from .models import (
    Fusion,
    Config,
    Monster,
    MonsterItem,
    Deck,
    Phase,
    Trigger,
    Grave,
    Hand,
    UserPoint,
    MonsterEffectWrapper,
    EndChainEffect,
    CostWrapper,
    DuelDeck,
    DuelGrave,
    DuelHand,
    FieldSize,
    TriggerTiming,
    Timing,
    PacWrapper,
    PacCostWrapper,
    EternalEffect,
    VirtualVariable,
    EternalTrigger,
    UnderDirection,
    TriggerTimingChangeVal,
    TriggerTimingNotEffected,
    TriggerTimingMonsterChangeVal,
    TriggerTimingRelation,
)
from django.db.models import Q
from django.db import reset_queries
import inspect
import json
import re
import os
import uuid
from django.db import connection
import random
import copy
from pprint import pprint
import inspect
import numpy as np
from time import time
import html

class DuelObj:
    invoke_flag = False
    def __init__(self, room_number):
        pass

    def copy_monster_from_deck(self, monster, deck_id, mine_or_other):
        # 移動した場合idをorg_idに戻す
        monster["id"] = monster["org_id"]
        if "from2" in monster:
            del monster["from2"]
        if "from_field_kind" in monster:
            del monster["from_field_kind"]
        monster["from"] = "deck"
        monster["from_deck_id"] = deck_id
        if "eternal" in monster:
            for key in reversed(range(len(monster["eternal"]))):
                if "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        monster["flag"] = 0
        monster["turncount"] = self.duel.turn_count
        if "rel" in monster:
            del monster["rel"]
        return monster

    def copy_monster_from_under(self, monster):
        # 移動した場合idをorg_idに戻す
        monster["id"] = monster["org_id"]
        if "eternal" in monster:
            for key in reversed(range(len(monster["eternal"]))):
                if "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        monster["flag"] = 0
        monster["turncount"] = self.duel.turn_count
        if "rel" in monster:
            del monster["rel"]
        return monster

    def copy_monster_from_grave(self, monster, deck_id, mine_or_other):
        # 移動した場合idをorg_idに戻す
        monster["id"] = monster["org_id"]
        monster["flag"] = 0
        monster["from"] = "grave"
        monster["from_deck_id"] = deck_id
        if "from2" in monster:
            del monster["from2"]
        if "from_field_kind" in monster:
            del monster["from_field_kind"]
        if "eternal" in monster:
            for key in reversed(range(len(monster["eternal"]))):
                if monster["eternal"][key] is None or "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        if "rel" in monster:
            del monster["rel"]
        monster["turncount"] = self.duel.turn_count
        return monster

    def copy_monster_from_hand(self, monster, deck_id, mine_or_other):
        # 移動した場合idをorg_idに戻す
        monster["id"] = monster["org_id"]
        monster["flag"] = 0
        monster["from"] = "hand"
        monster["from_deck_id"] = deck_id
        if "from2" in monster:
            del monster["from2"]
        if "from_field_kind" in monster:
            del monster["from_field_kind"]
        if "rel" in monster:
            del monster["rel"]
        if "eternal" in monster and monster["eternal"] is not None:
            for key in reversed(range(len(monster["eternal"]))):
                if monster["eternal"][key] is None or "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        monster["turncount"] = self.duel.turn_count
        return monster

    def copy_monster_from_field(self, monster, kind, mine_or_other):
        monster["from2"] = "field"
        monster["from_field_kind"] = kind
        monster["from_field_mine_or_other"] = mine_or_other
        return monster

    def copy_monster_to_deck(
        self, monster, deck_id, mine_or_other, variable_names=None
    ):
        duel = self.duel
        # 移動した場合idをorg_idに戻す
        monster["id"] = monster["org_id"]
        monster["flag"] = 0
        if "etenral" in monster:
            del monster["eternal"] 
        if "under" in monster:
            direction = UnderDirection.objects.filter(
                Q(to_place_kind=1) | Q(to_place_kind=0)
            )
            direction = direction.filter(to_deck__id=deck_id)
            if self.user == 1:
                mine_or_other2 = mine_or_other
            elif self.user == 2:
                if mine_or_other == 1:
                    mine_or_other2 = 2
                elif mine_or_other == 2:
                    mine_or_other2 = 1
                else:
                    mine_or_other2 = mine_or_other
            direction = direction.filter(Q(to_mine_or_other=mine_or_other2) | Q(to_mine_or_other = 0))
            direction = direction.first()
            mine_or_other2 = direction.dest_mine_or_other
            dest = direction.dest_place_kind
            shuffle = direction.shuffle
            if dest == 1:
                deck_id = direction.dest_deck.id
                self.move_unders_to_deck(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 2:
                deck_id = direction.dest_grave.id
                self.move_unders_to_grave(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 3:
                deck_id = direction.dest_hand.id
                self.move_unders_to_hand(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            del monster["under"]

        monster["place_unique_id"] = str(uuid.uuid4())
        monster["place"] = "deck"
        monster["mine_or_other"] = mine_or_other
        monster["deck_id"] = deck_id
        monster["turncount"] = self.duel.turn_count
        if "kind" in monster:
            del monster["kind"]
        if "rel" in monster:
            del monster["rel"]
        return monster

    def copy_monster_to_grave(
        self, monster, deck_id, mine_or_other, variable_names=None
    ):
        duel = self.duel
        # 移動した場合idをorg_idに戻す
        monster["flag"] = 0
        if "eternal" in monster and monster["eternal"] is not None:
            for key in reversed(range(len(monster["eternal"]))):
                if monster["eternal"][key] is None or "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        if "under" in monster:
            direction = UnderDirection.objects.filter(
                Q(to_place_kind=2) | Q(to_place_kind=0)
            )
            direction = direction.filter(to_grave__id=deck_id)
            if self.user == 1:
                mine_or_other2 = mine_or_other
            elif self.user == 2:
                if mine_or_other == 1:
                    mine_or_other2 = 2
                elif mine_or_other == 2:
                    mine_or_other2 = 1
                else:
                    mine_or_other2 = mine_or_other
            direction = direction.filter(Q(to_mine_or_other=mine_or_other2) | Q(to_mine_or_other = 0))
            direction = direction.first()
            dest = direction.dest_place_kind
            shuffle = direction.shuffle
            mine_or_other2 = direction.dest_mine_or_other
            if dest == 1:
                deck_id = direction.dest_deck.id
                self.move_unders_to_deck(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 2:
                deck_id = direction.dest_grave.id
                self.move_unders_to_grave(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 3:
                deck_id = direction.dest_hand.id
                self.move_unders_to_hand(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            del monster["under"]
        monster["id"] = monster["org_id"]
        monster["place_unique_id"] = str(uuid.uuid4())
        monster["place"] = "grave"
        monster["mine_or_other"] = mine_or_other
        monster["deck_id"] = deck_id
        monster["turncount"] = self.duel.turn_count
        if "kind" in monster:
            del monster["kind"]
        if "rel" in monster:
            del monster["rel"]
        return monster

    def copy_monster_to_hand(
        self, monster, deck_id, mine_or_other, variable_names=None
    ):
        duel = self.duel
        # 移動した場合idをorg_idに戻す
        monster["flag"] = 0
        if "eternal" in monster and monster["eternal"] is not None:
            for key in reversed(range(len(monster["eternal"]))):
                if monster["eternal"][key] is None or "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        if "under" in monster:
            direction = UnderDirection.objects.filter(
                Q(to_place_kind=3) | Q(to_place_kind=0)
            )
            direction = direction.filter(to_hand__id=deck_id)
            if self.user == 1:
                mine_or_other2 = mine_or_other
            elif self.user == 2:
                if mine_or_other == 1:
                    mine_or_other2 = 2
                elif mine_or_other == 2:
                    mine_or_other2 = 1
                else:
                    mine_or_other2 = mine_or_other
            direction = direction.filter(Q(to_mine_or_other=mine_or_other2) | Q(to_mine_or_other = 0))
            direction = direction.first()
            dest = direction.dest_place_kind
            shuffle = direction.shuffle
            mine_or_other2 = direction.dest_mine_or_other
            if dest == 1:
                deck_id = direction.dest_deck.id
                self.move_unders_to_deck(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 2:
                deck_id = direction.dest_grave.id
                self.move_unders_to_grave(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 3:
                deck_id = direction.dest_hand.id
                self.move_unders_to_hand(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            del monster["under"]
        monster["id"] = monster["org_id"]
        monster["place_unique_id"] = str(uuid.uuid4())
        monster["place"] = "hand"
        monster["mine_or_other"] = mine_or_other
        monster["deck_id"] = deck_id
        monster["turncount"] = self.duel.turn_count
        if "kind" in monster:
            del monster["kind"]
        if "rel" in monster:
            del monster["rel"]
        return monster

    def copy_monster_to_under(
        self, monster, deck_id, x, y, mine_or_other, variable_names=None, field=None
    ):
        duel = self.duel
        # 移動した場合idをorg_idに戻す
        if "eternal" in monster and monster["eternal"] is not None:
            for key in reversed(range(len(monster["eternal"]))):
                if monster["eternal"][key] is None or "persist" not in monster["eternal"][key]:
                    monster["eternal"].pop(key)
        if "under" in monster:
            direction = UnderDirection.objects.filter(
                Q(to_place_kind=5) | Q(to_place_kind=0)
            )
            if self.user == 1:
                mine_or_other2 = mine_or_other
            elif self.user == 2:
                if mine_or_other == 1:
                    mine_or_other2 = 2
                elif mine_or_other == 2:
                    mine_or_other2 = 1
                else:
                    mine_or_other2 = mine_or_other
            direction = direction.filter(Q(to_mine_or_other=mine_or_other2) | Q(to_mine_or_other = 0))
            direction = direction.first()
            dest = direction.dest_place_kind
            shuffle = direction.shuffle
            mine_or_other2 = direction.dest_mine_or_other
            if dest == 1:
                deck_id = direction.dest_deck.id
                self.move_unders_to_deck(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 2:
                deck_id = direction.dest_grave.id
                self.move_unders_to_grave(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 3:
                deck_id = direction.dest_hand.id
                self.move_unders_to_hand(
                    monster["under"], deck_id, shuffle, mine_or_other2
                )
            elif dest == 5:
                if "under" in monster:
                    for under in monster["under"]:
                        field["under"].append(under)
            del monster["under"]
        monster["id"] = monster["org_id"]
        monster["place_unique_id"] = str(uuid.uuid4())
        monster["place"] = "hand"
        monster["mine_or_other"] = mine_or_other
        monster["deck_id"] = deck_id
        monster["turncount"] = self.duel.turn_count
        if "kind" in monster:
            del monster["kind"]
        field["under"].append(monster)
        if "rel" in monster:
            del monster["rel"]
        return field

    def move_unders_to_deck(self, unders, deck_id, shuffle, mine_or_other2):
        duel = self.duel
        if self.user == 1:
            other_user = 2
        else:
            other_user = 1
        for under in unders:
            if mine_or_other2 == 1:
                deck = self.decks[deck_id]["mydeck"]
            elif mine_or_other2 == 2:
                deck = self.decks[deck_id]["otherdeck"]
            elif mine_or_other2 == 3:
                deck = self.decks[deck_id]["commondeck"]
            elif mine_or_other2 == 4:
                if self.user == under["owner"]:
                    deck = self.decks[deck_id]["mydeck"]
                elif other_user == under["owner"]:
                    deck = self.decks[deck_id]["otherdeck"]
                else:
                    deck = self.decks[deck_id]["commondeck"]
            under["turncount"] = self.duel.turn_count
            user_decks = deck
            user_decks.append(under)
            if shuffle is True:
                np.random.shuffle(user_decks)
            if mine_or_other2 == 1:
                self.decks[deck_id]["mydeck"] = user_decks
            elif mine_or_other2 == 2:
                self.decks[deck_id]["otherdeck"] = user_decks
            elif mine_or_other2 == 3:
                self.decks[deck_id]["commondeck"] = user_decks
            elif mine_or_other2 == 4:
                if self.user == under["owner"]:
                    self.decks[deck_id]["mydeck"] = user_decks
                elif other_user == under["owner"]:
                    self.decks[deck_id]["otherdeck"] = user_decks
                else:
                    self.decks[deck_id]["commondeck"] = user_decks

    def move_unders_to_grave(self, unders, deck_id, shuffle, mine_or_other2):
        duel = self.duel
        if self.user == 1:
            other_user = 2
        else:
            other_user = 1
        for under in unders:
            if mine_or_other2 == 1:
                grave = self.graves[deck_id]["mygrave"]
            elif mine_or_other2 == 2:
                grave = self.graves[deck_id]["othergrave"]
            elif mine_or_other2 == 3:
                grave = self.graves[deck_id]["commongrave"]
            elif mine_or_other2 == 4:
                if self.user == under["owner"]:
                    grave = self.graves[deck_id]["mygrave"]
                elif other_user == under["owner"]:
                    grave = self.graves[deck_id]["othergrave"]
                else:
                    grave = self.graves[deck_id]["commongrave"]
            user_graves = grave
            under["turncount"] = self.duel.turn_count
            user_graves.append(under)
            if shuffle is True:
                np.random.shuffle(user_graves)
            if mine_or_other2 == 1:
                self.graves[deck_id]["mygrave"] = user_graves
            elif mine_or_other2 == 2:
                self.graves[deck_id]["othergrave"] = user_graves
            elif mine_or_other2 == 3:
                self.graves[deck_id]["commongrave"] = user_graves
            elif mine_or_other2 == 4:
                if self.user == under["owner"]:
                    self.graves[deck_id]["mygrave"] = user_graves
                elif other_user == under["owner"]:
                    self.graves[deck_id]["othergrave"] = user_graves
                else:
                    self.graves[deck_id]["commongrave"] = user_graves

    def move_unders_to_hand(self, unders, deck_id, shuffle, mine_or_other2):
        duel = self.duel
        if self.user == 1:
            other_user = 2
        else:
            other_user = 1
        for under in unders:
            if mine_or_other2 == 1:
                hand = self.hands[deck_id]["myhand"]
            elif mine_or_other2 == 2:
                hand = self.hands[deck_id]["otherhand"]
            elif mine_or_other2 == 3:
                hand = self.hands[deck_id]["commonhand"]
            elif mine_or_other2 == 4:
                if self.user == under["owner"]:
                    hand = self.hands[deck_id]["myhand"]
                elif other_user == under["owner"]:
                    hand = self.hands[deck_id]["otherhand"]
                else:
                    hand = self.hands[deck_id]["commonhand"]
            under["turncount"] = self.duel.turn_count
            user_hands = hand
            user_hands.append(under)
            if shuffle is True:
                np.random.shuffle(user_hands)
            if mine_or_other2 == 1:
                self.hands[deck_id]["myhand"] = user_hands
            elif mine_or_other2 == 2:
                self.hands[deck_id]["otherhand"] = user_hands
            elif mine_or_other2 == 3:
                self.hands[deck_id]["commonhand"] = user_hands
            elif mine_or_other2 == 4:
                if self.user == under["owner"]:
                    self.hands[deck_id]["myhand"] = user_hands
                elif other_user == under["owner"]:
                    self.hands[deck_id]["otherhand"] = user_hands
                else:
                    self.hands[deck_id]["commonhand"] = user_hands

    def copy_monster_to_field(self, monster, x, y, mine_or_other, variable_names):
        duel = self.duel
        monster = copy.deepcopy(monster)
        monster["place_unique_id"] = str(uuid.uuid4())
        monster["place"] = "field"
        monster["deck_id"] = 0
        monster["x"] = x
        monster["y"] = y
        monster["mine_or_other"] = mine_or_other
        #monster["turncount"] = duel.turn_count
        if "kind" in monster:
            del monster["kind"]
        return monster

    def check_eternal_invalid(
        self, monster, user, effect_kind, place, deck_id, x, y, mine_or_other=-1
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 2
        )

    def check_no_choose(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        index=None,
        cost=0,
    ):
        id = self.get_monster_id(monster, place, user, deck_id, 0, 0, mine_or_other)
        monster_det = Monster.objects.get(id=id)
        eternals = monster_det.eternal_effect.all().filter(
            Q(eternal_effect_val=0) or Q(eternal_effect_val=3)
        )
        place_unique_id = monster["place_unique_id"]
        for eternal in eternals:
            tmps = json.loads(eternal.eternal_monster)
            tmps = tmps["monster"]
            if eternal.eternal_effect_val != 0 and eternal.eternal_effect_val != 3:
                continue
            tmp = {}
            if index is not None:
                tmp["index"] = index
            tmp["eternal"] = copy.deepcopy(eternal)
            tmp["effect_val"] = eternal.eternal_effect_val
            tmp["kind"] = eternal.eternal_kind
            tmp["priority"] = eternal.priority
            tmp["user"] = user
            if "already" in monster:
                tmp["already"] = monster["already"]
            else:
                tmp["already"] = 0
            tmp["place"] = place
            tmp["deck_id"] = deck_id
            tmp["x"] = x
            tmp["y"] = y
            tmp["place_unique_id"] = place_unique_id
            tmp["mine_or_other"] = mine_or_other
            self.invoke_eternal_effect_det(tmp, user)
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 1, cost
        )

    def check_not_effected(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        cost=None,
        amount = 0
    ):
        id = self.get_monster_id(monster, place, user, deck_id, 0, 0, mine_or_other)
        monster_det = Monster.objects.get(id=id)
        eternals = monster_det.eternal_effect.all().filter(eternal_effect_val=0)
        decks = self.deck_structure
        graves = self.grave_structure
        hands = self.hand_structure
        place_unique_id = monster["place_unique_id"]
        flag = True
        if not hasattr(self, "not_effected"):
            self.not_effected = []
        elif place_unique_id in self.not_effected:
            flag = False
        else:
            self.not_effected.append(place_unique_id)
        if place == "deck":
            tmp_deck = decks.filter(id=deck_id).get()
            if tmp_deck.eternal is True:
                flag = False
        if place == "grave":
            tmp_deck = graves.filter(id=deck_id).get()
            if tmp_deck.eternal is True:
                flag = False
        if place == "hand":
            tmp_deck = hands.filter(id=deck_id).get()
            if tmp_deck.eternal is True:
                flag = False
        if flag is True:
            for eternal in eternals:
                tmp = {}
                tmp["eternal"] = copy.deepcopy(eternal)
                tmp["effect_val"] = eternal.eternal_effect_val
                tmp["kind"] = eternal.eternal_kind
                tmp["priority"] = eternal.priority
                tmp["user"] = user
                if "already" in monster:
                    tmp["already"] = monster["already"]
                else:
                    tmp["already"] = 0
                tmp["place"] = place
                tmp["deck_id"] = deck_id
                tmp["place_unique_id"] = place_unique_id
                tmp["x"] = x
                tmp["y"] = y
                tmp["mine_or_other"] = mine_or_other
                self.invoke_eternal_effect_det(tmp, user)
        if place_unique_id in self.not_effected:
            self.not_effected.remove(place_unique_id)
        result =  self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 0, cost
        )
        tmp2 = {}
        tmp2["det"] = monster
        tmp2["mine_or_other"] = mine_or_other
        tmp2["user"] = user
        tmp2["place"] = place
        tmp2["deck_id"] = deck_id
        tmp2["x"] = x
        tmp2["y"] = y
        tmp2["place_unique_id"] = monster["place_unique_id"]
        if result is True:
            self.raise_trigger_not_effected(tmp2, amount, cost, effect_kind, user, 1)
        return result

    def check_invoke_invalid(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 3, persist
        )

    def check_no_invoke(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 5, persist
        )

    def check_ignore_chain_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 8, persist
        )

    def check_ignore_chain_user_only_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 9, persist
        )

    def check_ignore_chain_kind_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 10, persist
        )

    def check_ignore_same_chain_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 11, persist
        )

    def check_ignore_same_monster_chain_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 12, persist
        )

    def check_ignore_same_monster_exist_chain_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 13, persist
        )

    def check_ignore_phase_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 14, persist
        )

    def check_ignore_mine_or_other_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 15, persist
        )

    def check_ignore_no_invoke_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 16, persist
        )

    def check_ignore_timing_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 17, persist
        )

    def check_ignore_turn_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 19, persist
        )

    def check_ignore_monster_condition_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 20, persist
        )

    def check_ignore_monster_variable_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 21, persist
        )

    def check_ignore_monster_place_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 18, persist
        )

    def check_ignore_monster_place_condition_func(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        persist=0,
    ):
        return self.check_eternal_det(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other, 22, persist
        )

    def check_swap_init_val(
            self, monster, user, place, deck_id, x, y, val_name, mine_or_other=-1, persist=0
    ):
        tmp = self.check_eternal_det(
            monster,
            user,
            "-1",
            place,
            deck_id,
            x,
            y,
            mine_or_other,
            24,
            persist,
            val_name,
        )
        return tmp
    def check_swap_val(
        self, monster, user, place, deck_id, x, y, val_name, mine_or_other=-1, persist=0
    ):
        tmp = self.check_eternal_det(
            monster,
            user,
            "-1",
            place,
            deck_id,
            x,
            y,
            mine_or_other,
            7,
            persist,
            val_name,
        )
        return tmp

    def check_change_name(self, monster, user, place, deck_id, x, y, mine_or_other=-1):
        return_tmp = []
        return_tmp.append(monster["monster_name"])
        if "eternal" in monster and monster["eternal"] is not None:
            for i in range(len(monster["eternal"])):
                if monster["eternal"][i] is None:
                    continue
                if not self.check_eternal_invalid(
                    monster,
                    user,
                    monster["eternal"][i]["effect_kind"],
                    place,
                    deck_id,
                    x,
                    y,
                    mine_or_other,
                ):
                    if "monster_name" in monster["eternal"][i]:
                        if monster["eternal"][i]["monster_name"][
                            "add"
                            ] == 1:
                            return_tmp.append(monster["eternal"][i]["monster_name"])
                        else:
                            return_tmp = []
                            return_tmp.append( monster["eternal"][i]["monster_name"])
                else:
                    del monster["eternal"][i]
        tmp = self.check_eternal_det(
        monster,
        user,
        "-1",
        place,
        deck_id,
        x,
        y,
        mine_or_other,
        25,
        0, 
        return_tmp)
        if tmp != None:
            return_tmp = []
            return_tmp.append( tmp)
        return_tmp = self.check_eternal_det(
        monster,
        user,
        "-1",
        place,
        deck_id,
        x,
        y,
        mine_or_other,
        26,
        0, 
        return_tmp)
        return return_tmp

    def check_change_val(
        self, monster, user, place, deck_id, x, y, val_name, mine_or_other=-1, return_value=0,persist=0
    ):
        if monster is None:
            return 0
        if "eternal" in monster and monster["eternal"] is not None:
            for i in range(len(monster["eternal"])):
                if monster["eternal"][i] is None:
                    continue
                if not self.check_eternal_invalid(
                    monster,
                    user,
                    monster["eternal"][i]["effect_kind"],
                    place,
                    deck_id,
                    x,
                    y,
                    mine_or_other,
                ):
                    if val_name in monster["eternal"][i]["variables"]:
                        return_tmp = monster["eternal"][i]["variables"][val_name][
                            "value"
                        ]
                        if monster["eternal"][i]["variables"][val_name][
                            "add"
                            ] == 1:
                            return_value = return_tmp
                        elif self.is_float(return_tmp):
                            return_value += float(return_tmp)
                        else:
                            return return_tmp

                else:
                    del monster["eternal"][i]   
        if place == "field":
            flag = True
        else:
            if place == "deck":
                deckobj = Deck.objects.get(id = deck_id)
                flag = deckobj.eternal
            elif place == "grave":
                graveobj = Grave.objects.get(id = deck_id)
                flag = graveobj.eternal
            elif place == "hand":
                handobj = Hand.objects.get(id = deck_id)
                flag = handobj.eternal
            else:
                flag = True
        if flag is False:
            id = self.get_monster_id(monster, place, user, deck_id, 0, 0, mine_or_other)
            monster_det = Monster.objects.get(id=id)
            eternals = monster_det.eternal_effect.all().filter(eternal_effect_val=1)
            place_unique_id = monster["place_unique_id"]
            for eternal in eternals:
                tmps = json.loads(eternal.eternal_monster)
                tmps = tmps["monster"]
                tmp = {}
                tmp["monster"] = monster
                tmp["eternal"] = copy.deepcopy(eternal)
                tmp["effect_val"] = eternal.eternal_effect_val
                tmp["kind"] = eternal.eternal_kind
                tmp["priority"] = eternal.priority
                tmp["user"] = user
                if "already" in monster:
                    tmp["already"] = monster["already"]
                else:
                    tmp["already"] = 0
                tmp["place"] = place
                tmp["deck_id"] = deck_id
                tmp["x"] = x
                tmp["y"] = y
                tmp["place_unique_id"] = place_unique_id
                tmp["mine_or_other"] = mine_or_other
                self.invoke_eternal_effect_det(tmp, user)

        tmp_value = self.check_eternal_det(
            monster,
            user,
            "-1",
            place,
            deck_id,
            x,
            y,
            mine_or_other,
            4,
            persist,
            val_name,
        )
        if tmp_value is True:
            tmp_value = 0
        if self.is_float(return_value) and self.is_float(tmp_value) and tmp_value != 0.0:
            return_value = float(return_value) + float(tmp_value)
        return return_value

    def check_change_dest(
        self, monster, user, place, deck_id, x, y, val_name, mine_or_other=-1, persist=0
    ):
        return self.check_eternal_det(
            monster,
            user,
            "-1",
            place,
            deck_id,
            x,
            y,
            mine_or_other,
            6,
            persist,
            val_name,
        )

    def check_variable_instead(
        self, variable_id, mine_or_other, change_val, cost_or_effect, user, effect_kind
    ):
        return self.check_eternal_det(
            None,
            user,
            effect_kind,
            "",
            0,
            0,
            0,
            mine_or_other,
            23,
            0,
            variable_id,
            cost_or_effect,
            change_val,
        )

    def check_eternal_det(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other=-1,
        mode=0,
        persist=0,
        val_name=None,
        cost_or_effect=None,
        change_val2=0,
    ):
        user = int(user)
        if user == 1:
            other_user = 2
        elif user == 2:
            other_user = 1
        duel = self.duel
        field = self.field
        effect_kinds = effect_kind
        mine_or_other = int(mine_or_other)
        if monster is not None:
            tmp2 = {}
            tmp2["det"] = monster
            tmp2["mine_or_other"] = mine_or_other
            tmp2["user"] = user
            tmp2["place"] = place
            tmp2["deck_id"] = deck_id
            tmp2["x"] = x
            tmp2["y"] = y
            tmp2["place_unique_id"] = monster["place_unique_id"]

        name_flag= False 
        if duel.in_cost is True:
            chain_user = json.loads(duel.chain_user)
            chain_user = chain_user[str(self.tmp_chain)]
        elif duel.chain == 0 or duel.ask > 0:
            chain_user = self.user  
        else:
            chain_user = json.loads(duel.chain_user)
            chain_user = chain_user[str(duel.chain - 1)]
        if mode == 0:
            condition = self.not_effected_eternal_effect
            choose = 0
        elif mode == 1:
            condition = self.no_choose_eternal_effect
            choose = 0
        elif mode == 2:
            condition = self.not_eternal_effect
            choose = 2
        elif mode == 3:
            condition = self.invoke_invalid_eternal_effect
            choose = 2
        elif mode == 4:
            condition = self.change_val_eternal_effect
            change_val = 0
            choose = 2
        elif mode == 25:
            condition = self.change_name_eternal_effect
            choose = 2
            name_flag = True
        elif mode == 26:
            condition = self.change_name_add_eternal_effect
            choose = 2
            name_flag = True
        elif mode == 5:
            condition = self.no_invoke_eternal_effect
            choose = 2
        elif mode == 6:
            dest_flag = False
            condition = self.change_destination_eternal_effect
            change_val = 0
            choose = 2
        elif mode == 7:
            condition = self.swap_val_eternal_effect
            change_val = 0
            choose = 2
        elif mode == 8:
            condition = self.check_ignore_chain
            change_val = 0
            choose = 0
        elif mode == 9:
            condition = self.check_ignore_chain_user_only
            change_val = 0
            choose = 0
        elif mode == 10:
            condition = self.check_ignore_chain_kind
            change_val = 0
            choose = 0
        elif mode == 11:
            condition = self.check_ignore_same_chain
            change_val = 0
            choose = 0
        elif mode == 12:
            condition = self.check_ignore_same_monster_chain
            change_val = 0
            choose = 0
        elif mode == 13:
            condition = self.check_ignore_same_monster_exist_chain
            change_val = 0
            choose = 0
        elif mode == 14:
            condition = self.check_ignore_phase
            change_val = 0
            choose = 0
        elif mode == 15:
            condition = self.check_ignore_mine_or_other
            change_val = 0
            choose = 0
        elif mode == 16:
            condition = self.check_ignore_no_invoke
            change_val = 0
            choose = 0
        elif mode == 17:
            condition = self.check_ignore_timing
            change_val = 0
            choose = 0
        elif mode == 18:
            condition = self.check_monster_place_condition
            change_val = 0
            choose = 0
        elif mode == 19:
            condition = self.check_turn
            change_val = 0
            choose = 0
        elif mode == 20:
            condition = self.check_monster_condition_list
            change_val = 0
            choose = 0
        elif mode == 21:
            condition = self.check_monster_variable
            change_val = 0
            choose = 0
        elif mode == 22:
            condition = self.check_monster_place_condition
            change_val = 0
            choose = 0
        elif mode == 23:
            condition = self.take_variable_instead
        elif mode == 24:
            condition = self.swap_init_val_eternal_effect
            change_val = 0
            choose = 2
        if mode !=2:
            if("monster" in condition):
                if self.check_eternal_invalid(
                    condition["monster"],
                    condition["mine_or_other"],
                    effect_kind,
                    condition["place"],
                    condition["deck_id"],
                    condition["x"],
                    condition["y"],
                    condition["mine_or_other"],
                ):
                    if mode == 4:
                        return 0
                    elif mode == 25 or mode == 26:
                        return val_name
                    elif mode == 7 or mode == 24:
                        return val_name
                    elif mode == 14:
                        return []
                    elif mode == 17:
                        return []
                    elif mode == 21:
                        return []
                    else:
                        return False

        for not_effected in condition:
            this_monster = {}
            this_monster["det"] = not_effected["monster"]
            this_monster["mine_or_other"] = not_effected["mine_or_other"]
            this_monster["user"] = not_effected["user"]
            this_monster["place"] = not_effected["place"]
            this_monster["deck_id"] = not_effected["deck_id"]
            this_monster["x"] = not_effected["x"]
            this_monster["y"] = not_effected["y"] 
            this_monster["place_unique_id"] = monster["place_unique_id"]
            if "place_unique_id" not in not_effected:
                not_effected["place_unique_id"] = ""
            if "tmp_val" in not_effected:
                self.tmp_val[not_effected["place_unique_id"]] = not_effected["tmp_val"]
            eternal_mine_or_other = not_effected["mine_or_other"]
            if persist == 1:
                if "persist" not in not_effected or not_effected["persist"] == 0:
                    continue
            invalid_kinds = not_effected["invalid_kinds"]
            kind_flag = False
            if cost_or_effect is not None:
                if not_effected["cost_or_effect"] == 1 and cost_or_effect == 0:
                    continue
                elif not_effected["cost_or_effect"] == 2 and cost_or_effect == 1:
                    continue
            if "-1" == invalid_kinds:
                kind_flag = True
            else:
                if self.check_effect_kind(invalid_kinds, effect_kinds):
                    kind_flag = True
            if kind_flag is False:
                continue
            place_unique_id = not_effected["place_unique_id"]
            eternals = not_effected["eternal"]
            eternal_effect = copy.deepcopy(eternals)
            if mode == 25 or mode == 26:
                eternal_values = eternal_effect.value.split("_")
            if mode == 4:
                eternal_names = eternal_effect.val_name.split("_")
                eternal_values = eternal_effect.value.split("_")
                if val_name not in eternal_names:
                    continue
                val_key = eternal_names.index(val_name)
            if mode == 23:
                global_variable = eternal_effect.eternal_global_variable
                global_variable = global_variable.split("_")
                variable_name = global_variable[0]
                if variable_name != val_name:
                    return 0
                variable_mine_or_other = int(global_variable[1])
                eternal_values = eternal_effect.value
                val_key = 0
            if mode == 7 or mode == 24:
                eternal_names = eternal_effect.val_name.split("_")
                eternal_values = eternal_effect.value.split("_")
                if val_name not in eternal_names:
                    return val_name
                else:
                    val_key = eternal_names.index(val_name)
                    swap = eternal_values[val_key]
            if mode == 6:
                # 行き先変更永続
                # フィールドはうまくいかない
                eternal_names = json.loads(eternal_effect.val_name)
                eternal_values = json.loads(eternal_effect.value)
                val_name_det = val_name.split("_")
                if mine_or_other == 1:
                    mine_or_other_other = 2
                elif mine_or_other == 2:
                    mine_or_other_other = 1
                if val_name_det[2] == "4":
                    if monster["owner"] == mine_or_other:
                        val_name_det[2] = "1"
                    elif monster["owner"] != mine_or_other_other:
                        val_name_det[2] = "2"
                    else:
                        val_name_det[2] = "3"
                for eternal_name in eternal_names:
                    eternal_name_det = eternal_name["det"].split("_")
                    if val_name_det[0] != eternal_name_det[0]:
                        continue
                    if int(val_name_det[1]) != int(eternal_name_det[1]):
                        continue
                    if eternal_name_det[2] == val_name_det[2]:
                        dest_flag = True

            if mode == 6 and dest_flag is False:
                continue
            if monster is None and eternals.invalid_none_monster:
                if mode == 5:
                    return True
                    
                if mode == 14:
                    return not_effected["phases"]
                if mode == 17:
                    return not_effected["timings"]
                if mode == 21:
                    return not_effected["ignore_variable"]
                if mode == 23:
                    if not_effected["place"] == "field":
                        x = not_effected["x"]
                        y = not_effected["y"]
                        place_unique_id = not_effected["place_unique_id"]
                        if self.config.sort is True:
                            x = self.search_place_unique_id(y,place_unique_id)
                            if x == -1:
                                return 0
                        else:
                            if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                return 0
                        if mine_or_other == 1:
                            if (
                                int(field[x][y]["mine_or_other"])
                                != int(variable_mine_or_other)
                                and mine_or_other != -1
                            ):
                                return 0
                        else:
                            if (
                                int(field[x][y]["mine_or_other"])
                                == int(variable_mine_or_other)
                                and mine_or_other != -1
                            ):
                                return 0
                        monster_effect = json.loads(eternals.invalid_monster)
                        eternal_det = monster_effect["monster"][0]["monster"]

                        if (
                            "relation" in eternal_det
                            and len(eternal_det["relation"]) != 0
                        ):
                            relate_monster = not_effected["relate_monster"][0][
                                "monster"
                            ]
                            x = relate_monster["x"]
                            y = relate_monster["y"]
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,relate_monster["place_unique_id"])
                                if x == -1:
                                    return 0
                            if (
                                relate_monster["place_unique_id"]
                                == field[x][y]["det"]["place_unique_id"]
                            ):
                                if mode == 25:
                                    return eternal_values[0]
                                elif mode == 26:
                                    for eternal_value in eternal_values:
                                        val_name.append(eternal_value)
                                    return val_name

                                tmp3 = {}
                                tmp3["det"] = field[x][y]["det"]
                                tmp3["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp3["user"] = field[x][y]["mine_or_other"]
                                tmp3["place"] = "field"
                                tmp3["deck_id"] = 0
                                tmp3["x"] = x
                                tmp3["y"] = y
                                tmp3["place_unique_id"] = place_unique_id
                            change_val = min(
                                change_val2,
                                self.calculate_boland(
                                    eternal_effect.eternal_tmp_val, tmp3, None, True,eternal = True
                                ),
                            )
                        else:
                            if variable_mine_or_other == 1:
                                if (
                                    int(field[x][y]["mine_or_other"])
                                    != int(mine_or_other)
                                    and mine_or_other != -1
                                ):
                                    return 0
                            elif variable_mine_or_other == 2:
                                if (
                                    int(field[x][y]["mine_or_other"])
                                    == int(mine_or_other)
                                    and mine_or_other != -1
                                ):
                                    return 0
                            tmp3 = {}
                            tmp3["det"] = field[x][y]["det"]
                            tmp3["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp3["user"] = field[x][y]["mine_or_other"]
                            tmp3["place"] = "field"
                            tmp3["deck_id"] = 0
                            tmp3["x"] = x
                            tmp3["y"] = y
                            tmp3["place_unique_id"] = place_unique_id
                            change_val = min(
                                change_val2,
                                self.calculate_boland(
                                    eternal_values[val_key], tmp3, None, True,eternal = True
                                ),
                            )
                        change_val_eternal = {}
                        if "persist" in monster_effect:
                            if monster_effect["persist"][0] is True:
                                change_val_eternal["persist"] = True
                        change_val_eternal["variables"] = {}
                        change_val_eternal[
                            "monster_variable_change_life"
                        ] = monster_effect["monster_variable_change_life"][0]
                        change_val_eternal[
                            "monster_variable_change_life_length"
                        ] = monster_effect["monster_variable_change_life_length"][0]
                        change_val_eternal["effect_kind"] = monster_effect[
                            "monster_variable_change_effect_kind"
                        ][0]
                        for index in range(
                            len(monster_effect["monster_variable_change_name"])
                        ):
                            variable_name = monster_effect[
                                "monster_variable_change_name"
                            ][index]
                            if "monster_variable_change_initial" in monster_effect:
                                ini = monster_effect[
                                    "monster_variable_change_initial"
                                ][index]
                            else:
                                ini = False
                            if "monster_variable_change_add" in monster_effect:
                                add = monster_effect[
                                    "monster_variable_change_add"
                                ][index]
                            else:
                                add = 0
                            change_val_eternal["variables"][variable_name] = {}
                            change_val_eternal["variables"][variable_name][
                                "value"
                            ] = -float(change_val)
                            change_val_eternal["variables"][variable_name][
                                "ini"
                            ] = ini
                            change_val_eternal["variables"][variable_name][
                                "add"
                            ] = add
                        if "eternal" not in field[x][y]["det"]:
                            field[x][y]["det"]["eternal"] = []
                        field[x][y]["det"]["eternal"].append(change_val_eternal)
                        self.field = field
                        return change_val

                else:
                    return True
            eternal_org = eternals
            eternals = json.loads(eternals.invalid_monster)
            exclude = eternals["exclude"]
            eternals = eternals["monster"]
            mine_or_other_effect = not_effected["mine_or_other_effect"]
            if mine_or_other_effect == 0:
                pass
            elif mine_or_other_effect == 1:
                if int(not_effected["mine_or_other"]) != int(chain_user):
                    continue
            elif mine_or_other_effect == 2:
                if int(not_effected["mine_or_other"]) == int(chain_user):
                    continue
            for eternal in eternals:
                if exclude == "trigger":
                    if place_unique_id == monster["place_unique_id"]:
                        continue

                eternal_det = eternal["monster"]
                if "relation" in eternal_det and len(eternal_det["relation"]) != 0:
                    for relate_monster in not_effected["relate_monster"]:
                        if (
                            relate_monster["monster"]["place_unique_id"]
                            == monster["place_unique_id"]
                        ):
                            if mode == 25:
                                return eternal_values[0]
                            elif mode == 26:
                                for eternal_value in eternal_values:
                                    val_name.append( eternal_value)
                                return val_name
                            if mode == 4:
                                if (
                                    relate_monster["monster"]["mine_or_other"]
                                    == chain_user
                                ):
                                    change_val += self.calculate_boland(
                                        eternal_values[val_key], tmp2, None, True,eternal = True
                                    )
                                else:
                                    change_val += self.calculate_boland(
                                        eternal_values[val_key], tmp2, True, 1, eternal = True
                                    )
                            elif mode == 6:
                                return eternal_values
                            elif mode == 7 or mode == 24:
                                return swap
                            elif mode == 14:
                                return not_effected["phases"]
                            elif mode == 17:
                                return not_effected["timings"]
                            elif mode == 21:
                                return not_effected["ignore_variable"]
                            elif mode == 23:
                                if not_effected["global_variable"] != val_name:
                                    continue
                                return_tmp = min(
                                    self.calculate_boland(
                                        not_effected["tmp_val"],
                                        relate_monster["monster"],
                                        eternal = True
                                    ),
                                    change_val,
                                )
                                self.damage_monster(
                                    monster, not_effected["val_name"], return_tmp
                                )

                                return return_tmp
                            else:
                                return True
                elif eternal["as_monster_condition"] == "trigger":
                    if place_unique_id == monster["place_unique_id"]:
                        if mode == 25:
                            return eternal_values[0]
                        elif mode == 26:
                            for eternal_value in eternal_values:
                                 val_name.append( eternal_value)
                            return val_name
                        if mode == 4:
                            if monster["mine_or_other"] == chain_user:
                                change_val += self.calculate_boland(
                                    eternal_values[val_key], tmp2, False, 1,eternal = True
                                )
                            else:
                                change_val += self.calculate_boland(
                                    eternal_values[val_key], tmp2, True, 1,eternal = True
                                )
                        elif mode == 6:
                            return eternal_values
                        elif mode == 7 or mode == 24:
                            return swap
                        elif mode == 14:
                            return not_effected["phases"]
                        elif mode == 17:
                            return not_effected["timings"]
                        elif mode == 21:
                            return not_effected["ignore_variable"]
                        else:
                            return True
                if not eternal_det["place"]:
                    continue
                for place_det in eternal_det["place"]:
                    place_det_det = place_det["det"].split("_")
                    place_mine_or_other = int(place_det_det[2])
                    if place == place_det_det[0]:
                        if place == "field":
                            if eternal_mine_or_other == 1:
                                mine_or_other2 = place_mine_or_other
                            elif eternal_mine_or_other == 2:
                                if place_mine_or_other == 1:
                                    mine_or_other2 = 2
                                elif place_mine_or_other == 2:
                                    mine_or_other2 = 1
                                else:
                                    mine_or_other2 = place_mine_or_other
                            if mine_or_other == 0 or mine_or_other == -1:
                                pass
                            elif mine_or_other2 != field[x][y]["mine_or_other"]:
                                continue
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                kind = kind.split("_")
                            if place_det_det[1] in kind:
                                if self.check_monster_condition_det(
                                    eternal,
                                    monster,
                                    user,
                                    effect_kind,
                                    choose,
                                    None,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    not_effected["place_unique_id"],
                                    monster_check = this_monster,
                                    name_flag = name_flag
                                ):
                                    if mode == 4:
                                        if user == chain_user:
                                            change_val += self.calculate_boland(
                                                eternal_values[val_key], tmp2, None, True,eternal = True
                                            )
                                        else:
                                            change_val += self.calculate_boland(
                                                eternal_values[val_key], tmp2, True, 1,eternal = True
                                            )
                                    elif mode == 7 or mode == 24:
                                        return swap
                                    elif mode == 14:
                                        return not_effected["phases"]
                                    elif mode == 17:
                                        return not_effected["timings"]
                                    elif mode == 21:
                                        return not_effected["ignore_variable"]
                                    elif mode == 25:
                                        return eternal_values[0]
                                    elif mode == 26:
                                        for eternal_value in eternal_values:
                                            val_name.append( eternal_value)
                                        return val_name
                                    else:
                                        return True
                        elif place == "under":
                            if eternal_mine_or_other == 1:
                                mine_or_other2 = place_mine_or_other
                            elif eternal_mine_or_other == 2:
                                if place_mine_or_other == 1:
                                    mine_or_other2 = 2
                                elif place_mine_or_other == 2:
                                    mine_or_other2 = 1
                                else:
                                    mine_or_other2 = place_mine_or_other
                            if mine_or_other == 0 or mine_or_other == -1:
                                pass
                            elif mine_or_other2 != field[x][y]["mine_or_other"]:
                                continue
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                kind = kind.split("_")
                            if place_det_det[1] in kind:
                                if self.check_monster_condition_det(
                                        eternal,
                                        monster,
                                        user,
                                        effect_kind,
                                        choose,
                                        None,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        not_effected["place_unique_id"],
                                        monster_check = this_monster,
                                        name_flag = name_flag
                                ):
                                    if mode == 4:
                                        if user == chain_user:
                                            change_val += self.calculate_boland(
                                                eternal_values[val_key], tmp2, None, True,eternal = True
                                            )
                                        else:
                                            change_val += self.calculate_boland(
                                                eternal_values[val_key], tmp2, True, 1,eternal = True
                                            )
                                    elif mode == 6:
                                        return eternal_values
                                    elif mode == 7 or mode == 24:
                                        return swap
                                    elif mode == 14:
                                        return not_effected["phases"]
                                    elif mode == 17:
                                        return not_effected["timings"]
                                    elif mode == 21:
                                        return not_effected["ignore_variable"]
                                    elif mode == 25:
                                        return eternal_values[0]
                                    elif mode == 26:
                                        for eternal_value in eternal_values:
                                            val_name.append( eternal_value)
                                        return val_name
                                    else:
                                        return True
                        else:
                            if int(place_det_det[1]) == int(deck_id):
                                place_mine_or_other = int(place_det_det[2])
                                if int(mine_or_other) == -1:
                                    pass
                                elif (
                                    place_mine_or_other == 1
                                    and mine_or_other == eternal_mine_or_other
                                ) or (
                                    place_mine_or_other == 2
                                    and mine_or_other != eternal_mine_or_other
                                ):
                                    pass
                                else:
                                    if place_mine_or_other == 3:
                                        pass
                                    else:
                                        continue
                            else:
                                continue
                            if self.check_monster_condition_det(
                                eternal,
                                monster,
                                user,
                                effect_kind,
                                choose,
                                place_det_det[0],
                                place_det_det[1],
                                0,
                                0,
                                mine_or_other,
                                0,
                                not_effected["place_unique_id"],
                                monster_check = this_monster,
                                name_flag = name_flag
                            ):
                                if mode == 4:
                                    if user == chain_user:
                                        change_val += self.calculate_boland(
                                            eternal_values[val_key], tmp2, None, True
                                        )
                                    else:
                                        change_val += self.calculate_boland(
                                            eternal_values[val_key], tmp2, True, 1
                                        )
                                elif mode == 25: 
                                    return eternal_values[0]
                                elif mode == 26:
                                    for eternal_value in eternal_values:
                                        val_name.append( eternal_value)
                                    return val_name
                                elif mode == 7 or mode == 24:
                                    return swap
                                elif mode == 14:
                                    return not_effected["phases"]
                                elif mode == 17:
                                    return not_effected["timings"]
                                elif mode == 21:
                                    return not_effected["ignore_variable"]
                                elif mode == 25:
                                    return eternal_values[0]
                                elif mode == 26:
                                    for eternal_value in eternal_values:
                                        val_name.append( eternal_value)
                                    return val_name
                                else:
                                    return True
        if mode == 4:
            return change_val
        elif mode == 25:
            return val_name[0]
        elif mode == 26:
            return val_name
        elif mode == 7 or mode == 24:
            return val_name
        elif mode == 14:
            return []
        elif mode == 17:
            return []
        elif mode == 21:
            return []
        else:
            return False

    def check_monster_condition_det(
        self,
        monster_condition: object,
        monster: object,
        user: object,
        effect_kind="",
        choose=0,
        place=None,
        deck_id=0,
        x=0,
        y=0,
        mine_or_other=-1,
        cost_flag=0,
        eternal_place_unique_id = "",
        monster_check = None,
        name_flag = False
    ):
        #if user != self.user:
        #    other_user_flag2 = True
        #else:
        #謎多分Falseでいいと思われる
        other_user_flag2 = False
        field = self.field
        if monster_check is None:
            monster2 = {}
            monster2["det"] = monster
            monster2["mine_or_other"] = mine_or_other
            monster2["user"] = user
            monster2["place"] = place
            monster2["deck_id"] = deck_id
            monster2["x"] = x
            monster2["y"] = y
            monster2["place_unique_id"] = monster["place_unique_id"]
        else:
            monster2 = monster_check
        monster_condition = monster_condition["monster"]
        flag = monster_condition["flag"]
        if (choose == 1 or choose == 3) and effect_kind != "":
            if self.check_no_choose(
                monster,
                user,
                effect_kind,
                place,
                deck_id,
                x,
                y,
                mine_or_other,
                cost_flag,
            ):
                return False
        elif (choose == 2 or choose == 3) and effect_kind != "":
            if self.check_not_effected(
                monster,
                user,
                effect_kind,
                place,
                deck_id,
                x,
                y,
                mine_or_other,
                cost_flag,
            ):
                return False
        if "under" in monster_condition:
            if not self.check_under(monster_condition["under"], monster, monster2):
                return False
        if flag is not None and flag != "":
            flag_det = int(flag["flag_det"])
            if flag["operator"] == "=":
                if monster["flag"] != int(flag_det):
                    return False
            elif flag["operator"] == "&":
                if monster["flag"] & int(flag_det) == 0:
                    return False
            elif flag["operator"] == "^":
                if monster["flag"] & int(flag_det) != 0:
                    return False
        if (
            "place_unique_id" in monster_condition
            and monster_condition["place_unique_id"] != ""
        ):
            if monster["place_unique_id"] != self.get_place_unique_id(
                monster_condition["place_unique_id"]
            ):
                return False
        if "unique_id" in monster_condition and monster_condition["unique_id"] != "":
            if monster["card_unique_id"] != self.get_card_unique_id(
                monster_condition["unique_id"]
            ):
                return False
        if (
            "effect_valid" in monster_condition
            and monster_condition["effect_valid"] != ""
            and monster_condition["effect_valid"] is not None
        ):
            if self.check_eternal_invalid(
                monster,
                mine_or_other,
                str(monster_condition["effect_valid"]),
                place,
                deck_id,
                x,
                y,
                mine_or_other,
            ):
                return False
        if (
            "monster_effect" in monster_condition
            and monster_condition["monster_effect"] != 0
            and monster_condition["monster_effect"] != "0"
            and monster_condition["monster_effect"] != ""
            and monster_condition["monster_effect"] is not None
        ):
            id = self.get_monster_id(monster, place, user, deck_id, x, y, mine_or_other)
            monster_effect_monster_ary = str(monster_condition["monster_effect"]).split("_")
            monster_effect_flag = False
            for monster_effect_monster  in monster_effect_monster_ary:
                if monster_effect_monster[0] == "!":
                    if id == int(monster_effect_monster[1:]):
                        return False
                    else:
                        monster_effect_flag = True

                elif id == int(monster_effect_monster):
                    monster_effect_flag = True
                    break
            if monster_effect_flag is False:
                return False

        monster_name_kind = monster_condition["monster_name_kind"]
        current_and_or = "and"
        if(name_flag is False):
            monster_names = self.check_change_name(monster, user, place, deck_id, x, y, -1)
        else:
            monster_names = [monster["monster_name"]]
        cond_flag = True
        for name_kind in monster_name_kind:
            if name_kind != "":
                tmp_flag = False
                for monster_name in monster_names:
                    if name_kind["operator"] == "=":
                        if monster_name == self.get_name(
                            name_kind["monster_name"], 0, monster,eternal_place_unique_id
                        ):
                            tmp_flag = True
                    elif name_kind["operator"] == "!=":
                        if monster_name != self.get_name(
                            name_kind["monster_name"], 0, monster
                        ):
                            tmp_flag = True

                    elif name_kind["operator"] == "like":
                        if (
                            monster_name.find(
                                self.get_name(name_kind["monster_name"], 0, monster)
                            )
                            != -1
                        ):
                            tmp_flag = True
                    else:
                            tmp_flag = True
                if current_and_or == "and":
                    if cond_flag is True:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = False

                else:
                    if cond_flag is False:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = True
                current_and_or = name_kind["and_or"]
        if cond_flag is False:
            return False
        if (
                "place" in monster_condition
                and monster_condition["place"] 
        ):
            tmp_flag = False
            for place_tmp2 in monster_condition["place"]:
                place_det = place_tmp2["det"].split("_")
                if place_det[0] == "field":
                    if monster["place"] == "field":
                        if int(field[monster["x"]][monster["y"]]["kind"]) == int(place_det[1]):
                            tmp_flag = True
                elif place_det[0] == monster["place"]:
                    if int(place_det[1]) == int(monster["deck_id"]):
                        tmp_flag = True
                else:
                    tmp_flag = True
            if tmp_flag is False:
                return False
        if (
            "place_from" in monster_condition
            and monster_condition["place_from"] is not None
        ):
            tmp_flag = False
            for place_from in monster_condition["place_from"]:
                place_from_det = place_from["place"].split("_")
                if place_from_det[0] == "field":
                    if "from2" in monster and monster["from2"] == "field":
                        if int(monster["from_field_kind"]) == int(place_from_det[1]):
                            tmp_flag = True
                elif place_from_det[0] == monster["from"]:
                    if int(place_from_det[1]) == int(monster["from_deck_id"]):
                        tmp_flag = True
                else:
                    tmp_flag = True
            if tmp_flag is False:
                return False
        if "turn_count" in monster_condition and monster_condition["turn_count"] != "":
            if (
                self.calculate_boland(monster_condition["turn_count"], monster2, False,other_user_flag2 = other_user_flag2,user =user)
                != monster["turncount"]
            ):
                return False

        monster_condition_val = monster_condition["field_y"]
        for cond_det in monster_condition_val:
            cond_flag = True
            current_and_or = "and"
            tmp_flag = True

            for cond_val in cond_det:
                if not cond_val:
                    continue
                name = self.check_swap_val(
                    monster, user, place, deck_id, x, y, cond_val["name"], -1
                )
                name2 = self.check_swap_init_val(
                    monster, user, place, deck_id, x, y, cond_val["name"], -1
                )
                tmp = monster["variables"][name2]
                if not cond_val["num"].isnumeric() and not self.special_val(cond_val["num"][0]):
                    value = self.check_change_val(
                        monster, user, place, deck_id, x, y, name, mine_or_other,tmp["value"])
                    if value.isnumeric():
                        if cond_val["operator"] == "!=":
                            tmp_flag = True
                        else:
                            tmp_flag = False
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag
                            else:
                                cond_flag = False
                        else:
                            if cond_flag is True:
                                cond_flag = True
                            else:
                                cond_flag = tmp_flag
                        current_and_or = cond_val["and_or"]
                        continue
                    else:
                        if cond_val["operator"] == "=":
                            if value == cond_val["num"]:
                                tmp_flag = True
                            else:
                                tmp_flag = False
                        elif cond_val["operator"] == "":
                            values = value.split("_")
                            if cond_val["num"] in values:
                                tmp_flag = True
                            else:
                                tmp_flag = False
                        elif cond_val["operator"] == "!=":
                            if value == cond_val["num"]:
                                tmp_flag = False
                            else:
                                tmp_flag = True
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag
                            else:
                                cond_flag = False
                        else:
                            if cond_flag is True:
                                cond_flag = True
                            else:
                                cond_flag = tmp_flag
                        current_and_or = cond_val["and_or"]
                        continue
                if not tmp["value"].isnumeric():
                    value = self.check_change_val(
                        monster, user, place, deck_id, x, y, name, mine_or_other,tmp["value"])
                    if cond_val["operator"] == "!=":
                        if cond_val["num"] == value["value"]:
                            tmp_flag = False
                        else:
                            tmp_flag = True
                    elif cond_val["operator"] == "":
                        values = value.split("_")
                        if cond_val["num"] in values:
                            tmp_flag = True
                        else:
                            tmp_flag = False

                    elif cond_val["operator"] != "=":
                        tmp_flag = False
                    else:
                        if cond_val["num"] == value:
                            tmp_flag = True
                        else:
                            tmp_flag = False
                    if current_and_or == "and":
                        if cond_flag is True:
                            cond_flag = tmp_flag
                        else:
                            cond_flag = False
                    else:
                        if cond_flag is False:
                            cond_flag = tmp_flag
                        else:
                            cond_flag = True
                    current_and_or = cond_val["and_or"]
                    continue
                if cond_val["init"] == 0:
                    value = self.check_change_val(
                        monster, user, place, deck_id, x, y, name, mine_or_other,int(tmp["value"])
                    )
                elif cond_val["init"] == 1:
                    value = tmp["i_val"]
                elif cond_val["init"] == 2:
                    value = tmp["i_i_val"]
                if tmp["minus"] is False and float(value) < 0:
                    value = 0
                if cond_val["operator"] == "=": 
                    if float(value) != self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "":
                        values = str(value).split("_")
                        for index in range(len(values)):
                            values[index] = int(float(values[index]))
                        if int(cond_val["num"]) not in values:
                            tmp_flag = False
                elif cond_val["operator"] == "!==":
                        values = str(value).split("_")
                        for index in range(len(values)):
                            values[index] = int(float(values[index]))
                        if int(cond_val["num"]) in values:
                            tmp_flag = False
                elif cond_val["operator"] == "<=":
                    if float(value) > self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == ">=":
                    if float(value) < self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "!=":
                    if float(value) == self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                if current_and_or == "and":
                    if cond_flag is True:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = False

                else:
                    if cond_flag is False:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = True
                current_and_or = cond_val["and_or"]
                tmp_flag = True
            if cond_flag is False:
                return False
        monster_condition_val = monster_condition["field_x"]
        field_x_operators = monster_condition["field_x_operator"]
        field_x_and_or = monster_condition["field_x_and_or"]
        i =0
        for cond_val in monster_condition_val:
            cond_flag = True
            current_and_or = "and"
            tmp_flag = True

            if not cond_val:
                continue
            value = monster["x"]
            pprint(value)
            if field_x_operators[i] == "=": 
                if float(value) != self.calculate_boland(
                    cond_val, monster2, False,other_user_flag2 = other_user_flag2,user =user
                ):
                    tmp_flag = False
            elif field_x_operators[i] == "":
                    values = str(value).split("_")
                    for index in range(len(values)):
                        values[index] = int(float(values[index]))
                    if int(cond_val) not in values:
                        tmp_flag = False
            elif field_x_operators[i] == "!==":
                    values = str(value).split("_")
                    for index in range(len(values)):
                        values[index] = int(float(values[index]))
                    if int(cond_val) in values:
                        tmp_flag = False
            elif field_x_operators[i] == "<=":
                if float(value) > self.calculate_boland(
                    cond_val, monster2, False,other_user_flag2 = other_user_flag2,user =user
                ):
                    tmp_flag = False
            elif field_x_operators[i] == ">=":
                if float(value) < self.calculate_boland(
                    cond_val, monster2, False,other_user_flag2 = other_user_flag2,user =user
                ):
                    tmp_flag = False
            elif field_x_operators[i] == "!=":
                if float(value) == self.calculate_boland(
                    cond_val, monster2, False,other_user_flag2 = other_user_flag2,user =user
                ):
                    tmp_flag = False
            if current_and_or == "and":
                if cond_flag is True:
                    cond_flag = tmp_flag
                else:
                    cond_flag = False

            else:
                if cond_flag is False:
                    cond_flag = tmp_flag
                else:
                    cond_flag = True
            current_and_or = field_x_and_or[i]
            tmp_flag = True
            i+=1
        if cond_flag is False:
            return False
        monster_condition_val = monster_condition["monster_condition"]
        for cond_det in monster_condition_val:
            cond_flag = True
            current_and_or = "and"
            tmp_flag = True

            for cond_val in cond_det:
                if not cond_val:
                    continue
                name = self.check_swap_val(
                    monster, user, place, deck_id, x, y, cond_val["name"], -1
                )
                name2 = self.check_swap_init_val(
                    monster, user, place, deck_id, x, y, cond_val["name"], -1
                )
                tmp = monster["variables"][name2]
                if not cond_val["num"].isnumeric() and not self.special_val(cond_val["num"][0]):
                    value = self.check_change_val(
                        monster, user, place, deck_id, x, y, name, mine_or_other,tmp["value"])
                    if value.isnumeric():
                        if cond_val["operator"] == "!=":
                            tmp_flag = True
                        else:
                            tmp_flag = False
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag
                            else:
                                cond_flag = False
                        else:
                            if cond_flag is True:
                                cond_flag = True
                            else:
                                cond_flag = tmp_flag
                        current_and_or = cond_val["and_or"]
                        continue
                    else:
                        if cond_val["operator"] == "=":
                            if value == cond_val["num"]:
                                tmp_flag = True
                            else:
                                tmp_flag = False
                        elif cond_val["operator"] == "":
                            values = value.split("_")
                            if cond_val["num"] in values:
                                tmp_flag = True
                            else:
                                tmp_flag = False
                        elif cond_val["operator"] == "!=":
                            if value == cond_val["num"]:
                                tmp_flag = False
                            else:
                                tmp_flag = True
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag
                            else:
                                cond_flag = False
                        else:
                            if cond_flag is True:
                                cond_flag = True
                            else:
                                cond_flag = tmp_flag
                        current_and_or = cond_val["and_or"]
                        continue
                if not tmp["value"].isnumeric():
                    value = self.check_change_val(
                        monster, user, place, deck_id, x, y, name, mine_or_other,tmp["value"])
                    if cond_val["operator"] == "!=":
                        if cond_val["num"] == value["value"]:
                            tmp_flag = False
                        else:
                            tmp_flag = True
                    elif cond_val["operator"] == "":
                        values = value.split("_")
                        if cond_val["num"] in values:
                            tmp_flag = True
                        else:
                            tmp_flag = False

                    elif cond_val["operator"] != "=":
                        tmp_flag = False
                    else:
                        if cond_val["num"] == value:
                            tmp_flag = True
                        else:
                            tmp_flag = False
                    if current_and_or == "and":
                        if cond_flag is True:
                            cond_flag = tmp_flag
                        else:
                            cond_flag = False
                    else:
                        if cond_flag is False:
                            cond_flag = tmp_flag
                        else:
                            cond_flag = True
                    current_and_or = cond_val["and_or"]
                    continue
                if cond_val["init"] == 0:
                    value = self.check_change_val(
                        monster, user, place, deck_id, x, y, name, mine_or_other,int(tmp["value"])
                    )
                elif cond_val["init"] == 1:
                    value = tmp["i_val"]
                elif cond_val["init"] == 2:
                    value = tmp["i_i_val"]
                if tmp["minus"] is False and float(value) < 0:
                    value = 0
                if cond_val["operator"] == "=": 
                    if float(value) != self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "":
                        values = str(value).split("_")
                        for index in range(len(values)):
                            values[index] = int(float(values[index]))
                        if int(cond_val["num"]) not in values:
                            tmp_flag = False
                elif cond_val["operator"] == "!==":
                        values = str(value).split("_")
                        for index in range(len(values)):
                            values[index] = int(float(values[index]))
                        if int(cond_val["num"]) in values:
                            tmp_flag = False
                elif cond_val["operator"] == "<=":
                    if float(value) > self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == ">=":
                    if float(value) < self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "!=":
                    if float(value) == self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,user =user
                    ):
                        tmp_flag = False
                if current_and_or == "and":
                    if cond_flag is True:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = False

                else:
                    if cond_flag is False:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = True
                current_and_or = cond_val["and_or"]
                tmp_flag = True
            if cond_flag is False:
                return False
        if "relation" in monster_condition:
            relation_condition = monster_condition["relation"]
        else:
            relation_condition = []
        cond_flag = True
        current_and_or = "and"
        for index in range(len(relation_condition)):
            relation_name = monster_condition["relation"][index]
            if "relation_id" in monster_condition:
                relate_monster = monster_condition["relation_id"][index]
            else:
                relate_monster = ""
            relation_to = int(monster_condition["relation_to"][index])
            relation_kind = monster_condition["relation_kind"][index]
            if "relation_valid" in monster_condition:
                relate_valid = monster_condition["relation_valid"][index]
            else:
                relate_valid = ""
            if relation_name == "-2":
                tmp_flag = True
            else:
                tmp_flag = False

            if "rel" not in monster:
                if relation_name == "-2":
                    if current_and_or == "and":
                        pass
                    else:
                        cond_flag = True
                    continue
                else:
                    return False

            rel_det = monster["rel"]
            if relation_kind in monster["rel"]:
                for relation_det in rel_det[relation_kind]:
                    if relate_valid != "":
                        rel_monster_det = relation_det["monster"]
                        monster2 = self.get_monster(
                            rel_monster_det["place"],
                            rel_monster_det["place_unique_id"],
                            rel_monster_det["mine_or_other"],
                            rel_monster_det["user"],
                            rel_monster_det["deck_id"],
                            rel_monster_det["x"],
                            rel_monster_det["y"],
                        )
                        if self.check_eternal_invalid(
                                monster2["det"],
                                monster2["user"],
                                relate_valid,
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                monster2["mine_or_other"],
                        ):
                            tmp_flag = False
                            break
                    if relation_to == -1 or relation_to == int(relation_det["to"]):
                        if relation_name == "-2":
                            tmp_flag = False
                            break
                        elif (
                            relation_name == "-1"
                            or relation_name == ""
                            or relation_name == relation_det["name"]
                        ):
                            if relate_monster == "" or int(
                                relate_monster
                            ) == self.get_monster_id_easy(
                                relation_det["monster"]["det"]
                            ):
                                tmp_flag = True
                                break

            if current_and_or == "and":
                if cond_flag is True:
                    cond_flag = tmp_flag

            else:
                if cond_flag is False:
                    cond_flag = tmp_flag
            current_and_or = "and"
        if cond_flag is False:
            return False
        custom_monster_condition = monster_condition["custom_monster_condition"]
        for cond_det in custom_monster_condition:
            cond_flag = True
            current_and_or = "and"
            tmp_flag = True
            for cond_val in cond_det:
                if not cond_val:
                    continue
                name = self.check_swap_val(
                    monster, user, place, deck_id, x, y, cond_val["name"], -1
                )
                value = self.check_change_val(
                    monster, user, place, deck_id, x, y, name, -1
                )
                value = float(value)
                if cond_val["operator"] == "=" or cond_val["operator"] == "":
                    if str(value) != str(
                        self.calculate_boland(cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,mode = 1,user =user)
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "<=":
                    if int(value) > self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,mode = 1,user =user
                    ):

                        tmp_flag = False
                elif cond_val["operator"] == ">=":
                    if int(value) < self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,mode = 1,user =user
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "!=":
                    if int(value) == self.calculate_boland(
                        cond_val["num"], monster2, False,other_user_flag2 = other_user_flag2,mode = 1,user =user
                    ):
                        tmp_flag = False
                if current_and_or == "and":
                    if cond_flag is True:
                        cond_flag = tmp_flag

                else:
                    if cond_flag is False:
                        cond_flag = tmp_flag
                current_and_or = cond_val["and_or"]
                tmp_flag = True
            if cond_flag is False:
                return False
        return True

    def check_monster_condition(
        self,
        monster_conditions,
        user,
        cost_or_effect=False,
        monster=None,
        excludes=False,
        choose=0,
        effect_kind="",
        name_flag = False
    ):
        #if user != self.user:
        #    other_user_flag2 = True
        #else:
        #謎多分Falseでいいと思われる
        other_user_flag2 = False 
        choose = int(choose)
        duel = self.duel
        cost = self.cost
        mess = self.mess
        if str(self.tmp_chain) in cost:
            cost = cost[str(self.tmp_chain)]
        else:
            cost = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []

        timing_mess = self.timing_mess
        field = self.field
        actual_flag = False
        and_or_all = "and"
        flag = True
        for monster_condition in monster_conditions:
            as_flag = False
            count = 0
            variety = []
            same_name = {}
            variable_variety = []
            variable_counter = 0
            counter = -1
            x_counter = 0
            y_counter = 0
            exclude_flag = False
            equation_kind = monster_condition["equation"]["equation_kind"]
            if equation_kind == "x":
                counter = "x"
            elif equation_kind == "y":
                counter = "y"
            elif (
                equation_kind != "number"
                and equation_kind != "kind"
                and equation_kind != "same_name"
            ):
                counter = equation_kind
            place = monster_condition["monster"]["place"]
            if monster_condition["as_monster_condition"]:
                actual_flag = True
                as_flag = True
                as_monsters = monster_condition["as_monster_condition"].split(",")
                for as_monster in as_monsters:
                    if as_monster[0] != "~" and as_monster[0] != "%":
                        tmp = self.mess
                        if as_monster not in tmp[str(duel.chain - 1)]:
                            continue
                        monsters = tmp[str(duel.chain - 1)][as_monster]
                    elif as_monster[0] == "-":
                        tmp = self.mess
                        tmp = tmp[str(int(duel.chain - 2))]
                        if as_monster not in tmp[str(duel.chain - 2)]:
                            continue
                        monsters = tmp[as_monster]
                    elif as_monster[0] == "%":
                        tmp = self.timing_mess
                        if as_monster not in tmp:
                            continue
                        monsters = tmp[as_monster]
                    elif as_monster[0] == "~":
                        tmp = self.cost
                        if duel.in_cost is True:
                            if as_monster not in tmp[str(self.tmp_chain)]:
                                continue
                            monsters = tmp[str(self.tmp_chain)][as_monster]
                        else:
                            if as_monster not in tmp[str(duel.chain - 1)]:
                                continue
                            monsters = tmp[str(duel.chain - 1)][as_monster]
                    for monster2 in monsters:
                        if monster2["place"] == "field":
                            if field[monster2["x"]][monster2["y"]]["det"] is None:
                                continue
                            if (
                                field[monster2["x"]][monster2["y"]]["det"][
                                    "place_unique_id"
                                ]
                                != monster2["place_unique_id"]
                            ):
                                continue
                            if excludes:
                                exclude_flag = False
                                for exclude_det in excludes:
                                    if exclude_flag is True:
                                        break
                                        if exclude_det == "#trigger":
                                            if (
                                                field[monster2["x"]][monster2["y"]][
                                                    "det"
                                                ]["place_unique_id"]
                                                == monster["place_unique_id"]
                                            ):
                                                exclude_flag = True
                                                break

                                        if exclude_det in cost:
                                            for cost_det in cost[exclude_det]:
                                                if (
                                                    field[monster2["x"]][monster2["y"]][
                                                        "det"
                                                    ]["place_unique_id"]
                                                    == cost_det["det"][
                                                        "place_unique_id"
                                                    ]
                                                ):
                                                    exclude_flag = True
                                                    break
                                        if exclude_det[0] == "%":
                                            if exclude_det in timing_mess:
                                                for timing_det in timing_mess[
                                                    exclude_det
                                                ]:
                                                    if (
                                                        field[monster2["x"]][
                                                            monster2["y"]
                                                        ]["det"]["place_unique_id"]
                                                        == timing_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                        if exclude_det in mess:
                                            for mess_det in mess[exclude_det]:
                                                if (
                                                    field[monster2["x"]][monster2["y"]][
                                                        "det"
                                                    ]["place_unique_id"]
                                                    == mess_det["det"][
                                                        "place_unique_id"
                                                    ]
                                                ):
                                                    exclude_flag = True
                                                    break
                            if exclude_flag is True:
                                exclude_flag = False
                                continue
                        elif monster2["place"] == "deck":
                            flag = False
                            deck_id = monster2["deck_id"]
                            mine_or_other = int(monster2["mine_or_other"])
                            if 1 == self.user:
                                mine_or_other2 = mine_or_other
                            else:
                                if mine_or_other == 1:
                                    mine_or_other2 = 2
                                elif mine_or_other == 2:
                                    mine_or_other2 = 1
                                else:
                                    mine_or_other2 = mine_or_other
                            if mine_or_other2 == 1:
                                deck = self.decks[deck_id]["mydeck"]
                            elif mine_or_other2 == 2:
                                deck = self.decks[deck_id]["otherdeck"]
                            elif mine_or_other2 == 3:
                                deck = self.decks[deck_id]["commondeck"]
                            for tmp in deck:
                                if (
                                    tmp["place_unique_id"]
                                    == monster2["place_unique_id"]
                                ):
                                    if excludes:
                                        exclude_flag = False
                                        for exclude_det in excludes:
                                            if exclude_flag is True:
                                                break
                                            if exclude_det[0] == "~":
                                                if exclude_det in cost:
                                                    for cost_det in cost[exclude_det]:
                                                        if (
                                                            tmp["place_unique_id"]
                                                            == cost_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                                if exclude_det[0] == "%":
                                                    if exclude_det in timing_mess:
                                                        for timing_det in timing_mess[
                                                            exclude_det
                                                        ]:
                                                            if (
                                                                tmp["place_unique_id"]
                                                                == timing_det["det"][
                                                                    "place_unique_id"
                                                                ]
                                                            ):
                                                                exclude_flag = True
                                                                break
                                                if exclude_det in mess:
                                                    for mess_det in mess[exclude_det]:
                                                        if (
                                                            tmp["place_unique_id"]
                                                            == mess_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                    if exclude_flag is True:
                                        exclude_flag = False
                                        break
                                    flag = True
                                    break
                            if flag is False:
                                continue
                        elif monster2["place"] == "grave":
                            flag = False
                            deck_id = monster2["deck_id"]
                            mine_or_other = int(monster2["mine_or_other"])
                            if 1 == self.user:
                                mine_or_other2 = mine_or_other
                            else:
                                if mine_or_other == 1:
                                    mine_or_other2 = 2
                                elif mine_or_other == 2:
                                    mine_or_other2 = 1
                                else:
                                    mine_or_other2 = mine_or_other
                            if mine_or_other2 == 1:
                                grave = self.graves[deck_id]["mygrave"]
                            elif mine_or_other2 == 2:
                                grave = self.graves[deck_id]["othergrave"]
                            elif mine_or_other2 == 3:
                                grave = self.graves[deck_id]["commongrave"]
                            for tmp in grave:
                                if (
                                    tmp["place_unique_id"]
                                    == monster2["place_unique_id"]
                                ):
                                    if excludes:
                                        exclude_flag = False
                                        for exclude_det in excludes:
                                            if exclude_flag is True:
                                                break
                                            if exclude_det[0] == "~":
                                                if exclude_det in cost:
                                                    for cost_det in cost[exclude_det]:
                                                        if (
                                                            tmp["place_unique_id"]
                                                            == cost_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                                if exclude_det[0] == "%":
                                                    if exclude_det in timing_mess:
                                                        for timing_det in timing_mess[
                                                            exclude_det
                                                        ]:
                                                            if (
                                                                tmp["place_unique_id"]
                                                                == timing_det["det"][
                                                                    "place_unique_id"
                                                                ]
                                                            ):
                                                                exclude_flag = True
                                                                break
                                                if exclude_det in mess:
                                                    for mess_det in mess[exclude_det]:
                                                        if (
                                                            tmp["place_unique_id"]
                                                            == mess_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                    if exclude_flag is True:
                                        exclude_flag = False
                                        break
                                    flag = True
                                    break
                            if flag is False:
                                continue
                        elif monster2["place"] == "hand":
                            flag = False
                            deck_id = monster2["deck_id"]
                            mine_or_other = int(monster2["mine_or_other"])
                            if 1 == self.user:
                                mine_or_other2 = mine_or_other
                            else:
                                if mine_or_other == 1:
                                    mine_or_other2 = 2
                                elif mine_or_other == 2:
                                    mine_or_other2 = 1
                                else:
                                    mine_or_other2 = mine_or_other
                            if mine_or_other2 == 1:
                                hand = self.hands[deck_id]["myhand"]
                            elif mine_or_other2 == 2:
                                hand = self.hands[deck_id]["otherhand"]
                            elif mine_or_other2 == 3:
                                hand = self.hands[deck_id]["commonhand"]
                            for tmp in hand:
                                if (
                                    tmp["place_unique_id"]
                                    == monster2["place_unique_id"]
                                ):
                                    if excludes:
                                        exclude_flag = False
                                        for exclude_det in excludes:
                                            if exclude_flag is True:
                                                break
                                            if exclude_det[0] == "~":
                                                if exclude_det in cost:
                                                    for cost_det in cost[exclude_det]:
                                                        if (
                                                            tmp["place_unique_id"]
                                                            == cost_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                                if exclude_det[0] == "%":
                                                    if exclude_det in timing_mess:
                                                        for timing_det in timing_mess[
                                                            exclude_det
                                                        ]:
                                                            if (
                                                                tmp["place_unique_id"]
                                                                == timing_det["det"][
                                                                    "place_unique_id"
                                                                ]
                                                            ):
                                                                exclude_flag = True
                                                                break
                                                if exclude_det in mess:
                                                    for mess_det in mess[exclude_det]:
                                                        if (
                                                            tmp["place_unique_id"]
                                                            == mess_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                    if exclude_flag is True:
                                        exclude_flag = False
                                        break
                                    flag = True
                                    break
                            if flag is False:
                                continue
                        if (
                            self.check_monster_condition_det(
                                monster_condition,
                                monster2["det"],
                                user,
                                effect_kind,
                                choose,
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                monster2["mine_or_other"],
                                monster_check = monster,
                                name_flag = name_flag
                            )
                            is True
                        ):
                            if counter == "x":
                                x_counter += monster2["x"]
                            elif counter == "y":
                                y_counter += monster2["y"]
                            elif counter != -1:
                                variable = monster2["det"]["variables"][counter][
                                    "value"
                                ]
                                tmp_varieties = variable.split("_")
                                for tmp_variety in tmp_varieties:
                                    variable_variety.append(tmp_variety)
                                variable_counter += int(variable["value"])
                            if monster2["det"]["id"] not in variety:
                                variety.append(monster2["det"]["id"])
                            if monster2["det"]["monster_name"] not in same_name:
                                same_name[monster2["det"]["monster_name"]] = 0
                            same_name[monster2["det"]["monster_name"]] += 1
                            count += 1
            if place and as_flag is False:
                actual_flag = True
                for place_tmp in place:
                    place_tmp = place_tmp["det"].split("_")
                    deck_id = place_tmp[1]
                    mine_or_other = int(place_tmp[2])
                    if (user == 1 and mine_or_other == 1) or (
                        user == 2 and mine_or_other == 2
                    ):
                        mine_or_other = 1
                    elif (user == 1 and mine_or_other == 2) or (
                        user == 2 and mine_or_other == 1
                    ):
                        mine_or_other = 2
                    else:
                        mine_or_other = 3
                    if place_tmp[0] == "field":
                        if mine_or_other == 3:
                            mine_or_other = 0
                        field = self.field
                        for x in range(len(field)):
                            for y in range(len(field[x])):
                                if self.field_free is False:
                                    kind = field[x][y]["kind"]
                                else:
                                    kind = field[0][y]["kind"]
                                mine_or_other_field = field[x][y]["mine_or_other"]
                                # if user != 1:
                                #    if mine_or_other_field ==1:
                                #       mine_or_other_field = 2
                                #    elif mine_or_other_field ==2:
                                #        mine_or_other_field = 1
                                if kind != "":
                                    tmp = kind.split("_")
                                else:
                                    tmp = []
                                    tmp.append("99999")
                                if (
                                    deck_id in tmp
                                    and mine_or_other == mine_or_other_field
                                ):
                                    if (
                                        "det" in field[x][y]
                                        and field[x][y]["det"] is not None
                                    ):
                                        if (
                                            self.check_monster_condition_det(
                                                monster_condition,
                                                field[x][y]["det"],
                                                user,
                                                effect_kind,
                                                choose,
                                                "field",
                                                None,
                                                x,
                                                y,
                                                field[x][y]["mine_or_other"],
                                                monster_check = monster,
                                                name_flag = name_flag
                                            )
                                            is True
                                        ):
                                            if excludes:
                                                exclude_flag = False
                                                for exclude_det in excludes:
                                                    if exclude_flag is True:
                                                        break
                                                    if exclude_det == "#trigger":
                                                        if (
                                                                field[x][y][
                                                                    "det"
                                                                ]["place_unique_id"]
                                                                == monster["place_unique_id"]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                                    if exclude_det[0] == "~":
                                                        if exclude_det in cost:
                                                            for cost_det in cost[
                                                                exclude_det
                                                            ]:
                                                                if (
                                                                    field[x][y]["det"][
                                                                        "place_unique_id"
                                                                    ]
                                                                    == cost_det["det"][
                                                                        "place_unique_id"
                                                                    ]
                                                                ):
                                                                    exclude_flag = True
                                                                    break
                                                        if exclude_det[0] == "%":
                                                            if (
                                                                exclude_det
                                                                in timing_mess
                                                            ):
                                                                for (
                                                                    timing_det
                                                                ) in timing_mess[
                                                                    exclude_det
                                                                ]:
                                                                    if (
                                                                        field[x][y][
                                                                            "det"
                                                                        ][
                                                                            "place_unique_id"
                                                                        ]
                                                                        == timing_det[
                                                                            "det"
                                                                        ][
                                                                            "place_unique_id"
                                                                        ]
                                                                    ):
                                                                        exclude_flag = (
                                                                            True
                                                                        )
                                                                        break
                                                        if exclude_det in mess:
                                                            for mess_det in mess[
                                                                exclude_det
                                                            ]:
                                                                if (
                                                                    field[x][y]["det"][
                                                                        "place_unique_id"
                                                                    ]
                                                                    == mess_det["det"][
                                                                        "place_unique_id"
                                                                    ]
                                                                ):
                                                                    exclude_flag = True
                                                                    break
                                            if exclude_flag is True:
                                                exclude_flag = False
                                                continue
                                            count += 1
                                            if field[x][y]["det"]["id"] not in variety:
                                                variety.append(field[x][y]["det"]["id"])
                                            if (
                                                field[x][y]["det"]["monster_name"]
                                                not in same_name
                                            ):
                                                same_name[
                                                    field[x][y]["det"]["monster_name"]
                                                ] = 0
                                            same_name[
                                                field[x][y]["det"]["monster_name"]
                                            ] += 1

                                            if counter == "x":
                                                x_counter += x
                                            if counter == "y":
                                                y_counter += y
                                            if counter != -1:
                                                variable = field[x][y]["det"][
                                                    "variables"
                                                ][counter]
                                                tmp_varieties = variable["value"].split(
                                                    "_"
                                                )
                                                for tmp_variety in tmp_varieties:
                                                    if (
                                                        tmp_variety
                                                        not in variable_variety
                                                    ):
                                                        variable_variety.append(
                                                            tmp_variety
                                                        )
                                                variable_counter += int(
                                                    variable["value"]
                                                )

                    if (place_tmp[2] == "1" and user == self.user) or (
                        place_tmp[2] == "2" and user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and user != self.user) or (
                        place_tmp[2] == "2" and user == self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if (place_tmp[2] == "1" and user == 1) or (
                        place_tmp[2] == "2" and user != 1
                    ):
                        mine_or_other3 = 1
                    elif (place_tmp[2] == "1" and user != 1) or (
                        place_tmp[2] == "2" and user == 1
                    ):
                        mine_or_other3 = 2
                    else:
                        mine_or_other3 = 3
                    if place_tmp[0] == "deck":
                        deck_id = int(deck_id)
                        if mine_or_other2 == 1:
                            deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            deck = self.decks[deck_id]["otherdeck"]
                        elif mine_or_other2 == 3:
                            deck = self.decks[deck_id]["commondeck"]
                        for j in range(len(deck)):
                            if (
                                self.check_monster_condition_det(
                                    monster_condition,
                                    deck[j],
                                    user,
                                    effect_kind,
                                    choose,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    monster_check = monster,
                                                name_flag = name_flag
                                )
                                is True
                            ):
                                if excludes:
                                    exclude_flag = False
                                    for exclude_det in excludes:
                                        if exclude_flag is True:
                                            break
                                        if exclude_det == "#trigger":
                                            if (
                                                    deck[j]["place_unique_id"]
                                                    == monster["place_unique_id"]
                                            ):
                                                exclude_flag = True
                                                break
                                        if exclude_det[0] == "~":
                                            if exclude_det in cost:
                                                for cost_det in cost[exclude_det]:
                                                    if (
                                                        deck[j]["place_unique_id"]
                                                        == cost_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                            if exclude_det[0] == "%":
                                                if exclude_det in timing_mess:
                                                    for timing_det in timing_mess[
                                                        exclude_det
                                                    ]:
                                                        if (
                                                            deck[j]["place_unique_id"]
                                                            == timing_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                            if exclude_det in mess:
                                                for mess_det in mess[exclude_det]:
                                                    if (
                                                        deck[j]["place_unique_id"]
                                                        == mess_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                if exclude_flag is True:
                                    exclude_flag = False
                                    continue
                                if deck[j]["id"] not in variety:
                                    variety.append(deck[j]["id"])
                                if deck[j]["monster_name"] not in same_name:
                                    same_name[deck[j]["monster_name"]] = 0
                                same_name[deck[j]["monster_name"]] += 1
                                count += 1
                                if counter != -1:
                                    variable = deck[j]["variables"][counter]
                                    tmp_varieties = variable["value"].split("_")
                                    for tmp_variety in tmp_varieties:
                                        if tmp_variety not in variable_variety:
                                            variable_variety.append(tmp_variety)
                                    variable_counter += int(variable["value"])
                    if place_tmp[0] == "grave":
                        deck_id = int(deck_id)
                        if mine_or_other2 == 1:
                            grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            grave = self.graves[deck_id]["othergrave"]
                        elif mine_or_other2 == 3:
                            grave = self.graves[deck_id]["commongrave"]
                        for j in range(len(grave)):
                            if (
                                self.check_monster_condition_det(
                                    monster_condition,
                                    grave[j],
                                    user,
                                    effect_kind,
                                    choose,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    monster_check = monster,
                                                name_flag = name_flag
                                )
                                is True
                            ):
                                if excludes:
                                    exclude_flag = False
                                    for exclude_det in excludes:
                                        if exclude_flag is True:
                                            break
                                        if exclude_det == "#trigger":
                                            if (
                                                    grave[j]["place_unique_id"]
                                                    == monster["place_unique_id"]
                                            ):
                                                exclude_flag = True
                                                break
                                        if exclude_det[0] == "~":
                                            if exclude_det in cost:
                                                for cost_det in cost["det"][
                                                    exclude_det
                                                ]:
                                                    if (
                                                        grave[j]["place_unique_id"]
                                                        == cost_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                            if exclude_det[0] == "%":
                                                if exclude_det in timing_mess:
                                                    for timing_det in timing_mess[
                                                        exclude_det
                                                    ]:
                                                        if (
                                                            grave[j]["place_unique_id"]
                                                            == timing_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                            if exclude_det in mess:
                                                for mess_det in mess[exclude_det]:
                                                    if (
                                                        grave[j]["place_unique_id"]
                                                        == mess_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                if exclude_flag is True:
                                    exclude_flag = False
                                    continue
                                if grave[j]["id"] not in variety:
                                    variety.append(grave[j]["id"])
                                if grave[j]["monster_name"] not in same_name:
                                    same_name[grave[j]["monster_name"]] = 0
                                same_name[grave[j]["monster_name"]] += 1
                                count += 1
                                if counter != -1:
                                    variable = grave[j]["variables"][counter]
                                    tmp_varieties = variable["value"].split("_")
                                    for tmp_variety in tmp_varieties:
                                        if tmp_variety not in variable_variety:
                                            variable_variety.append(tmp_variety)
                                    variable_counter += int(variable["value"])
                    if place_tmp[0] == "hand":
                        deck_id = int(deck_id)
                        if mine_or_other2 == 1:
                            hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            hand = self.hands[deck_id]["otherhand"]
                        elif mine_or_other2 == 3:
                            hand = self.hands[deck_id]["commonhand"]
                        for j in range(len(hand)):
                            if (
                                self.check_monster_condition_det(
                                    monster_condition,
                                    hand[j],
                                    user,
                                    effect_kind,
                                    choose,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    monster_check = monster,
                                                name_flag = name_flag
                                )
                                is True
                            ):
                                if excludes:
                                    exclude_flag = False
                                    for exclude_det in excludes:
                                        if exclude_flag is True:
                                            break
                                        if exclude_det == "#trigger":
                                            if (
                                                    hand[j]["place_unique_id"]
                                                    == monster["place_unique_id"]
                                            ):
                                                exclude_flag = True
                                                break
                                        if exclude_det[0] == "~":
                                            if exclude_det in cost:
                                                for cost_det in cost[exclude_det]:
                                                    if (
                                                        hand[j]["place_unique_id"]
                                                        == cost_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                            if exclude_det[0] == "%":
                                                if exclude_det in timing_mess:
                                                    for timing_det in timing_mess[
                                                        exclude_det
                                                    ]:
                                                        if (
                                                            hand[j]["place_unique_id"]
                                                            == timing_det["det"][
                                                                "place_unique_id"
                                                            ]
                                                        ):
                                                            exclude_flag = True
                                                            break
                                            if exclude_det in mess:
                                                for mess_det in mess[exclude_det]:
                                                    if (
                                                        hand[j]["place_unique_id"]
                                                        == mess_det["det"][
                                                            "place_unique_id"
                                                        ]
                                                    ):
                                                        exclude_flag = True
                                                        break
                                if exclude_flag is True:
                                    exclude_flag = False
                                    continue
                                if hand[j]["id"] not in variety:
                                    variety.append(hand[j]["id"])
                                if hand[j]["monster_name"] not in same_name:
                                    same_name[hand[j]["monster_name"]] = 0
                                same_name[hand[j]["monster_name"]] += 1
                                count += 1
                                if counter != -1:
                                    variable = hand[j]["variables"][counter]
                                    tmp_varieties = variable["value"].split("_")
                                    for tmp_variety in tmp_varieties:
                                        if tmp_variety not in variable_variety:
                                            variable_variety.append(tmp_variety)
                                    variable_counter += int(variable["value"])
            min_equation_number = monster_condition["min_equation_number"]
            max_equation_number = monster_condition["max_equation_number"]
            if equation_kind == "number":
                if count >= float(self.calculate_boland(
                    min_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                )) and count <= float(self.calculate_boland(max_equation_number, monster,other_user_flag2 = other_user_flag2,user =user)):
                    if and_or_all == "or":
                        flag = True
                    elif flag is True:
                        flag = True
                else:
                    if and_or_all == "and":
                        flag = False
                    elif flag is False:
                        flag = False

            elif equation_kind == "kind":
                if len(variety) >= self.calculate_boland(
                    min_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                ) and len(variety) <= self.calculate_boland(
                    max_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                ):
                    if and_or_all == "or":
                        flag = True
                    elif flag is True:
                        flag = True
                else:
                    if and_or_all == "and":
                        flag = False
                    elif flag is False:
                        flag = False
            elif equation_kind == "same_name":
                if same_name:
                    same_name_max = max(same_name.values())
                else:
                    same_name_max = 0
                if (
                    same_name
                    and same_name_max
                    >= self.calculate_boland(min_equation_number, monster,other_user_flag2 = other_user_flag2,user =user)
                    and same_name_max
                    <= self.calculate_boland(max_equation_number, monster,other_user_flag2 = other_user_flag2,user =user)
                ):
                    if and_or_all == "or":
                        flag = True
                    elif flag is True:
                        flag = True
                else:
                    if and_or_all == "and":
                        flag = False
                    elif flag is False:
                        flag = False
            elif counter == "x":
                if x_counter >= self.calculate_boland(
                    min_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                ) and x_counter <= self.calculate_boland(max_equation_number, monster,other_user_flag2 = other_user_flag2,user =user):
                    if and_or_all == "or":
                        flag = True
                    elif flag is True:
                        flag = True
                else:
                    if and_or_all == "and":
                        flag = False
                    elif flag is False:
                        flag = False
            elif counter == "y":
                if y_counter >= self.calculate_boland(
                    min_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                ) and y_counter <= self.calculate_boland(max_equation_number, monster,other_user_flag2 = other_user_flag2,user =user):
                    if and_or_all == "or":
                        flag = True
                    elif flag is True:
                        flag = True
                else:
                    if and_or_all == "and":
                        flag = False
                    elif flag is False:
                        flag = False
            else:
                if len(variable_variety) >= self.calculate_boland(
                    min_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                ) and len(variable_variety) <= self.calculate_boland(
                    max_equation_number, monster,other_user_flag2 = other_user_flag2,user =user
                ):
                    if and_or_all == "or":
                        flag = True
                    elif flag is True:
                        flag = True
                else:
                    if and_or_all == "and":
                        flag = False
                    elif flag is False:
                        flag = False
            if "and_or" in monster_condition:
                and_or_all = monster_condition["and_or"]
            else:
                and_or_all = "and"
        # monsterが条件にない場合
        if actual_flag is False:
            return True
        return flag

    def check_eternal_effect_monster(self, eternal_effect, user, monster=0):
        if eternal_effect.eternal_effect_monster == "":
            return True
        eternal_effect_monster = json.loads(eternal_effect.eternal_effect_monster)
        eternal_effect_monster_condition = eternal_effect_monster[0]
        place = eternal_effect_monster[0]["place"]
        if "flag" in eternal_effect_monster:
            flag = eternal_effect_monster["flag"]
        else:
            flag = None
        if (
            self.check_eternal_effect_monster_det(
                place, flag, eternal_effect_monster_condition, monster, user
            )
            is False
        ):
            return False
        return True

    def check_trigger_monster(self, trigger, user, monster=0,move_from=0):
        if trigger.trigger_monster == "":
            return True
        if (
            self.check_trigger_monster_det(
                trigger.trigger_monster, monster, user, trigger,move_from
            )
            is False
        ):
            return False
        return True

    def check_eternal_effect_monster_det(
        self, places, flag_det, eternal_effect_monster_condition, monster, user
    ):
        if user == 1:
            user = 1
        else:
            user = 2

        monster_place = monster["place"]
        flag = False
        for place_tmp in places:
            place_tmp = place_tmp.split("_")
            place = place_tmp[0]
            if place == monster_place:
                if str(monster["deck_id"]).find(place_tmp[1]) == -1:
                    continue
                if (
                    place_tmp[2] == "1"
                    and user == self.user
                    or place_tmp[2] == "2"
                    and user != self.user
                ):
                    if int(monster["mine_or_other"]) != 1:
                        continue
                else:
                    if int(monster["mine_or_other"]) != 2:
                        continue
                flag = True
                break
        if flag is False:
            return False
        if self.check_monster_condition_det(
            eternal_effect_monster_condition["monster_monster"],
            monster["det"],
            user,
            "",
            0,
            monster["place"],
            monster["deck_id"],
            monster["x"],
            monster["y"],
            monster["mine_or_other"],
        ):
            return True
        else:
            return False

    def unique_fusion_effect(self):
        duel = self.duel
        tmp = self.mess
        chain_user = json.loads(duel.chain_user)
        user = int(chain_user[str(duel.chain-1)])
        if str(duel.chain - 1) not in tmp:
            tmp[str(duel.chain - 1)] = {}
        place1 = tmp[str(duel.chain - 1)]["fusion"]
        place = place1[0]
        if duel.is_ai is True and user == 2:
            fusion = Fusion.objects.get(id=place["fusion"]["id"])
        else:
            fusion = Fusion.objects.get(id=place["fusion"])
        return fusion.unique_effect
    def get_fusion_material(self,monster_effect,user,trigger,mode=0,effect_flag = 0,strategy = "",strategy_up_or_down =""):
        duel = self.duel
        tmp = self.mess
        if str(duel.chain - 1) not in tmp:
            tmp[str(duel.chain - 1)] = {}
        place1 = tmp[str(duel.chain - 1)]["fusion"]
        place = place1[0]
        if trigger.instead_condition:
            instead_condition = json.loads(trigger.instead_condition)
            if self.check_monster_effect_condition(
                    instead_condition, 0, 2):
                instead = True
            else:
                instead = False
        else:
            instead = True
        trigger_fusion1 = json.loads(trigger.fusion1)
        if(trigger.instead1):
            instead1 = json.loads(trigger.instead1)
        else:
            instead1 = None
        if(trigger.fusion2):
            trigger_fusion2 = json.loads(trigger.fusion2)
        else:
            trigger_fusion2 = None
        if(trigger.instead2):
            instead2 = json.loads(trigger.instead2)
        else:
            instead2 = None
        if(trigger.fusion3):
            trigger_fusion3 = json.loads(trigger.fusion3)
        else:
            trigger_fusion3 = None
        if(trigger.instead3):
            instead3 = json.loads(trigger.instead3)
        else:
            instead3 = None
        monster_id = self.get_monster_id(
            place["det"], place["place"], place["det"]["owner"],place["deck_id"],place["x"], place["y"], place["mine_or_other"])
        if user == 2 and duel.is_ai is True:
            fusion = Fusion.objects.get(id=place["fusion"]["id"])
        else:
            fusion = Fusion.objects.get(id=place["fusion"])
        fusion1 = json.loads(fusion.fusion1)
        if(fusion.fusion2):
            fusion2 = json.loads(fusion.fusion2)
        else:
            fusion2 = None
        if(fusion.fusion3):
            fusion3 = json.loads(fusion.fusion3)
        else:
            fusion3 = None
        if fusion1:
            fusion_monster1 = self.check_fusion_monster_det(trigger_fusion1,fusion1,instead1,fusion,user,mode = mode,effect_flag = effect_flag,strategy = strategy,strategy_up_or_down = strategy_up_or_down)
        else:
            fusion_monster1 = {}
            fusion_monster1["max"] = 0
            fusion_monster1["min"] = 0
            fusion_monster1["monster"] = []
        if fusion2:
            fusion_monster2 = self.check_fusion_monster_det(trigger_fusion2,fusion2,instead2,fusion,user,mode = mode,effect_flag = effect_flag,strategy = strategy,strategy_up_or_down = strategy_up_or_down)
        else:
            fusion_monster2 = {}
            fusion_monster2["max"] = 0
            fusion_monster2["min"] = 0
            fusion_monster2["monster"] = []
        if fusion3:
            fusion_monster3 = self.check_fusion_monster_det(trigger_fusion3,fusion3,instead3,fusion,user,mode = mode,effect_flag = effect_flag,strategy = strategy,strategy_up_or_down = strategy_up_or_down)
        else:
            fusion_monster3 = {}
            fusion_monster3["max"] = 0
            fusion_monster3["min"] = 0
            fusion_monster3["monster"] = []
        ary = [fusion_monster1,fusion_monster2,fusion_monster3]
        if mode == 0:
            if fusion_monster1 is False or fusion_monster2 is False or fusion_monster3 is False:
                return False
            else:
                return True
        return ary

    def get_fusion_monster(
        self, fusion_monster_condition, user, trigger,mode = 0,effect_flag = 0,strategy = ""
        ):
        duel = self.duel
        effect_kind = trigger.trigger_kind
        return_monster = []
        tmp2 = json.loads(fusion_monster_condition)
        fusion_monster_condition = tmp2
        exclude = fusion_monster_condition["exclude"]
        tmp2 = tmp2["monster"]
        monster_effect_det2 = tmp2[0]
        tmp_deck = None
        if effect_flag == 1:
            minus_chain =  -1
        else:
            minus_chain = 0 
        for tmps in tmp2:
            places = tmps["monster"]["place"]
            for place in places:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain + minus_chain )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        deck_name = self.decks[deck_id]["deck_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "grave":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain + minus_chain )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_deck = self.get_grave_with_effect(
                                self.decks[grave_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["commongrave"]
                        deck_name = self.graves[deck_id]["grave_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "hand":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain + minus_chain )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.decks[hand_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["commonhand"]
                        deck_name = self.hands[deck_id]["hand_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "field":
                    field = self.field
                    tmp_deck = False
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    effect_user = chain_user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            fusion_monster = {}
                            if strategy != "": 
                                if strategy in field[x][y]["det"]["variables"]:
                                    tmp_variable = field[x][y]["det"]["variables"][strategy]
                                    if not tmp_variable["value"].isnumeric():
                                         tmp_variable["value"] = 0
                                else:
                                    tmp_variable = {}
                                    tmp_variable["value"] = 0
                                value = self.check_change_val(
                        field[x][y]["det"], user, "field", 0, x, y, strategy, mine_or_other, int(tmp_variable["value"])
                    )
                            else: 
                                value = 0
                            fusion_monster["det"] = field[x][y]["det"]
                            fusion_monster["mine_or_other"] = field[x][y]["mine_or_other"]
                            fusion_monster["user"] = chain_user
                            fusion_monster["place"] = "field"
                            fusion_monster["deck_id"] = 0
                            fusion_monster["x"] = x
                            fusion_monster["y"] = y
                            fusion_monster["strategy_value"] = value
                            fusion_monster["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            exclude = fusion_monster_condition["exclude"]
                            if self.validate_answer(
                                fusion_monster, fusion_monster_condition["monster"], exclude, duel
                                ):
                                fusions = self.check_fusion_monster(fusion_monster,trigger,user,effect_flag = effect_flag)
                                if fusions:
                                    if mode == 1:
                                        return True
                                    for fusion in fusions:
                                        fusion_monster["fusion"] = fusion
                                        return_monster.append(fusion_monster)
                if not tmp_deck:
                    continue
                for tmp_fusion_monster in tmp_deck:
                        if strategy != "": 
                            tmptmpdeck = org_deck[tmp_fjusion_monster]
                            if strategy in tmptmpdeck["variables"]:
                                tmp_variable = tmptmpdeck["variables"][strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                tmptmpdeck, user, place_tmp[0], deck_id, 0, 0, strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        fusion_monster = {}
                        fusion_monster["det"] = org_deck[tmp_fusion_monster]
                        fusion_monster["mine_or_other"] = mine_or_other
                        fusion_monster["user"] = user
                        fusion_monster["place"] = place_tmp[0]
                        fusion_monster["deck_id"] = deck_id
                        fusion_monster["deck_name"] = deck_name
                        fusion_monster["x"] = 0
                        fusion_monster["y"] = 0
                        fusion_monster["place_unique_id"] = org_deck[tmp_fusion_monster][
                            "place_unique_id"
                        ]
                        fusion_monster["strategy_value"] = value
                        exclude = fusion_monster_condition["exclude"]
                        if self.validate_answer(
                            fusion_monster, fusion_monster_condition["monster"][0]["monster"], exclude, duel
                            ):
                           fusions = self.check_fusion_monster(fusion_monster,trigger,user,effect_flag = effect_flag)
                           if fusions:
                                if mode == 1:
                                   return True
                                for fusion in fusions:
                                    fusion_monster["fusion"] = fusion
                                    return_monster.append(fusion_monster)
                                    fusion_monster =copy.deepcopy(fusion_monster)
        if mode == 1:
            return False
        return return_monster
    def validate_place(self,monster_condition,monster,user):
        monster_place = monster["place"]
        tmp2 = monster_condition["monster"]
        flag = True
        for tmps in tmp2:
            current_and_or = "and"
            places = tmps["monster"]["place"]
            if places is None:
                return flag
            for place_tmp in places:
                place = place_tmp["det"]
                and_or = place_tmp["and_or"]
                place_tmp = place.split("_")
                flag2 = False
                flag3 = True
                if place_tmp[0] == monster_place:
                    if monster_place == "field":
                        flag3 = True
                    elif str(monster["deck_id"]).find(place_tmp[1]) == -1:
                        flag3 = False
                else:
                    flag3 = False
                if  (place_tmp[2] == "1" and user == 1 and int(monster["mine_or_other"]) == 1):
                        flag2 = True
                elif (place_tmp[2] == "1"
                    and user == 2 and int(monster["mine_or_other"]) == 2):
                        flag2 = True
                elif  (place_tmp[2] == "2" and user == 1 and int(monster["mine_or_other"]) == 2):
                        flag2 = True
                elif(place_tmp[2] == "2" and user == 2 and int(monster["mine_or_other"]) == 1):
                        flag2 = True
                if monster_place != place_tmp[0]:
                    flag2 = False
                if flag2 is True and flag3 is True:
                   if current_and_or == "or":
                       flag = True
                else:
                   if current_and_or == "and":
                       flag = False
                current_and_or = and_or

            if flag is False:
                return False
        return True
    def check_trigger_monster_det(
        self, trigger_monster_condition, monster, user, trigger,move_from
        ):
        if monster["det"] is None:
            monster = move_from
        monster_place = monster["place"]
        effect_kind = trigger.trigger_kind
        tmp2 = json.loads(trigger_monster_condition)
        tmp2 = tmp2["monster"]
        flag = True
        for tmps in tmp2:
            current_and_or = "and"
            places = tmps["monster"]["place"]
            as_monster =tmps["as_monster_condition"]
            if monster != 0 and not self.check_ignore_monster_place_func(
                monster["det"],
                user,
                effect_kind,
                monster["place"],
                monster["deck_id"],
                monster["x"],
                monster["y"],
                user,
                1,
            ):
                for place_tmp in places:
                    place = place_tmp["det"]
                    and_or = place_tmp["and_or"]
                    place_tmp = place.split("_")
                    flag2 = False
                    flag3 = True
                    if place_tmp[0] == monster_place:
                        if monster_place == "field":
                            flag3 = True
                        if str(monster["deck_id"]).find(place_tmp[1]) == -1:
                            flag3 = False
                    else:
                        flag3 = False
                    if  (place_tmp[2] == "1" and user == 1 and monster["mine_or_other"] == 1):
                            flag2 = True
                    elif (place_tmp[2] == "1"
                        and user == 2 and monster["mine_or_other"] == 2):
                            flag2 = True
                    elif  (place_tmp[2] == "2" and user == 1 and monster["mine_or_other"] == 2):
                            flag2 = True
                    elif(place_tmp[2] == "2" and user == 2 and monster["mine_or_other"] == 1):
                            flag2 = True
                    if monster_place != place_tmp[0]:
                        flag2 = False
                    '''
                    elif (
                            (place_tmp[2] == "2"
                             and user == 1 and monster["mine_or_other"] == 1)
                             or   (place_tmp[2] == "2"
                                 and user == 2 and monster["mine_or_other"] == 2)
                            or (place_tmp[2] == "1"
                                and user == 2 and monster["mine_or_other"] == 1)
                            or (place_tmp[2] == "1"
                                and user == 1 and monster["mine_or_other"] == 2)
                    ):
                            flag2 = True
                    '''
                    if flag2 is True and flag3 is True:
                       if current_and_or == "or":
                           flag = True
                    else:
                       if current_and_or == "and":
                           flag = False
                    current_and_or = and_or

                if flag is False:
                    return False
            if self.check_ignore_monster_place_condition_func(
                monster["det"],
                user,
                effect_kind,
                monster["place"],
                monster["deck_id"],
                monster["x"],
                monster["y"],
                user,
                1,
            ) is False:
                if as_monster != "trigger_from":
                    if self.check_monster_condition_det(
                        tmps,
                        monster["det"],
                        user,
                        "",
                        0,
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        monster["mine_or_other"],
                    ):
                        return True
                    else:
                        return False
                else:
                    if self.check_monster_condition_det(
                        tmps,
                        move_from["det"],
                        user,
                        "",
                        0,
                        move_from["place"],
                        move_from["deck_id"],
                        move_from["x"],
                        move_from["y"],
                        move_from["mine_or_other"],
                    ):
                        return True
                    else:
                        return False
        return flag

    def check_trigger_condition(self, trigger, user, monster=0):
        duel = self.duel
        effect_kind = trigger.trigger_kind
        if trigger.trigger_condition == "":
            return True
        trigger_condition = json.loads(trigger.trigger_condition)
        if "monster" in trigger_condition and monster and monster["det"] is not None:
            if "choose" in trigger_condition:
                choose = trigger_condition["choose"]
                if choose is None:
                    choose = 0
            else:
                choose = 0
            if not self.check_ignore_monster_condition_func(
                monster["det"],
                user,
                effect_kind,
                monster["place"],
                monster["deck_id"],
                monster["x"],
                monster["y"],
                user,
                1,
            ):
                excludes = False
                if "exclude" in trigger_condition:
                    exclude = trigger_condition["exclude"]
                    if exclude:
                        excludes = exclude.split(",")
                if (
                    self.check_monster_condition(
                        trigger_condition["monster"],
                        user,
                        False,
                        monster,
                        excludes,
                        choose,
                        effect_kind,
                    )
                    is False
                ):
                    return False
        if "variable" in trigger_condition:
            if monster and monster["det"] is not None:
                ignore_variable_name = self.check_ignore_monster_variable_func(
                    monster["det"],
                    user,
                    effect_kind,
                    monster["place"],
                    monster["deck_id"],
                    monster["x"],
                    monster["y"],
                    user,
                    1,
                )
            else:
                ignore_variable_name = []
            if (
                self.check_monster_condition(
                    trigger_condition["monster"], user, False, monster
                )
                is False
            ):
                return False
            variable_flag = True
            current_and_or = "and"
            for key in range(len(trigger_condition["variable"])):
                variable_condition = trigger_condition
                variable = trigger_condition["variable"][key]["variable"]
                variable = variable.split("_")
                mine_or_other = int(variable[2])
                variable_name = variable[1]
                variable = json.loads(duel.global_variable)
                virtual_variables = self.virtual_variables
                variable.update(virtual_variables)
                if variable_name == "chain":
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not duel.virtual_chain == self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not duel.virtual_chain <= self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not duel.virtual_chain >= self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not duel.virtual_chain != self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif variable_name == "turncount":
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not duel.turn_count == self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not duel.turn_count <= self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not duel.turn_count >= self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not duel.turn_count != self.calculate_boland(
                                variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif mine_or_other == 0:
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not variable[variable_name][
                                   "value"
                               ] == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not variable[variable_name][
                                   "value"
                               ] <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not variable[variable_name][
                                   "value"
                               ] >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not variable[variable_name][
                                   "value"
                               ] != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif (
                        mine_or_other == 1 and user == 1 or mine_or_other == 2 and user == 2
                ):
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not variable[variable_name][
                                   "1_value"
                               ] == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not variable[variable_name][
                                   "1_value"
                               ] <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not variable[variable_name][
                                   "1_value"
                               ] >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not variable[variable_name][
                                   "1_value"
                               ] != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif (
                        mine_or_other == 2 and user == 1 or mine_or_other == 1 and user == 2
                ):
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not variable[variable_name][
                                   "2_value"
                               ] == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not variable[variable_name][
                                   "2_value"
                               ] <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not variable[variable_name][
                                   "2_value"
                               ] >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                            variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not variable[variable_name][
                                   "2_value"
                               ] != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"],user =user
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                current_and_or = variable_condition["variable"][key]["and_or"]
        if variable_flag is False:
            return False
        return True

    # effect_flagはコスト中に実行されていた場合
    def end_cost(self, user,org_chain,trigger,effect_flag=False,copy=0):
        self.end_cost_clear_relation(user)
        self.end_cost_copy(user)
        self.end_cost_remove(user)
        self.end_cost_under(user)
        self.end_cost_add(user)
        self.end_cost_variable(user)
        self.end_cost_flag(user)
        self.end_cost_global_variable(user)
        self.end_cost_clear(user)
        self.end_cost_shuffle(user)
        self.duel.in_cost_force = False
        self.cost_result = {}
        if effect_flag is False:
            self.duel.in_pac_cost = "[]"
            self.duel.in_cost = False
            self.duel.in_copying = False
            self.duel.in_cost_cancel = True
            if self.duel.mute == 0:
                self.duel.log_turn += self.duel.cost_log
            self.duel.log += self.duel.cost_log
            self.current_log += self.duel.cost_log
            self.duel.cost_log = ""
            # コストを支払い終わったらチェーン処理
            if user == 1:
                self.duel.appoint = 2
            elif user == 2:
                self.duel.appoint = 1
            self.duel.log += self.duel.trigger_log
            self.duel.log_turn += self.duel.trigger_log
            self.current_log += self.duel.trigger_log
            trigger_waiting = json.loads(self.duel.trigger_waiting)
            chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
            chain_det_trigger_json[str(org_chain)] = trigger.id
            self.duel.chain_det_trigger = json.dumps(chain_det_trigger_json)
            if copy == 0:
                self.duel.canbechained = trigger.canbechained
            else:
                self.duel.canbechained = False

    def change_appoint(self,appoint):
        duel = self.duel
        if duel.in_cost is True:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        elif duel.chain == 0:
            user = self.user
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        if(appoint== "user_turn"):
            self.duel.appoint = self.duel.user_turn
        elif(appoint== "chain"):
            self.duel.appoint = self.duel.user
        elif(appoint== "not chain"):
            if user == 1:
                self.duel.appoint = 2
            elif user == 2:
                self.duel.appoint = 1
        elif(appoint== "change"):
            if self.duel.appoint == 2:
                self.duel.appoint = 2
            elif self.duel.appoint == 1:
                self.duel.appoint = 1

    def end_cost_copy(self, user):
        field = self.field
        if self.cost_result == "":
            return
        cost = self.cost_result
        if "copy" in cost:
            if "field" in cost["copy"]:
                for tmp2 in cost["copy"]["field"]:
                    field[tmp2["x"]][tmp2["y"]]["det"] = self.copy_monster_det(
                        field[tmp2["x"]][tmp2["y"]]["det"],
                        tmp2["copy_monster"],
                        tmp2["cost_det"],
                        tmp2["effect_kind"],
                    )
                self.field = field
            if "deck" in cost["copy"]:
                for tmp2 in cost["copy"]["deck"]:
                    deck_id = tmp2["deck_id"]
                    user = tmp2["mine_or_other"]
                    place_unique_id = tmp2["place_unique_id"]
                    if user == 1 and self.user == 1 or user == 2 and self.user == 2:
                        user_decks = self.decks[deck_id]["mydeck"]
                    elif user == 2 and self.user == 1 or user == 1 and self.user == 2:
                        user_decks = self.decks[deck_id]["otherdeck"]
                    elif user == 3:
                        user_decks = self.decks[deck_id]["commondeck"]
                    index = 0
                    for user_deck in user_decks:
                        if place_unique_id == user_deck["place_unique_id"]:
                            user_decks[index] = self.copy_monster_det(
                                user_deck,
                                tmp2["copy_monster"],
                                tmp2["cost_det"],
                                tmp2["effect_kind"],
                            )
                        index += 1
                    if user == 1 and self.user == 1 or user == 2 and self.user == 2:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif user == 2 and self.user == 1 or user == 1 and self.user == 2:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif user == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
                    if "deck" in cost["copy"]:
                        for tmp2 in cost["copy"]["deck"]:
                            deck_id = tmp2["deck_id"]
                            user = tmp2["mine_or_other"]
                            place_unique_id = tmp2["place_unique_id"]
                            if (
                                user == 1
                                and self.user == 1
                                or user == 2
                                and self.user == 2
                            ):
                                user_decks = self.decks[deck_id]["mydeck"]
                            elif (
                                user == 2
                                and self.user == 1
                                or user == 1
                                and self.user == 2
                            ):
                                user_decks = self.decks[deck_id]["otherdeck"]
                            elif user == 3:
                                user_decks = self.decks[deck_id]["commondeck"]
                            index = 0
                            for user_deck in user_decks:
                                if place_unique_id == user_deck["place_unique_id"]:
                                    user_decks[index] = self.copy_monster_det(
                                        user_deck,
                                        tmp2["copy_monster"],
                                        tmp2["cost_det"],
                                        tmp2["effect_kind"],
                                    )
                                    index += 1
                            if (
                                user == 1
                                and self.user == 1
                                or user == 2
                                and self.user == 2
                            ):
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif (
                                user == 2
                                and self.user == 1
                                or user == 1
                                and self.user == 2
                            ):
                                self.decks[deck_id]["otherdeck"] = user_decks
                            elif user == 3:
                                self.decks[deck_id]["commondeck"] = user_decks
            if "grave" in cost["copy"]:
                for tmp2 in cost["copy"]["grave"]:
                    deck_id = tmp2["deck_id"]
                    user = tmp2["mine_or_other"]
                    place_unique_id = tmp2["place_unique_id"]
                    if user == 1 and self.user == 1 or user == 2 and self.user == 2:
                        user_graves = self.graves[deck_id]["mygrave"]
                    elif user == 2 and self.user == 1 or user == 1 and self.user == 2:
                        user_graves = self.graves[deck_id]["othergrave"]
                    elif user == 3:
                        user_graves = self.graves[deck_id]["commongrave"]
                    index = 0
                    for user_grave in user_graves:
                        if place_unique_id == user_grave["place_unique_id"]:
                            user_graves[index] = self.copy_monster_det(
                                user_grave,
                                tmp2["copy_monster"],
                                tmp2["cost_det"],
                                tmp2["effect_kind"],
                            )
                            index += 1
                    if user == 1 and self.user == 1 or user == 2 and self.user == 2:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif user == 2 and self.user == 1 or user == 1 and self.user == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif user == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
            if "hand" in cost["copy"]:
                for tmp2 in cost["copy"]["hand"]:
                    deck_id = tmp2["deck_id"]
                    user = tmp2["mine_or_other"]
                    place_unique_id = tmp2["place_unique_id"]
                    if user == 1 and self.user == 1 or user == 2 and self.user == 2:
                        user_hands = self.hands[deck_id]["myhand"]
                    elif user == 2 and self.user == 1 or user == 1 and self.user == 2:
                        user_hands = self.hands[deck_id]["otherhand"]
                    elif user == 3:
                        user_hands = self.hands[deck_id]["commonhand"]
                    index = 0
                    for user_hand in user_hands:
                        if place_unique_id == user_hand["place_unique_id"]:
                            user_hands[index] = self.copy_monster_det(
                                user_hand,
                                tmp2["copy_monster"],
                                tmp2["cost_det"],
                                tmp2["effect_kind"],
                            )
                            index += 1
                    if user == 1 and self.user == 1 or user == 2 and self.user == 2:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif user == 2 and self.user == 1 or user == 1 and self.user == 2:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif user == 3:
                        self.hands[deck_id]["commonhand"] = user_hands

    def end_cost_global_variable(self, user):
        if self.cost_result == "":
            return
        cost = self.cost_result
        variable = json.loads(self.duel.global_variable)
        if "global_change_val" in cost:
            for tmp in cost["global_change_val"]:
                mine_or_other = tmp["mine_or_other"]
                variable_id = tmp["variable_id"]
                change_val = tmp["change_val"]
                change_how = tmp["change_how"]
                if mine_or_other == 0:
                    if change_how == 0:
                        variable[str(variable_id)]["value"] += change_val
                    elif change_how == 1:
                        variable[str(variable_id)]["value"] -= change_val
                    elif change_how == 2:
                        variable[str(variable_id)]["value"] = change_val
                elif (mine_or_other == 1 and user == 1) or (
                    mine_or_other == 2 and user == 2
                ):
                    if change_how == 0:
                        variable[str(variable_id)]["1_value"] += change_val
                    elif change_how == 1:
                        variable[str(variable_id)]["1_value"] -= change_val
                    elif change_how == 2:
                        variable[str(variable_id)]["1_value"] = change_val
                elif (mine_or_other == 2 and user == 1) or (
                    mine_or_other == 1 and user == 2
                ):
                    if change_how == 0:
                        variable[str(variable_id)]["2_value"] += change_val
                    elif change_how == 1:
                        variable[str(variable_id)]["2_value"] -= change_val
                    elif change_how == 2:
                        variable[str(variable_id)]["2_value"] = change_val

        self.duel.global_variable = json.dumps(variable)

    def end_cost_under(self, cost_user):
        if self.cost_result == "":
            return
        cost = self.cost_result
        field = self.field
        if "under" in cost:
            if "field" in cost["under"]:
                for tmp in cost["under"]["field"]:
                    x = tmp["x"]
                    y = tmp["y"]
                    move_to = json.loads(tmp["det"])
                    if "under" not in field[x][y]["det"]:
                        field[x][y]["det"]["under"] = []
                    field[x][y]["det"] = self.copy_monster_to_under(
                        move_to,
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                        None,
                        field[x][y]["det"],
                    )
                self.field = field

    def end_cost_add(self, cost_user):
        if self.cost_result == "":
            return
        cost = self.cost_result
        field = self.field
        if "add" in cost:
            if "field" in cost["add"]:
                for tmp in cost["add"]["field"]:
                    x = tmp["x"]
                    y = tmp["y"]
                    effect_kind = tmp["kind"]
                    move_to = json.loads(tmp["det"])
                    move_to_tmp = copy.deepcopy(move_to)
                    move_to_org = json.loads(tmp["move_from"])
                    org_move_to = json.loads(tmp["org_det"])
                    check_cost = self.cost
                    user = tmp["user"]
                    if (
                        org_move_to["place_unique_id"]
                        == check_cost[str(self.tmp_chain)]["~trigger"][0][
                            "place_unique_id"
                        ]
                    ):
                        check_mess = self.mess
                        tmp2 = {}
                        tmp2["x"] = x
                        tmp2["y"] = y
                        tmp2["det"] = move_to_tmp
                        tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                        tmp2["card_unique_id"] = move_to_tmp["card_unique_id"]
                        tmp2["mine_or_other"] = user
                        tmp2["user"] = user
                        tmp2["place"] = "field"
                        tmp2["deck_id"] = 0
                        check_cost[str(self.tmp_chain)]["~trigger"] = []
                        check_cost[str(self.tmp_chain)]["~trigger"].append(tmp2)
                        check_mess[str(self.tmp_chain)]["trigger"] = []
                        check_mess[str(self.tmp_chain)]["trigger"].append(tmp2)
                        self.cost = check_cost
                        self.mess = check_mess
                    field[x][y]["det"] = move_to
                    self.raise_trigger(
                        move_to,
                        move_to_org,
                        org_move_to,
                        "cost",
                        "field",
                        field[x][y]["mine_or_other"],
                        user,
                        None,
                        effect_kind,
                        x,
                        y,
                    )

                self.field = field
            if "deck" in cost["add"]:
                for tmp in cost["add"]["deck"]:

                    effect_kind = tmp["kind"]
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    user_det = tmp["user_det"]
                    how = int(tmp["how"])
                    move_to = json.loads(tmp["det"])
                    move_to_tmp = move_to.copy()
                    move_to_org = json.loads(tmp["move_from"])
                    org_move_to = json.loads(tmp["org_det"])
                    check_cost = self.cost
                    if (
                        org_move_to["place_unique_id"]
                        == check_cost[str(self.tmp_chain)]["~trigger"][0][
                            "place_unique_id"
                        ]
                    ):
                        check_mess = self.mess
                        tmp2 = {}
                        tmp2["x"] = 0
                        tmp2["y"] = 0
                        tmp2["det"] = move_to_tmp
                        tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                        tmp2["card_unique_id"] = move_to_tmp["card_unique_id"]
                        tmp2["mine_or_other"] = user
                        tmp2["user"] = user
                        tmp2["place"] = "deck"
                        tmp2["deck_id"] = deck_id
                        check_cost[str(self.tmp_chain)]["~trigger"] = []
                        check_cost[str(self.tmp_chain)]["~trigger"].append(tmp2)
                        check_mess[str(self.tmp_chain)]["trigger"] = []
                        check_mess[str(self.tmp_chain)]["trigger"].append(tmp2)
                        self.cost = check_cost
                        self.mess = check_mess
                    self.raise_trigger(
                        move_to,
                        move_to_org,
                        org_move_to,
                        "cost",
                        "deck",
                        user,
                        user_det,
                        deck_id,
                        effect_kind,
                        None,
                        None,
                    )
                    if user == 1 and 1 == self.user or user == 2 and 1 != self.user:
                        user_decks = self.decks[deck_id]["mydeck"]
                    elif user == 2 and 1 == self.user or user == 1 and 1 != self.user:
                        user_decks = self.decks[deck_id]["otherdeck"]
                    elif user == 3:
                        user_decks = self.decks[deck_id]["commondeck"]
                    if how == 0:
                        user_decks.insert(0, move_to)
                    elif how == 1:
                        user_decks.append(move_to)
                    else:
                        range_i = random.randrange(len(user_decks))
                        user_decks.insert(range_i, move_to)
                    if user == 1 and 1 == self.user or user == 2 and 1 != self.user:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif user == 2 and 1 == self.user or user == 1 and 1 != self.user:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif user == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
            if "grave" in cost["add"]:
                for tmp in cost["add"]["grave"]:

                    effect_kind = tmp["kind"]
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    user_det = tmp["user_det"]
                    how = int(tmp["how"])
                    move_to = json.loads(tmp["det"])
                    move_to_org = json.loads(tmp["move_from"])
                    move_to_tmp = move_to.copy()
                    org_move_to = json.loads(tmp["org_det"])
                    check_cost = self.cost
                    if (
                        "~trigger" in check_cost[str(self.tmp_chain)] and
                        org_move_to["place_unique_id"]
                        == check_cost[str(self.tmp_chain)]["~trigger"][0][
                            "place_unique_id"
                        ]
                    ):
                        check_mess = self.mess
                        tmp2 = {}
                        tmp2["x"] = 0
                        tmp2["y"] = 0
                        tmp2["det"] = move_to_tmp
                        tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                        tmp2["card_unique_id"] = move_to_tmp["card_unique_id"]
                        tmp2["mine_or_other"] = user
                        tmp2["user"] = user
                        tmp2["place"] = "grave"
                        tmp2["deck_id"] = deck_id
                        check_cost[str(self.tmp_chain)]["~trigger"] = []
                        check_cost[str(self.tmp_chain)]["~trigger"].append(tmp2)
                        check_mess[str(self.tmp_chain)]["trigger"] = []
                        check_mess[str(self.tmp_chain)]["trigger"].append(tmp2)
                        self.cost = check_cost
                        self.mess = check_mess
                    self.raise_trigger(
                        move_to,
                        move_to_org,
                        org_move_to,
                        "cost",
                        "grave",
                        user,
                        user_det,
                        deck_id,
                        effect_kind,
                        None,
                        None,
                    )
                    if user == 1 and 1 == self.user or user == 2 and 1 != self.user:
                        user_graves = self.graves[deck_id]["mygrave"]
                    elif user == 2 and 1 == self.user or user == 1 and 1 != self.user:
                        user_graves = self.graves[deck_id]["othergrave"]
                    elif user == 3:
                        user_graves = self.graves[deck_id]["commongrave"]
                    if how == 0:
                        user_graves.insert(0, move_to)
                    elif how == 1:
                        user_graves.append(move_to)
                    else:
                        range_i = random.randrange(len(user_graves))
                        user_graves.insert(range_i, move_to)
                    if user == 1 and 1 == self.user or user == 2 and 1 != self.user:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif user == 2 and 1 == self.user or user == 1 and 1 != self.user:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif user == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
            if "hand" in cost["add"]:
                for tmp in cost["add"]["hand"]:

                    effect_kind = tmp["kind"]
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    user_det = tmp["user_det"]
                    move_to = json.loads(tmp["det"])
                    move_to_org = json.loads(tmp["move_from"])
                    org_move_to = json.loads(tmp["org_det"])
                    how = int(tmp["how"])
                    move_to = json.loads(tmp["det"])
                    move_to_tmp = move_to.copy()
                    check_cost = self.cost
                    if (
                        org_move_to["place_unique_id"]
                        == check_cost[str(self.tmp_chain)]["~trigger"][0][
                            "place_unique_id"
                        ]
                    ):
                        check_mess = self.mess
                        tmp2 = {}
                        tmp2["x"] = 0
                        tmp2["y"] = 0
                        tmp2["det"] = move_to_tmp
                        tmp2["det"]["place_unique_id"] = move_to_tmp["place_unique_id"]
                        tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                        tmp2["card_unique_id"] = move_to_tmp["card_unique_id"]
                        tmp2["mine_or_other"] = user
                        tmp2["user"] = user
                        tmp2["place"] = "hand"
                        tmp2["deck_id"] = deck_id
                        check_cost[str(self.tmp_chain)]["~trigger"] = []
                        check_cost[str(self.tmp_chain)]["~trigger"].append(tmp2)
                        check_mess[str(self.tmp_chain)]["trigger"] = []
                        check_mess[str(self.tmp_chain)]["trigger"].append(tmp2)
                        self.cost = check_cost
                    self.raise_trigger(
                        move_to,
                        move_to_org,
                        org_move_to,
                        "cost",
                        "hand",
                        user,
                        user_det,
                        deck_id,
                        effect_kind,
                        None,
                        None,
                    )
                    if user == 1 and 1 == self.user or user == 2 and 1 != self.user:
                        user_hands = self.hands[deck_id]["myhand"]
                    elif user == 2 and 1 == self.user or user == 1 and 1 != self.user:
                        user_hands = self.hands[deck_id]["otherhand"]
                    elif user == 3:
                        user_hands = self.hands[deck_id]["commonhand"]
                    if how == 0:
                        user_hands.insert(0, move_to)
                    elif how == 1:
                        user_hands.append(move_to)
                    else:
                        range_i = random.randrange(len(user_hands))
                        user_hands.insert(range_i, move_to)
                    if user == 1 and 1 == self.user or user == 2 and 1 != self.user:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif user == 2 and 1 == self.user or user == 1 and 1 != self.user:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif user == 3:
                        self.hands[deck_id]["commonhand"] = user_hands

    def get_val_designated(
        self,
        val,
        other_user_flag=False,
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
    ):
        duel = self.duel
        val = val[1:-1]
        val = val.split(":")
        x = int(val[0])
        y = int(val[1])
        val_name = val[2]
        field = self.field
        user = field[x][y]["user"]
        field = field[x][y]["det"]
        tmp4raise = {}
        tmp4raise["det"] = field[x][y]["det"]
        tmp4raise["mine_or_other"] = field[x][y]["mine_or_other"]
        tmp4raise["user"] = user
        tmp4raise["place"] = "field"
        tmp4raise["deck_id"] = 0
        tmp4raise["x"] = x
        tmp4raise["y"] = y
        tmp4raise["place_unique_id"] = field[x][y]["det"]["place_unique_id"]
        return_value = 0
        if len(val) > 3:
            eternal_kind = val[3]
            if eternal_kind != "":
                if self.check_eternal_invalid(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    eternal_kind,
                    "field",
                    0,
                    x,
                    y,
                    field[x][y]["mine_or_other"],
                ):
                    return 0
        val_name = self.check_swap_val(
            field["det"], user, "field", 0, x, y, val_name, 1
        )
        val_name2 = self.check_swap_init_val(
            field["det"], user, "field", 0, x, y, val_name, 1
        )
        if val_name == "name":
            return field["det"]["monster_name"]
        else:
            if val_name2 in field["det"]["variables"]:
                return_value = int(field["det"]["variables"][val_name2]["value"])
        return_value = self.check_change_val(
            field["det"], field["mine_or_other"], "field", 0, x, y, val_name, 1,return_value
        )
        if isinstance(return_value, str):
            return return_value
        if return_value < 0 and (
            val_name not in field[x][y]["det"]["variables"]
            or field["det"]["variabels"][val_name]["minus"] is False
        ):
            return_value = 0
        if change_val_flag and accumulate_flag is False:
            self.raise_trigger_change_val(
                tmp4raise, return_value, 0, effect_kind, user, 1
            )
        if accumulate_flag is True:
            self.accumulate_global(
                tmp4raise, return_value, 0, effect_kind, user, global_name
            )
            return_value = 0
        if duel.alt_global != "" and global_name is not None:
            alt_val = self.change_alt_global2(
                global_name["variable_id"],
                field[x][y]["mine_or_other"],
                global_name["variable_how"],
                effect_kind,
                return_value,
            )
            return_value -= alt_val
            instead_val = self.check_variable_instead(
                global_name["variable_id"],
                global_name["mine_or_other"],
                return_value,
                1,
                user,
                effect_kind,
            )
            return_value -= instead_val
            self.raise_trigger_change_val(
                tmp4raise, return_value, 0, effect_kind, user, 0
            )
        return return_value

    def floor(self, src, num):
        range = pow(10, num)
        return (int)(src / range) * range

    def get_val_floor(self, val, pre, other_user_flag=False, effect_kind=""):
        val = val[1:-1]
        val = self.floor(pre, int(val))
        return val

    def get_val_sum(
        self,
        val,
        other_user_flag=False,
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
        eternal = False,
        user = None
    ):
        duel = self.duel
        val = val[1:-1]
        val = val.split(":")
        place = val[0]
        deck_id = int(val[1])
        mine_or_other = int(val[2])
        if len(val) > 3:
            val_name = val[3]
        else:
            val_name = ""
        if len(val) > 4 and val[4] != "":
            cond = val[4]
            cond = cond.split("^")
        else:
            cond = []
        if len(val) > 5:
            method = val[5]
        else:
            method = "SUM"
        if len(val) > 6 and val[6] != "":
            flag = val[6]
        else:
            flag = False
        if len(val) > 7:
            eternal_kind = val[7]
        else:
            eternal_kind = ""
        if len(val) > 8 and val[8] != "":
            monster_id = int(val[8])
        else:
            monster_id = -1
        if len(val) > 9 and val[9] != "":
            init = int(val[9])
        else:
            init = 0
        if user is not None:
            pass
        elif duel.in_cost is True :
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        elif duel.chain == 0:
            user = self.duel.appoint
        elif duel.ask == 1:
            user = self.user
        elif duel.ask == 2:
            user = self.user
        elif duel.ask == 3:
            user = self.user
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        if other_user_flag is True :
            if mine_or_other == 1:
                mine_or_other = 2
            elif mine_or_other == 2:
                mine_or_other = 1
        return_value = 0
        if (mine_or_other == 1 and user == 1) or (mine_or_other == 2 and user != 1):
            mine_or_other_absolute = 1
        elif (mine_or_other == 2 and user == 1) or (mine_or_other == 1 and user != 1):
            mine_or_other_absolute = 2
        else:
            mine_or_other_absolute = 3
        if place == "deck":
            if (
                (mine_or_other_absolute == 1
                and 1 == self.user)
                or
                (mine_or_other_absolute == 2
                and 1 != self.user)
            ):
                cards = self.decks[deck_id]["mydeck"]
            elif (
                (mine_or_other_absolute == 2
                and 1 == self.user)
                or
                (mine_or_other_absolute == 1
                and 1 != self.user)
            ):
                cards = self.decks[deck_id]["otherdeck"]
            elif mine_or_other == 3:
                cards = self.decks[deck_id]["commondeck"]
        if place == "grave":
            if (
               (mine_or_other_absolute == 1
                 and 1 == self.user)
               or
               (mine_or_other_absolute == 2
                 and 1 != self.user)
            ):
                cards = self.graves[deck_id]["mygrave"]
            elif (
                 (mine_or_other_absolute == 2
                  and 1 == self.user)
                 or
                 (mine_or_other_absolute == 1
                  and 1 != self.user)
            ):
                cards = self.graves[deck_id]["othergrave"]
            elif mine_or_other == 3:
                cards = self.graves[deck_id]["commongrave"]
        if place == "hand":
            if (
               (mine_or_other_absolute == 1
               and 1 == self.user)
               or
               (mine_or_other_absolute == 2
               and 1 != self.user)
            ):
                cards = self.hands[deck_id]["myhand"]
            elif (
               (mine_or_other_absolute == 2
                and 1 == self.user)
               or
               (mine_or_other_absolute == 1
                and 1 != self.user)
            ):
                cards = self.hands[deck_id]["otherhand"]
            elif mine_or_other == 3:
                cards = self.hands[deck_id]["commonhand"]
        for card in cards:
            if monster_id != -1:
                if monster_id != int(self.get_monster_id_easy(card)):
                    continue
            if eternal_kind != "":
                if self.check_eternal_invalid(
                    card,
                    mine_or_other,
                    eternal_kind,
                    place,
                    deck_id,
                    0,
                    0,
                    mine_or_other,
                ):
                    continue
            if val_name == "name":
                return card["monster_name"]
            if flag:
                if flag[0] == "^":
                    if int(flag[1:]) & int(card["flag"]):
                        continue
                else:
                    if not (int(flag) & int(card["flag"])):
                        continue
            tmp2 = card["variables"]
            tmp4raise = {}
            tmp4raise["det"] = card
            tmp4raise["mine_or_other"] = mine_or_other_absolute
            tmp4raise["user"] = user
            tmp4raise["place"] = place
            tmp4raise["deck_id"] = deck_id
            tmp4raise["x"] = 0
            tmp4raise["y"] = 0
            tmp4raise["place_unique_id"] = card["place_unique_id"]
            cond_flag = True
            next_and_or = "and"

            for cond_det in cond:
                cond_det = cond_det.split("@")
                current_and_or = next_and_or
                if len(cond_det) > 3:
                    next_and_or = cond_det[3]
                else:
                    next_and_or = "and"
                tmp3 = int(tmp2[cond_det[0]]["value"])

                tmp3 = self.check_change_val(
                    card,
                    mine_or_other_absolute,
                    place,
                    deck_id,
                    0,
                    0,
                    cond_det[0],
                    mine_or_other_absolute,
                    tmp3
                )
                tmp3 = int(tmp3)
                if cond_det[2] == "=":
                    if int(cond_det[1]) == tmp3:
                        if current_and_or == "or":
                            cond_flag = True
                    else:
                        if current_and_or == "and":
                            cond_flag = False
                elif cond_det[2] == ">=":
                    if tmp3 >= int(cond_det[1]):
                        if current_and_or == "or":
                            cond_flag = True
                    else:
                        if current_and_or == "and":
                            cond_flag = False
                elif cond_det[2] == "<=":
                    if tmp3 <= int(cond_det[1]):
                        if current_and_or == "or":
                            cond_flag = True
                    else:
                        if current_and_or == "and":
                            cond_flag = False
                elif cond_det[2] == "!=":
                    if tmp3 != int(cond_det[1]):
                        if current_and_or == "or":
                            cond_flag = True
                    else:
                        if current_and_or == "and":
                            cond_flag = False
            if cond_flag is False:
                continue

            if val_name == "" or val_name == "0":
                return_value += 1
            else:
                val_name = self.check_swap_val(
                    card, user, place, deck_id, 0, 0, val_name, 1
                )
                val_name2 = self.check_swap_init_val(
                    card, user, place, deck_id, 0, 0, val_name, 1
                )
                if init == 1:
                    return_tmp = int(tmp2[val_name2]["i_val"])
                else:
                    if val_name in tmp2:
                        return_tmp = int(tmp2[val_name2]["val"])
                    return_tmp = self.check_change_val(
                        card, user, place, deck_id, 0, 0, val_name, 1,return_tmp
                    )
                if isinstance(return_tmp, str):
                    return return_tmp
                if return_tmp < 0 and (
                    val_name not in tmp2 or tmp2[val_name]["minus"] is False
                ):
                    return_tmp = 0
                if method == "SUM":
                    if change_val_flag and accumulate_flag is False:
                        self.raise_trigger_change_val(
                            tmp4raise, return_tmp, 0, "", user, 1
                        )
                    if accumulate_flag is True:
                        self.accumulate_global(
                            tmp4raise, return_tmp, 0, "", user, global_name
                        )
                        return_tmp = 0
                    elif duel.alt_global != "" and global_name is not None:
                        alt_val = self.change_alt_global2(
                            global_name["variable_id"],
                            mine_or_other,
                            global_name["variable_how"],
                            effect_kind,
                            return_tmp,
                        )
                        return_tmp -= alt_val
                        instead_val = self.check_variable_instead(
                            global_name["variable_id"],
                            global_name["mine_or_other"],
                            return_tmp,
                            1,
                            user,
                            effect_kind,
                        )
                        return_tmp -= instead_val
                        self.raise_trigger_change_val(
                            tmp4raise, return_tmp, 0, effect_kind, user, 0
                        )
                    return_value += return_tmp
                elif method == "MAX":
                    return_value = max(int(return_tmp), return_value)
                elif method == "MIN":
                    return_value = min(int(return_tmp), return_value)

        return return_value

    def get_val_sum_field(
        self,
        val,
        other_user_flag=False,
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
        eternal = False
    ):
        duel = self.duel
        val = val[1:-1]
        val = val.split(":")
        place = int(val[0])
        mine_or_other = int(val[1])
        if duel.in_cost is True:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        elif duel.chain == 0:
            user = duel.appoint
        elif duel.ask == 1:
            user = self.user
        elif duel.ask == 2:
            user = self.user
        elif duel.ask == 3:
            user = self.user
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        if other_user_flag is True and eternal is True:
            if mine_or_other == 1:
                mine_or_other = 2
            elif mine_or_other == 2:
                mine_or_other = 1
        if mine_or_other != 3:
            if (user == 1 and mine_or_other == 1) or (user == 2 and mine_or_other == 2):
                mine_or_other = 1
            else:
                mine_or_other = 2
        val_name = val[2]
        val_name_array = val_name.split("#")
        if len(val) >14:
            init = int(val[14])
        else:
            init = 0
        if len(val) > 3 and val[3] != "":
            flag = int(val[3])
            if flag == 0:
                flag = False
        else:
            flag = False
        if len(val) > 4:
            eternal_flag = val[4]
        else:
            eternal_flag = False
        if len(val) > 5:
            method = val[5]
        else:
            method = "SUM"
        if len(val) > 6:
            cond = val[6]
            if cond != "":
                cond = cond.split("^")
            else:
                cond = []
        else:
            cond = []
        field = self.field
        if len(val) > 7 and val[7] != "":
            x = int(val[7])
            y = int(val[8])
            if len(val_name_array) == 1:
                if init == 1:
                    return field[x][y]["det"]["variables"][val_name]["i_val"]
                val_name2 = self.check_swap_val(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    "field",
                    0,
                    x,
                    y,
                    val_name,
                    1,
                )
                val_name3 = self.check_swap_init_val(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    "field",
                    0,
                    x,
                    y,
                    val_name2,
                    1,
                )
                tmp2 = field[x][y]["det"]["variables"][val_name3]["value"]
                if isinstance(tmp2, str) and self.is_float(tmp2) is False:
                    return tmp2
                else:
                    tmp2 = int(tmp2)
                tmp2 = self.check_change_val(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    "field",
                    0,
                    x,
                    y,
                    val_name2,
                    field[x][y]["mine_or_other"],
                    tmp2,
                )
                if isinstance(tmp2, str):
                    return tmp2
                if tmp2 < 0 and field[x][y]["det"]["variables"][val_name2]["minus"] is False:
                    tmp2 = 0
                return int(tmp2)
            else:
                val_name2 = self.check_swap_val(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    "field",
                    0,
                    x,
                    y,
                    val_name_array[0],
                    1,
                )
                val_name3 = self.check_swap_init_val(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    "field",
                    0,
                    x,
                    y,
                    val_name_array[0],
                    1,
                )
                if init == 1:
                    tmp2 = field[x][y]["det"]["variables"][val_name3]["i_val"]
                else:
                    tmp2 = field[x][y]["det"]["variables"][val_name3]["value"]
                    if isinstance(tmp2, str) and self.is_float(tmp2) is False:
                        return tmp2
                    else:
                        tmp2 = int(tmp2)
                    tmp2 = self.check_change_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        val_name_array[0],
                        field[x][y]["mine_or_other"],
                        tmp2,
                    )
                if init == 1:
                    val_name4 = self.check_swap_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        val_name_array[2],
                        1,
                    )
                    val_name5 = self.check_swap_init_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        val_name_array[2],
                        1,
                    )
                    tmp3 = field[x][y]["det"]["variables"][val_name5]["i_val"]
                else:
                    val_name4 = self.check_swap_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        val_name_array[2],
                        1,
                    )
                    val_name5 = self.check_swap_init_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        val_name_array[2],
                        1,
                    )
                    tmp3 = field[x][y]["det"]["variables"][val_name5]["value"]
                    if isinstance(tmp3, str) and self.is_float(tmp3) is False:
                        return tmp3
                    else:
                        tmp3 = int(tmp3)
                    tmp3 = self.check_change_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        val_name4,
                        field[x][y]["mine_or_other"],
                        tmp3,
                    )
                if val_name_array[1] == "+":
                    return tmp2+tmp3
                else:
                    return tmp2-tmp3
                    
        field_size = FieldSize.objects.get(id=1)
        rel_name = None
        if len(val) > 9:
            rel_name = val[9]
            rel_kind = val[10]
            if val[11] != "":
                rel_to = int(val[11])
            else:
                rel_to = 0
            if val[12] != "":
                rel_id = int(val[12])
            else:
                rel_id = 0
        if len(val) > 13 and val[13] != "":
            monster_id = int(val[13])
        else:
            monster_id = -1
        tmp3 = 0
        if self.field_free is True:
            field_x = 20
        else:
            field_x = field_size.field_x
        for x in range(field_x):
            for y in range(field_size.field_y):
                if self.field_free is False:
                    kind = field[x][y]["kind"]
                else:
                    kind = field[0][y]["kind"]
                kind = kind.split("_")
                if field[x][y]["mine_or_other"] == mine_or_other and str(place) in kind:
                    if field[x][y]["det"] is not None:
                        if monster_id != -1:
                            if monster_id != int(
                                self.get_monster_id_easy(field[x][y]["det"])
                            ):
                                continue
                        if flag:
                            if field[x][y]["det"]["flag"] & flag == 0:
                                continue
                        if eternal_flag is True:
                            if self.check_eternal_invalid(
                                field[x][y]["det"],
                                field[x][y]["det"]["mine_or_other"],
                                eternal_flag,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                            ):
                                continue
                        cond_flag = True
                        next_and_or = "and"
                        for cond_det in cond:
                            cond_det = cond_det.split("@")
                            current_and_or = next_and_or
                            if len(cond_det) > 3:
                                next_and_or = cond_det[3]
                            else:
                                next_and_or = "and"

                            val_name4 = self.check_swap_val(
                                field[x][y]["det"],
                                field[x][y]["mine_or_other"],
                                "field",
                                0,
                                x,
                                y,
                                cond_det[0],
                                1,
                            )
                            val_name5 = self.check_swap_init_val(
                                field[x][y]["det"],
                                field[x][y]["mine_or_other"],
                                "field",
                                0,
                                x,
                                y,
                                cond_det[0],
                                1,)
                            
                            if val_name5 in field[x][y]["det"]["variables"]:
                                tmp4 = field[x][y]["det"]["variables"][val_name5]["value"].split("_")
                            else:
                                tmp4 = [0]
                            if len(tmp4) <= 1:
                                tmp4 = int(tmp4[0])
                                tmp4 = self.check_change_val(
                                field[x][y]["det"],
                                field[x][y]["mine_or_other"],
                                "field",
                                0,
                                x,
                                y,
                                val_name4,
                                field[x][y]["mine_or_other"],
                                tmp4
                            )
                            if cond_det[2] == "=":
                                if isinstance(tmp4,list):
                                    if cond_det[1] in tmp4:
                                        if current_and_or == "or":
                                            cond_flag = True
                                    else:
                                        if current_and_or == "and":
                                            cond_flag = False
                                else:
                                    if int(cond_det[1]) == int(tmp4):
                                        if current_and_or == "or":
                                            cond_flag = True
                                    else:
                                        if current_and_or == "and":
                                            cond_flag = False
                            elif cond_det[2] == ">=":
                                if int(tmp4) >= int(cond_det[1]):
                                    if current_and_or == "or":
                                        cond_flag = True
                                else:
                                    if current_and_or == "and":
                                        cond_flag = False
                            elif cond_det[2] == "<=":
                                if int(tmp4) <= int(cond_det[1]):
                                    if current_and_or == "or":
                                        cond_flag = True
                                else:
                                    if current_and_or == "and":
                                        cond_flag = False
                            elif cond_det[2] == "!=":
                                if int(tmp4) != int(cond_det[1]):
                                    if current_and_or == "or":
                                        cond_flag = True
                                else:
                                    if current_and_or == "and":
                                        cond_flag = False
                        if cond_flag is False:
                            continue
                        if rel_name is not None and rel_name != "":
                            rel_flag = False
                            if (
                                "rel" in field[x][y]["det"]
                                and rel_kind in field[x][y]["det"]["rel"]
                            ):
                                for rel_monster in field[x][y]["det"]["rel"][rel_kind]:
                                    if (
                                        rel_monster["name"] != rel_name
                                        or rel_monster["to"] != rel_to
                                    ):
                                        continue
                                    rel_monster_det = rel_monster["monster"]
                                    monster = self.get_monster(
                                        rel_monster_det["place"],
                                        rel_monster_det["place_unique_id"],
                                        rel_monster_det["mine_or_other"],
                                        rel_monster_det["user"],
                                        rel_monster_det["deck_id"],
                                        rel_monster_det["x"],
                                        rel_monster_det["y"],
                                    )
                                    if rel_id != "":
                                        if (
                                            self.get_monster_id_easy(monster["det"])
                                            != rel_id
                                        ):
                                            continue
                                    rel_flag = True
                                    break
                            if rel_flag is False:
                                continue
                        if val_name == "":
                            tmp3 += 1
                        elif val_name == "name":
                            return field[x][y]["det"]["monster_name"]
                        else:
                            tmp2 = field[x][y]["det"]["variables"]
                            tmp4raise = {}
                            tmp4raise["det"] = field[x][y]["det"]
                            tmp4raise["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp4raise["user"] = user
                            tmp4raise["place"] = "field"
                            tmp4raise["deck_id"] = 0
                            tmp4raise["x"] = x
                            tmp4raise["y"] = y
                            tmp4raise["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            return_tmp = 0
                            return_tmp2 = 0
                            if len(val_name_array) == 1:
                                val_name = self.check_swap_val(
                                    field[x][y]["det"],
                                    field[x][y]["mine_or_other"],
                                    "field",
                                    0,
                                    x,
                                    y,
                                    val_name,
                                    1,
                                )
                                val_name2 = self.check_swap_init_val(
                                    field[x][y]["det"],
                                    field[x][y]["mine_or_other"],
                                    "field",
                                    0,
                                    x,
                                    y,
                                    val_name,
                                    1,
                                )
                                if init == 1:
                                    return_tmp = int(tmp2[val_name2]["i_val"])
                                else:
                                    if val_name in tmp2:
                                        return_tmp = int(tmp2[val_name2]["value"])
                                    return_tmp = self.check_change_val(
                                        field[x][y]["det"],
                                        field[x][y]["mine_or_other"],
                                        "field",
                                        0,
                                        x,
                                        y,
                                        val_name,
                                        field[x][y]["mine_or_other"],
                                        return_tmp
                                    )
                                if isinstance(return_tmp, str):
                                    return return_tmp
                                if return_tmp < 0 and (
                                    val_name not in tmp2 or tmp2[val_name]["minus"] is False
                                ):
                                    return_tmp = 0
                            else:
                                val_name_array[0] = self.check_swap_val(
                                    field[x][y]["det"],
                                    field[x][y]["mine_or_other"],
                                    "field",
                                    0,
                                    x,
                                    y,
                                    val_name_array[0],
                                    1,
                                )
                                val_name_tmp = self.check_swap_init_val(
                                    field[x][y]["det"],
                                    field[x][y]["mine_or_other"],
                                    "field",
                                    0,
                                    x,
                                    y,
                                    val_name_array[0],
                                    1,
                                )
                                if init == 1:
                                    return_tmp = int(tmp2[val_name_tmp]["i_val"])
                                else:
                                    if val_name_array[0] in tmp2:
                                        return_tmp = int(tmp2[val_name_tmp]["value"])
                                    return_tmp = self.check_change_val(
                                        field[x][y]["det"],
                                        field[x][y]["mine_or_other"],
                                        "field",
                                        0,
                                        x,
                                        y,
                                        val_name_array[0],
                                        field[x][y]["mine_or_other"],
                                        return_tmp
                                    )
                                val_name_array[2] = self.check_swap_val(
                                    field[x][y]["det"],
                                    field[x][y]["mine_or_other"],
                                    "field",
                                    0,
                                    x,
                                    y,
                                    val_name_array[2],
                                    1,
                                )
                                val_name_tmp2 = self.check_swap_init_val(
                                    field[x][y]["det"],
                                    field[x][y]["mine_or_other"],
                                    "field",
                                    0,
                                    x,
                                    y,
                                    val_name_array[2],
                                    1,
                                )
                                if init == 1:
                                    return_tmp = int(tmp2[val_name_tmp2]["i_val"])
                                else:
                                    if val_name_array[2] in tmp2:
                                        return_tmp2 = int(tmp2[val_name_tmp2]["value"])
                                    return_tmp2 = self.check_change_val(
                                        field[x][y]["det"],
                                        field[x][y]["mine_or_other"],
                                        "field",
                                        0,
                                        x,
                                        y,
                                        val_name_array[2],
                                        field[x][y]["mine_or_other"],
                                        return_tmp2
                                    )
                                if val_name_array[1] == "+":
                                    return_tmp = return_tmp + return_tmp2
                                else:
                                    return_tmp = return_tmp - return_tmp2
                                if return_tmp < 0 and (
                                        val_name not in tmp2 or tmp2[val_name]["minus"] is False
                                ):
                                    return_tmp = 0
                            if method == "SUM":
                                if change_val_flag and accumulate_flag is False:
                                    self.raise_trigger_change_val(
                                        tmp4raise, return_tmp, 0, effect_kind, user, 1
                                    )
                                if accumulate_flag is True:
                                    self.accumulate_global(
                                        tmp4raise,
                                        return_tmp,
                                        0,
                                        effect_kind,
                                        user,
                                        global_name,
                                    )
                                    return_tmp = 0
                                elif duel.alt_global != "" and global_name is not None:
                                    alt_val = self.change_alt_global2(
                                        global_name["variable_id"],
                                        mine_or_other,
                                        global_name["variable_how"],
                                        effect_kind,
                                        return_tmp,
                                    )
                                    return_tmp -= alt_val
                                    instead_val = self.check_variable_instead(
                                        global_name["variable_id"],
                                        global_name["mine_or_other"],
                                        return_tmp,
                                        1,
                                        user,
                                        effect_kind,
                                    )
                                    return_tmp -= instead_val
                                    self.raise_trigger_change_val(
                                        tmp4raise, return_tmp, 0, effect_kind, user, 0
                                    )
                                tmp3 += return_tmp
                            elif method == "MAX":
                                tmp3 = max(return_tmp, tmp3)
                            elif method == "MIN":
                                tmp3 = min(return_tmp, tmp3)
        return tmp3

    def get_val_variable_mess(self, val, other_user_flag=False, effect_kind=""):
        tmp = self.variable_mess
        change_val = tmp[str(self.duel.chain - 1)]
        return change_val

    def get_val(
        self,
        val,
        other_user_flag=False,
        effect_kind_rel="",
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
        mode=0,
    ):
        val = val[1:-1]
        val = val.split(":")
        name = val[0]
        val_name = val[1]
        if len(val) > 2 and val[2] != "":
            flag = int(val[2])
        else:
            flag = ""
        rel_name = None
        if len(val) > 3:
            rel_name = val[3]
            rel_kind = val[4]
            if val[5] != "":
                rel_to = int(val[5])
            else:
                rel_to = 0
            if val[6] != "":
                rel_id = int(val[6])
            else:
                rel_id = 0
        if len(val) > 7:
            under = int(val[7])
        else:
            under = 0
        if (len(val) > 8) and val[8] != "":
            id = int(val[8])
        else:
            id = -1
        if (len(val) > 9) and val[9] != "":
            monster_effect_kind = val[9]
        else:
            monster_effect_kind = "0"
        if (len(val) > 10) and val[10] == "1":
            init = val[10]
        else:
            init = 0

        return_value = 0
        if mode == 0:
            tmp = self.mess
            if name not in tmp[str(self.duel.chain - 1)]:
                tmp = []
            else:
                tmp = tmp[str(self.duel.chain - 1)][name]
        else:
            if name not in self.timing_mess:
                tmp = []
            else:
                tmp = self.timing_mess[name]
        for monster in tmp:
            if id != -1:
                if int(id) != int(self.get_monster_id_easy(monster["det"])):
                    continue
            if rel_name is not None and rel_name != "":
                if "rel" in monster["det"] and rel_kind in monster["det"]["rel"]:
                    for rel_monster in monster["det"]["rel"][rel_kind]:
                        if (
                            rel_monster["name"] != rel_name
                            or rel_monster["to"] != rel_to
                        ):
                            continue
                        rel_monster_det = rel_monster["monster"]
                        monster2 = self.get_monster(
                            rel_monster_det["place"],
                            rel_monster_det["place_unique_id"],
                            rel_monster_det["mine_or_other"],
                            rel_monster_det["user"],
                            rel_monster_det["deck_id"],
                            rel_monster_det["x"],
                            rel_monster_det["y"],
                        )
                        if rel_id != "" and rel_id != 0:
                            if self.get_monster_id_easy(monster2["det"]) != rel_id:
                                continue
                            if monster_effect_kind != "0":
                                if self.check_eternal_invalid(
                                        monster2["det"],
                                        monster2["user"],
                                        monster_effect_kind,
                                        monster2["place"],
                                        monster2["deck_id"],
                                        monster2["x"],
                                        monster2["y"],
                                        monster2["mine_or_other"],
                                ):
                                    continue
                        if effect_kind_rel != "":
                            if self.check_not_effected(
                                monster2["det"],
                                monster2["user"],
                                effect_kind_rel,
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                monster2["mine_or_other"],
                                0,
                            ):
                                return "NoneEffect"
                        return_tmp = 0
                        if val_name == "place_id":
                            return monster2["place_unique_id"]
                        if val_name == "name":
                            return monster2["det"]["monster_name"]
                        elif val_name == "":
                            return_tmp += 1
                        else:
                            val_name = self.check_swap_val(
                                monster2["det"],
                                monster2["mine_or_other"],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                val_name,
                                1,
                            )
                            val_name2 = self.check_swap_init_val(
                                monster2["det"],
                                monster2["mine_or_other"],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                val_name,
                                1,
                            )
                            if val_name2 in monster2["det"]["variables"]:
                                return_tmp += int(
                                    monster2["det"]["variables"][val_name2]["value"]
                                )
                            if init == 0:
                                return_tmp = self.check_change_val(
                                monster2["det"],
                                monster2["mine_or_other"],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                val_name,
                                1,
                                return_tmp
                            )
                            if isinstance(return_tmp, str):
                                return return_tmp
                            if return_tmp < 0 and (
                                val_name in monster2["det"]["variables"]
                                or monster2["det"]["variables"][val_name]["minus"]
                                is False
                            ):
                                return_tmp = 0
                        if change_val_flag and accumulate_flag is False:
                            self.raise_trigger_change_val(
                                monster2,
                                return_tmp,
                                0,
                                effect_kind,
                                monster2["mine_or_other"],
                                1,
                            )
                        if accumulate_flag is True:
                            self.accumulate_global(
                                monster2,
                                return_tmp,
                                0,
                                effect_kind,
                                monster2["mine_or_other"],
                                global_name,
                            )
                            return_tmp = 0
                        elif self.duel.alt_global != "" and global_name is not None:
                            alt_val = self.change_alt_global2(
                                global_name["variable_id"],
                                monster2["mine_or_other"],
                                global_name["variable_how"],
                                effect_kind,
                                return_tmp,
                            )
                            return_tmp -= alt_val
                            instead_val = self.check_variable_instead(
                                global_name["variable_id"],
                                global_name["mine_or_other"],
                                return_tmp,
                                1,
                                monster2["mine_or_other"],
                                effect_kind,
                            )
                            return_tmp -= instead_val
                            self.raise_trigger_change_val(
                                monster2,
                                return_tmp,
                                0,
                                effect_kind,
                                monster2["mine_or_other"],
                                0,
                            )
                        return_value += return_tmp
            elif under == 1:
                if "under" not in monster["det"]:
                    return 0
                for under_monster in monster["det"]["under"]:
                    if monster_effect_kind != "0":
                        if self.check_eternal_invalid(
                                under_monster["det"],
                                under_monster["user"],
                                monster_effect_kind,
                                under_monster["place"],
                                under_monster["deck_id"],
                                under_monster["x"],
                                under_monster["y"],
                                under_monster["mine_or_other"],
                        ):
                            continue
                    if val_name == "name":
                        return under_monster["monster_name"]
                    elif val_name == "place_id":
                        return under_monster["place_unique_id"]
                    if val_name != "":
                        tmp2 = under_monster["variables"]
                        return_tmp2 = 0
                        val_name = self.check_swap_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                        )
                        val_name2 = self.check_swap_init_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                        )
                        if val_name in tmp2:
                            return_tmp = tmp2[val_name2]["value"]
                        if (
                            isinstance(return_tmp, str)
                            and self.is_float(return_tmp) is False
                        ):
                            return return_tmp
                        else:
                            return_tmp = int(return_tmp)
                        if init == 0:
                            return_tmp = self.check_change_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                            return_tmp
                        )
                        if isinstance(return_tmp, str):
                            return return_tmp
                        if return_tmp < 0 and (
                            val_name not in tmp2 or tmp2[val_name]["minus"] is False
                        ):
                            return_tmp = 0
                        if self.is_float(return_tmp):
                            return_tmp2 += int(return_tmp)
                        else:
                            return return_tmp
                        if not isinstance(return_tmp, str) or self.is_float(return_tmp):
                            return_tmp2 += int(return_tmp)
                        else:
                            return return_tmp
                        return_value += return_tmp2
                    else:
                        return_value += 1
            else:
                if monster_effect_kind != "0":
                    if self.check_eternal_invalid(
                            monster["det"],
                            monster["user"],
                            monster_effect_kind,
                            monster["place"],
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            monster["mine_or_other"],
                    ):
                        continue
                if flag is True:
                    if "flag" in monster and monster["flag"] & flag == 0:
                        continue
                if(monster["det"] is None):
                    tmp2 = []
                else:
                    tmp2 = monster["det"]["variables"]
                return_tmp = 0
                if val_name == "":
                    return_tmp = 1
                elif val_name == "name":
                    return monster["det"]["monster_name"]
                else:
                    val_name = self.check_swap_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["user"],
                    )
                    val_name2 = self.check_swap_init_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["user"],
                    )
                    if val_name2 in tmp2:
                        if tmp2[val_name2]["value"].isnumeric():
                            return_tmp = int(tmp2[val_name2]["value"])
                        else:
                            return_tmp = 0
                    if init == 0:
                        return_tmp = self.check_change_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["mine_or_other"],
                        return_tmp
                    )
                    if isinstance(return_tmp, str):
                        return return_tmp
                    if return_tmp < 0 and (
                        val_name not in tmp2 or tmp2[val_name]["minus"] is False
                    ):
                        return_tmp = 0
                if change_val_flag and accumulate_flag is False:
                    self.raise_trigger_change_val(
                        monster, return_tmp, 0, effect_kind, monster["mine_or_other"], 1
                    )
                if accumulate_flag is True:
                    self.accumulate_global(
                        monster,
                        return_tmp,
                        0,
                        effect_kind,
                        monster["mine_or_other"],
                        global_name,
                    )
                    return_tmp = 0
                elif self.duel.alt_global != "" and global_name is not None:
                    alt_val = self.change_alt_global2(
                        global_name["variable_id"],
                        monster["mine_or_other"],
                        global_name["variable_how"],
                        effect_kind,
                        return_tmp,
                    )
                    return_tmp -= alt_val
                    instead_val = self.check_variable_instead(
                        global_name["variable_id"],
                        global_name["mine_or_other"],
                        return_tmp,
                        1,
                        monster["mine_or_other"],
                        effect_kind,
                    )
                    return_tmp -= instead_val
                    self.raise_trigger_change_val(
                        monster, return_tmp, 0, effect_kind, monster["mine_or_other"], 0
                    )
                return_value += return_tmp
        return return_value

    def get_val_trigger(
        self,
        val,
        monster,
        other_user_flag=False,
        effect_kind_rel="",
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
    ):
        val = val[1:-1]
        val = val.split(":")
        if len(val) > 1:
            val_name = val[1]
        else:
            val_name = ""
        rel_name = None
        if len(val) > 3:
            rel_name = val[3]
            rel_kind = val[4]
            rel_id = 0
        if len(val) > 5:
            if val[5] != "":
                rel_to = int(val[5])
            else:
                rel_to = 0
        if len(val) > 6:
            if val[6] != "":
                rel_id = int(val[6])
            else:
                rel_id = 0
        if len(val) > 7:
            under = int(val[7])
        else:
            under = False
        if (len(val) > 8) and val[8] != "":
            id = int(val[8])
        else:
            id = -1
        if (len(val) > 9) and val[9] != "":
            monster_effect_kind = val[9]
        else:
            monster_effect_kind = "0"
        if (len(val) > 10) and val[10] != "":
            init = int(val[10])
        else:
            init = 0

        return_value = 0
        if id != -1:
            if int(id) != int(self.get_monster_id_easy(monster["det"])):
                return 0
        if rel_name is not None and rel_name != "":
            if "rel" in monster["det"] and rel_kind in monster["det"]["rel"]:
                for rel_monster in monster["det"]["rel"][rel_kind]:
                    if rel_monster["name"] != rel_name or int(rel_monster["to"]) != rel_to:
                        continue
                    rel_monster_det = rel_monster["monster"]
                    monster2 = self.get_monster(
                        rel_monster_det["place"],
                        rel_monster_det["place_unique_id"],
                        rel_monster_det["mine_or_other"],
                        rel_monster_det["user"],
                        rel_monster_det["deck_id"],
                        rel_monster_det["x"],
                        rel_monster_det["y"],
                    )
                    if rel_id != 0:
                        if self.get_monster_id_easy(monster2["det"]) != rel_id:
                            continue
                    if monster_effect_kind != "0":
                        if self.check_eternal_invalid(
                                monster2["det"],
                                monster2["user"],
                                monster_effect_kind,
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                monster2["mine_or_other"],
                        ):
                            continue
                    if effect_kind_rel != "":
                        if self.check_not_effected(
                            monster2["det"],
                            monster2["user"],
                            effect_kind_rel,
                            monster2["place"],
                            monster2["deck_id"],
                            monster2["x"],
                            monster2["y"],
                            monster2["mine_or_other"],
                            0,
                        ):
                            continue
                    return_tmp = 0
                    if val_name == "place_id":
                        return monster2["place_unique_id"]
                    if val_name == "name":
                        return monster2["det"]["monster_name"]
                    else:
                        val_name = self.check_swap_val(
                            monster2["det"],
                            monster2["mine_or_other"],
                            monster2["place"],
                            monster2["deck_id"],
                            monster2["x"],
                            monster2["y"],
                            val_name,
                            1,
                        )
                        val_name2 = self.check_swap_init_val(
                            monster2["det"],
                            monster2["mine_or_other"],
                            monster2["place"],
                            monster2["deck_id"],
                            monster2["x"],
                            monster2["y"],
                            val_name,
                            1,
                        )
                        if val_name == "":
                            return_tmp += 1
                        else:
                            if init == 1:
                                return_tmp += int(
                                    monster2["det"]["variables"][val_name2]["i_val"]
                                )
                            else:
                                if val_name2 in monster2["det"]["variables"]:
                                    return_tmp += int(
                                        monster2["det"]["variables"][val_name2]["value"]
                                    )
                                return_tmp = self.check_change_val(
                                    monster2["det"],
                                    monster2["mine_or_other"],
                                    monster2["place"],
                                    monster2["deck_id"],
                                    monster2["x"],
                                    monster2["y"],
                                    val_name,
                                    1,
                                    return_tmp
                                )
                            if isinstance(return_tmp, str):
                                return return_tmp
                            if return_tmp < 0 and (
                                val_name not in monster2["det"]["variables"]
                                or monster2["det"]["variables"][val_name]["minus"] is False
                            ):
                                return_tmp = 0
                    if change_val_flag and accumulate_flag is False:
                        self.raise_trigger_change_val(
                            monster2,
                            return_tmp,
                            0,
                            effect_kind,
                            monster2["mine_or_other"],
                            1,
                        )
                    if accumulate_flag is True:
                        self.accumulate_global(
                            monster2,
                            return_tmp,
                            0,
                            effect_kind,
                            monster2["mine_or_other"],
                            global_name,
                        )
                        return_tmp = 0
                    elif self.duel.alt_global != "" and global_name is not None:
                        alt_val = self.change_alt_global2(
                            global_name["variable_id"],
                            monster2["mine_or_other"],
                            global_name["variable_how"],
                            effect_kind,
                            return_tmp,
                        )
                        return_tmp -= alt_val
                        instead_val = self.check_variable_instead(
                            global_name["variable_id"],
                            global_name["mine_or_other"],
                            return_tmp,
                            1,
                            monster2["mine_or_other"],
                            effect_kind,
                        )
                        return_tmp -= instead_val
                        self.raise_trigger_change_val(
                            monster2,
                            return_tmp,
                            0,
                            effect_kind,
                            monster2["mine_or_other"],
                            0,
                        )
                    return_value += return_tmp
        elif under == 1:
            if "under" not in monster["det"]:
                return 0
            for under_monster in monster["det"]["under"]:
                if monster_effect_kind != "0":
                    if self.check_eternal_invalid(
                            under_monster["det"],
                            under_monster["user"],
                            monster_effect_kind,
                            under_monster["place"],
                            under_monster["deck_id"],
                            under_monster["x"],
                            under_monster["y"],
                            under_monster["mine_or_other"],
                    ):
                        continue
                if val_name == "name":
                    return under_monster["monster_name"]
                elif val_name == "place_id":
                    return under_monster["place_unique_id"]
                if val_name != "":
                    tmp2 = under_monster["variables"]
                    return_tmp2 = 0
                    val_name = self.check_swap_val(
                        under_monster,
                        monster["mine_or_other"],
                        "under",
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["mine_or_other"],
                    )
                    val_name2 = self.check_swap_init_val(
                        under_monster,
                        monster["mine_or_other"],
                        "under",
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["mine_or_other"],
                    )
                    if init == 1:
                        return_tmp = tmp2[val_name2]["i_val"]
                    else:
                        if val_name in tmp2:
                            return_tmp = tmp2[val_name2]["value"]
                        if (
                            isinstance(return_tmp, str)
                            and self.is_float(return_tmp) is False
                        ):
                            return return_tmp
                        else:
                            return_tmp = int(return_tmp)
                        return_tmp = self.check_change_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                            return_tmp
                        )
                    if isinstance(return_tmp, str):
                        return return_tmp
                    if return_tmp < 0 and (
                        val_name not in tmp2 and tmp2[val_name]["minus"] is False
                    ):
                        return_tmp = 0
                    if not isinstance(return_tmp, str) or self.is_float(return_tmp):
                        return_tmp2 += int(return_tmp)
                    else:
                        return return_tmp
                    return_value += return_tmp2
                else:
                    return_value += 1
        else:
            if monster_effect_kind != "0":
                if self.check_eternal_invalid(
                        monster["det"],
                        monster["user"],
                        monster_effect_kind,
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        monster["mine_or_other"],
                ):
                   return 0
            if val_name == "name":
                return monster["det"]["monster_name"]
            elif val_name == "place_id":
                return monster["place_unique_id"]
            elif val_name == "x":
                return monster["x"]
            elif val_name == "y":
                return monster["y"]
            if val_name != "":
                tmp2 = monster["det"]["variables"]
                return_tmp2 = 0
                val_name = self.check_swap_val(
                    monster["det"],
                    monster["mine_or_other"],
                    monster["place"],
                    monster["deck_id"],
                    monster["x"],
                    monster["y"],
                    val_name,
                    monster["mine_or_other"],
                )
                val_name2 = self.check_swap_init_val(
                    monster["det"],
                    monster["mine_or_other"],
                    monster["place"],
                    monster["deck_id"],
                    monster["x"],
                    monster["y"],
                    val_name,
                    monster["mine_or_other"],
                )
                if init == 1:
                    return_tmp = int(tmp2[val_name2]["i_val"])
                else:
                    if val_name2 in tmp2:
                        return_tmp = int(tmp2[val_name2]["value"])
                        if (
                            isinstance(return_tmp, str)
                            and self.is_float(return_tmp) is False
                        ):
                            return return_tmp
                        else:
                            return_tmp = int(return_tmp)
                    else:
                        return_tmp = 0
                    return_tmp = self.check_change_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["mine_or_other"],
                        return_tmp
                    )
                if isinstance(return_tmp, str):
                    return return_tmp
                if return_tmp < 0 and (
                    val_name not in tmp2 or tmp2[val_name]["minus"] is False
                ):
                    return_tmp = 0
                if self.is_float(return_tmp):
                    return_tmp2 += int(return_tmp)
                else:
                    return return_tmp
                if change_val_flag and accumulate_flag is False:
                    self.raise_trigger_change_val(
                        monster, return_tmp, 0, effect_kind, monster["mine_or_other"], 1
                    )
                if accumulate_flag is True:
                    self.accumulate_global(
                        monster,
                        return_tmp,
                        0,
                        effect_kind,
                        monster["mine_or_other"],
                        global_name,
                    )
                    return_tmp = 0
                elif self.duel.alt_global != "" and global_name is not None:
                    alt_val = self.change_alt_global2(
                        global_name["variable_id"],
                        monster["mine_or_other"],
                        global_name["variable_how"],
                        effect_kind,
                        return_tmp,
                    )
                    return_tmp -= alt_val
                    instead_val = self.check_variable_instead(
                        global_name["variable_id"],
                        global_name["mine_or_other"],
                        return_tmp,
                        1,
                        monster["mine_or_other"],
                        effect_kind,
                    )
                    return_tmp -= instead_val
                    self.raise_trigger_change_val(
                        monster, return_tmp, 0, effect_kind, monster["mine_or_other"], 0
                    )
                return_value += return_tmp2
            else:
                return_value += 1
        return return_value

    def get_place_unique_id(self, val, mode=0):
        if val[0] == "~":
            return self.get_place_unique_id_cost(val, mode)
        elif val[0] == "%":
            return self.get_place_unique_id_timing_mess(val, mode)
        else:
            return self.get_place_unique_id_effect(val, mode)

    def get_name(self, val, mode=0, monster=None,place_unique_id = ""):
        if val == "tmp_val":
            return self.tmp_val[place_unique_id]
        elif val[0] != "{":
            return val
        if val[1] == "~":
            return self.get_name_cost(val, mode)
        elif val[1] == "^":
            return self.get_name_global(val)
        elif val[1] == "%":
            return self.get_name_timing_mess(val, mode)
        else:
            return self.get_name_effect(val, mode, monster)

    def get_name_global(self, val):
        duel = self.duel
        val = val[1:-1]
        variable = json.loads(duel.global_variable)
        return variable[val]

    def get_name_monster_all(self, monsters):
        return_value = ""
        for monster in monsters:
            return_value += monster["det"]["monster_name"] + " "
        return return_value

    def get_place_name(self,val,user):
        val = val[1:-1]
        val_ary = val.split(";")
        val_ary[1] = self.calculate_boland(val_ary[1],user = user)
        if val_ary[0] == "deck":
           return self.get_deck_name(val_ary[1],val_ary[2],val_ary[3],user)
        elif val_ary[0] == "grave":
            return self.get_grave_name(val_ary[1],val_ary[2],val_ary[3],user)
        elif val_ary[0] == "hand":
            return self.get_hand_name(val_ary[1],val_ary[2],val_ary[3],user)
    def get_deck_name(self,num,deck_id,rel_mine_or_other,user):
        deck_id = int(deck_id)
        rel_mine_or_other = int(rel_mine_or_other)
        mine_or_other = rel_mine_or_other
        if user  == 2:
            if rel_mine_or_other == 1:
                mine_or_other = 2
            elif rel_mine_or_other == 2:
                mine_or_other = 1
        if rel_mine_or_other == 1:
            if user == self.user:
                user_decks = self.decks[deck_id]["mydeck"]
            else:
                user_decks = self.decks[deck_id]["otherdeck"]
        elif rel_mine_or_other == 2:
            if user == self.user:
                user_decks = self.decks[deck_id]["otherdeck"]
            else:
                user_decks = self.decks[deck_id]["otherdeck"]
        else:
            user_decks = self.decks[deck_id]["commondeck"]
        return self.get_name_det(user_decks,"deck",deck_id,mine_or_other,num)
    def get_grave_name(self,num,deck_id,rel_mine_or_other,user):
        deck_id = int(deck_id)
        rel_mine_or_other = int(rel_mine_or_other)
        mine_or_other = rel_mine_or_other
        if user  == 2:
            if rel_mine_or_other == 1:
                mine_or_other = 2
            elif rel_mine_or_other == 2:
                mine_or_other = 1
        if rel_mine_or_other == 1:
            user_graves = self.graves[deck_id]["mygrave"]
        elif rel_mine_or_other == 2:
            user_graves = self.graves[deck_id]["othergrave"]
        else:
            user_graves = self.graves[deck_id]["commongrave"]
        return self.get_name_det(user_graves,"grave",deck_id,mine_or_other,num)
    def get_hand_name(self,num,deck_id,rel_mine_or_other,user):
        deck_id = int(deck_id)
        rel_mine_or_other = int(rel_mine_or_other)
        mine_or_other = rel_mine_or_other
        if user  == 2:
            if rel_mine_or_other == 1:
                mine_or_other = 2
            elif rel_mine_or_other == 2:
                mine_or_other = 1
        if rel_mine_or_other == 1:
            user_hands = self.hands[deck_id]["myhand"]
        elif rel_mine_or_other == 2:
            user_hands = self.hands[deck_id]["otherhand"]
        else:
            user_hands = self.hands[deck_id]["commonhand"]
        return self.get_name_det(user_hands,"hand",deck_id,mine_or_other,num)
    def get_name_det(self,cards,place,deck_id,mine_or_other,num):
        ret = ""
        i = 0
        for card in cards:
            monster_name = self.check_change_name(
                card,
                mine_or_other,
                place,
                deck_id,
                0,
                0,
                mine_or_other,
            )
            ret += monster_name[0]+","
            i += 1
            if i >= num:
                break
        ret = ret[:-1]
        return ret


    def get_name_all(self, val, mode=0):
        if val[0] != "{":
            return val
        if val[1] == "~":
            return self.get_name_cost_all(val, mode)
        elif val[1] == "%":
            return self.get_name_timing_mess_all(val, mode)
        else:
            return self.get_name_effect_all(val, mode)

    def get_place_unique_id_cost(self, val, mode):
        tmp = self.cost
        tmp = tmp[str(self.tmp_chain)][val]
        tmp = tmp[0]
        return tmp["det"]["place_unique_id"]

    def get_place_unique_id_timing_mess(self, val, mode):
        tmp = self.timing_mess
        tmp = tmp[val]
        tmp = tmp[0]
        return tmp["det"]["place_unique_id"]

    def get_place_unique_id_effect(self, val, mode):
        duel = self.duel
        tmp = self.mess
        tmp = tmp[str(duel.chain - 1)][val]
        tmp = tmp[0]
        return tmp["det"]["place_unique_id"]

    def get_card_unique_id_cost(self, val, mode):
        tmp = self.cost
        tmp = tmp[str(self.tmp_chain)][val]
        tmp = tmp[0]
        return tmp["det"]["card_unique_id"]

    def get_card_unique_id_timing_mess(self, val, mode):
        tmp = self.timing_mess
        tmp = tmp[val]
        tmp = tmp[0]
        return tmp["det"]["card_unique_id"]

    def get_card_unique_id_effect(self, val, mode):
        duel = self.duel
        tmp = self.mess
        tmp = tmp[str(duel.chain - 1)][val]
        tmp = tmp[0]
        return tmp["det"]["card_unique_id"]

    def get_name_cost(self, val, mode):
        val = val[2:-1]
        tmp = self.cost
        tmp = tmp[str(self.tmp_chain)][val]
        tmp = tmp[0]
        if mode == 1 and tmp["det"]["variables"]["show"]["value"] == "1":
            hide_name = self.config.hide_name
            return hide_name
        return tmp["det"]["monster_name"]

    def get_name_cost_all(self, val, mode):
        val = val[1:-1]
        tmp = self.cost
        tmps = tmp[str(self.tmp_chain)][val]
        return_value = []
        for tmp in tmps:
            if mode == 1 and tmp["det"]["variables"]["show"]["value"] == "1":
                hide_name = self.config.hide_name
                return_value.append(hide_name)
            else:
                return_value.append(tmp["det"]["monster_name"])
        return return_value

    def get_name_timing_mess_all(self, val, mode):
        val = val[2:-1]
        tmp = self.timing_mess
        tmps = tmp[val]
        return_value = []
        for tmp in tmps:
            if mode == 1 and tmp["det"]["variables"]["show"]["value"] == "1":
                hide_name = self.config.hide_name
                return_value.appned(hide_name)
        else:
            return_value.appned(tmp["det"]["monster_name"])

        return return_value

    def get_name_timing_mess(self, val, mode):
        val = val[2:-1]
        tmp = self.timing_mess
        tmp = tmp[val]
        tmp = tmp[0]

        if mode == 1 and tmp["det"]["variables"]["show"]["value"] == "1":
            hide_name = self.config.hide_name
            return hide_name
        return tmp["det"]["monster_name"]

    def get_name_effect_all(self, val, mode):
        duel = self.duel
        val = val[1:-1]
        tmp = self.mess
        if val not in tmp[str(duel.chain-1)]:
            return []
        tmps = tmp[str(duel.chain - 1)][val]
        return_value = []
        for tmp in tmps:
            if mode == 1 and tmp["det"]["variables"]["show"]["value"] == "1":
                hide_name = self.config.hide_name
                return_value.appned(hide_name)
        else:
            return_value.append(tmp["det"]["monster_name"])

        return return_value

    def get_name_effect(self, val, mode, monster):
        duel = self.duel
        val = val[1:-1]
        val = val.split(":")
        tmp = self.mess
        tmp = tmp[str(duel.chain - 1)][val[0]]
        tmp = tmp[0]
        user = tmp["user"]
        place = tmp["place"]
        deck_id = tmp["deck_id"]
        x = tmp["x"]
        y = tmp["y"]
        mine_or_other = tmp["mine_or_other"]
        if len(val) >= 2:
            if "eternal" in tmp:
                for i in range(len(tmp["eternal"])):
                    if tmp["eternal"][i] is None:
                        continue
                    if not self.check_eternal_invalid(
                        tmp,
                        user,
                        tmp["eternal"][i]["effect_kind"],
                        place,
                        deck_id,
                        x,
                        y,
                        mine_or_other,
                    ):
                        if val[1] in tmp["eternal"][i]["variables"]:
                            return tmp["eternal"][i]["variables"]
            return tmp["det"]["variables"][val[1]]["value"]
        if mode == 1 and tmp["det"]["variables"]["show"]["value"] == "1":
            hide_name = self.config.hide_name
            return hide_name

        return tmp["det"]["monster_name"]

    def get_val_cost(
        self,
        val,
        other_user_flag=False,
        effect_kind_rel="",
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
    ):
        return_value = 0
        val = val[1:-1]
        val = val.split(":")
        name = val[0]
        val_name = val[1]
        if 2 in val and val[2] != "":
            flag = val[2]
        else:
            flag = False
        tmp = self.cost
        if self.duel.in_cost is True:
            if name in tmp[str(self.tmp_chain)]:
                tmp = tmp[str(self.tmp_chain)][name]
            else:
                tmp = {}
        else:
            if name in tmp[str(self.duel.chain - 1)]:
                tmp = tmp[str(self.duel.chain - 1)][name]
            else:
                tmp = {}
        rel_name = None
        if len(val) > 3:
            rel_name = val[3]
            rel_kind = val[4]
            if val[5] != "":
                rel_to = int(val[5])
            else:
                rel_to = 0
            if val[6] != "":
                rel_id = int(val[6])
            else:
                rel_id = 0
        if len(val) > 7 and val[7] != "":
            under = int(val[7])
        else:
            under = 0
        if (len(val) > 8) and val[8] != "":
            id = int(val[8])
        else:
            id = -1
        if (len(val) > 9) and val[9] != "":
            monster_effect_kind = val[9]
        else:
            monster_effect_kind = "0"
        return_value = 0
        for monster in tmp:
            if id != -1:
                if int(id) != int(self.get_monster_id_easy(monster["det"])):
                    return 0
            if rel_name is not None and rel_name != "":
                if "rel" in monster["det"] and rel_kind in monster["det"]["rel"]:
                    for rel_monster in monster["det"]["rel"][rel_kind]:
                        if (
                            rel_monster["name"] != rel_name
                            or rel_monster["to"] != rel_to
                        ):
                            continue
                        rel_monster_det = rel_monster["monster"]
                        monster2 = self.get_monster(
                            rel_monster_det["place"],
                            rel_monster_det["place_unique_id"],
                            rel_monster_det["mine_or_other"],
                            rel_monster_det["user"],
                            rel_monster_det["deck_id"],
                            rel_monster_det["x"],
                            rel_monster_det["y"],
                        )
                        if rel_id != "":
                            if self.get_monster_id_easy(monster2["det"]) != rel_id:
                                continue
                        if monster_effect_kind != "0":
                            if self.check_eternal_invalid(
                                    monster2["det"],
                                    monster2["user"],
                                    monster_effect_kind,
                                    monster2["place"],
                                    monster2["deck_id"],
                                    monster2["x"],
                                    monster2["y"],
                                    monster2["mine_or_other"],
                            ):
                                continue
                        if effect_kind_rel != "":
                            if self.check_not_effected(
                                monster2["det"],
                                monster2["user"],
                                effect_kind_rel,
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                monster2["mine_or_other"],
                                1,
                            ):
                                return "NoneEffect"
                        return_tmp = 0
                        if val_name == "place_id":
                            return monster2["place_unique_id"]
                        if val_name == "name":
                            return monster2["det"]["monster_name"]
                        else:
                            val_name = self.check_swap_val(
                                monster2["det"],
                                monster2["mine_or_other"],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                val_name,
                                1,
                            )
                            val_name2 = self.check_swap_init_val(
                                monster2["det"],
                                monster2["mine_or_other"],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                val_name,
                                1,
                            )
                            if val_name2 in monster2["det"]["variables"]:
                                return_tmp = int(
                                    monster2["det"]["variables"][val_name2]["value"]
                                )
                            return_tmp = self.check_change_val(
                                monster2["det"],
                                monster2["mine_or_other"],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                val_name,
                                1,
                                return_tmp
                            )
                            if isinstance(return_tmp, str):
                                return return_tmp
                            if return_tmp < 0 and (
                                val_name2 not in monster2["det"]["variables"]
                                or monster2["det"]["variables"][val_name2]["minus"]
                                is False
                            ):
                                return_tmp = 0
                        if change_val_flag and accumulate_flag is False:
                            self.raise_trigger_change_val(
                                monster2,
                                return_tmp,
                                0,
                                effect_kind,
                                monster2["mine_or_other"],
                                1,
                            )
                        if accumulate_flag is True:
                            self.accumulate_global(
                                monster2,
                                return_tmp,
                                0,
                                effect_kind,
                                monster2["mine_or_other"],
                                global_name,
                            )
                            return_tmp = 0
                        elif self.duel.alt_global != "" and global_name is not None:
                            alt_val = self.change_alt_global2(
                                global_name["variable_id"],
                                monster2["mine_or_other"],
                                global_name["variable_how"],
                                effect_kind,
                                return_tmp,
                            )
                            return_tmp -= alt_val
                            instead_val = self.check_variable_instead(
                                global_name["variable_id"],
                                global_name["mine_or_other"],
                                return_tmp,
                                1,
                                monster2["mine_or_other"],
                                effect_kind,
                            )
                            return_tmp -= instead_val
                            self.raise_trigger_change_val(
                                monster2,
                                return_tmp,
                                0,
                                effect_kind,
                                monster2["mine_or_other"],
                                0,
                            )
                        return_value += return_tmp
            elif under == 1:
                if "under" not in monster["det"]:
                    return 0
                for under_monster in monster["det"]["under"]:
                    if monster_effect_kind != "0":
                        if self.check_eternal_invalid(
                                under_monster["det"],
                                under_monster["user"],
                                monster_effect_kind,
                                under_monster["place"],
                                under_monster["deck_id"],
                                under_monster["x"],
                                under_monster["y"],
                                under_monster["mine_or_other"],
                        ):
                            continue
                    if val_name == "name":
                        return under_monster["monster_name"]
                    elif val_name == "place_id":
                        return under_monster["place_unique_id"]
                    if val_name != "":
                        tmp2 = under_monster["variables"]
                        return_tmp2 = 0
                        val_name = self.check_swap_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                        )
                        val_name2 = self.check_swap_init_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                        )
                        if val_name2 in tmp2:
                            return_tmp = tmp2[val_name2]["value"]
                        if (
                            isinstance(return_tmp, str)
                            and self.is_float(return_tmp) is False
                        ):
                            return return_tmp
                        else:
                            return_tmp = int(return_tmp)
                        return_tmp = self.check_change_val(
                            under_monster,
                            monster["mine_or_other"],
                            "under",
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            val_name,
                            monster["mine_or_other"],
                            return_tmp
                        )
                        if isinstance(return_tmp, str):
                            return return_tmp
                        if return_tmp < 0 and (
                            val_name not in tmp2 or tmp2[val_name]["minus"] is False
                        ):
                            return_tmp = 0
                        if self.is_float(return_tmp):
                            pass
                        else:
                            return return_tmp
                        if not isinstance(return_tmp, str) or self.is_float(return_tmp):
                            return_tmp2 += int(return_tmp)
                        else:
                            return return_tmp
                        return_value += return_tmp2
                    else:
                        return_value += 1
            else:
                if monster_effect_kind != "0":
                    if self.check_eternal_invalid(
                            monster["det"],
                            monster["user"],
                            monster_effect_kind,
                            monster["place"],
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            monster["mine_or_other"],
                    ):
                        continue
                if flag is True:
                    if monster["flag"] & flag == 0:
                        continue
                tmp2 = monster["det"]["variables"]
                return_tmp = 0
                if val_name == "name":
                    return monster["det"]["monster_name"]
                else:
                    val_name = self.check_swap_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["user"],
                    )
                    val_name2 = self.check_swap_init_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["user"],
                    )
                    if val_name2 in tmp2:
                        if tmp2[val_name2]["value"].isnumeric():
                            return_tmp += int(tmp2[val_name2]["value"])
                    return_tmp = self.check_change_val(
                        monster["det"],
                        monster["mine_or_other"],
                        monster["place"],
                        monster["deck_id"],
                        monster["x"],
                        monster["y"],
                        val_name,
                        monster["mine_or_other"],
                        return_tmp
                    )
                    if isinstance(return_tmp, str):
                        return return_tmp
                    if return_tmp < 0 and (
                        val_name not in tmp2 or tmp2[val_name2]["minus"] is False
                    ):
                        return_tmp = 0
                if change_val_flag and accumulate_flag is False:
                    self.raise_trigger_change_val(
                        monster, return_tmp, 0, effect_kind, monster["mine_or_other"], 1
                    )
                if accumulate_flag is True:
                    self.accumulate_global(
                        monster,
                        return_tmp,
                        0,
                        effect_kind,
                        monster["mine_or_other"],
                        global_name,
                    )
                    return_tmp = 0
                elif self.duel.alt_global != "" and global_name is not None:
                    alt_val = self.change_alt_global2(
                        global_name["variable_id"],
                        monster["mine_or_other"],
                        global_name["variable_how"],
                        effect_kind,
                        return_tmp,
                    )
                    return_tmp -= alt_val
                    instead_val = self.check_variable_instead(
                        global_name["variable_id"],
                        global_name["mine_or_other"],
                        return_tmp,
                        1,
                        monster["mine_or_other"],
                        effect_kind,
                    )
                    return_tmp -= instead_val
                    self.raise_trigger_change_val(
                        monster, return_tmp, 0, effect_kind, monster["mine_or_other"], 0
                    )
                return_value += return_tmp
        return return_value

    def get_val_global(self, val, other_user_flag=False, effect_kind="",other_user_flag2=False):
        duel = self.duel
        chain = str(duel.chain - 1)
        if duel.in_cost is True:
            chain = str(self.tmp_chain)
            user = duel.cost_user
        elif self.duel.retrieve == 0 and (duel.chain == 0 or duel.ask > 0):
            user = self.user
        elif self.duel.retrieve == 0 and other_user_flag2 is True:
            if self.user == 1:
                user = 2
            elif self.user == 2:
                user = 1
        elif self.duel.retrieve == 0:
            user = self.user
        elif  duel.chain == 0:
            user = self.user
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        val = val[1:-1]
        val = val.split(":")
        variable_name = val[0]
        if variable_name == "turncount":
            return duel.turn_count
        if variable_name == "chain":
            return duel.virtual_chain
        mine_or_other = int(val[1])
        variable = json.loads(duel.global_variable)
        chain_variable_det = json.loads(duel.chain_variable)
        if mine_or_other == 0:
            if variable_name in variable:
                return int(variable[variable_name]["value"])
            elif variable_name in self.virtual_variables:
                return int(self.virtual_variables[variable_name]["value"])
            elif (
                chain in chain_variable_det
                and variable_name in chain_variable_det[chain]
            ):
                return chain_variable_det[chain][variable_name]
            else:
                return 0
        if other_user_flag is True:
            if mine_or_other == 1:
                mine_or_other2 = 2
            elif mine_or_other == 2:
                mine_or_other2 = 1
        else:
            mine_or_other2 = mine_or_other
        if (mine_or_other2 == 1 and user == 1) or (mine_or_other2 == 2 and user == 2):
            if variable_name in variable:

                return int(variable[variable_name]["1_value"])
            elif variable_name in self.virtual_variables:
                return int(self.virtual_variables[variable_name]["1_value"])
            elif (
                chain in chain_variable_det
                and variable_name in chain_variable_det[chain]
            ):
                return chain_variable_det[chain][variable_name]
            else:
                return 0
        if (mine_or_other2 == 2 and user == 1) or (mine_or_other2 == 1 and user == 2):
            if variable_name in variable:
                return int(variable[variable_name]["2_value"])
            elif variable_name in self.virtual_variables:
                return int(self.virtual_variables[variable_name]["2_value"])
            elif (
                chain in chain_variable_det
                and variable_name in chain_variable_det[chain]
            ):
                return chain_variable_det[chain][variable_name]
            else:
                return 0

    def special_val(self,val):
        if val== "-" or  val == "{" or val == "[" or val == "[" or val == "&" or val=="|" or val=="^":
            return True
        return False
    def calculate_boland(
        self,
        boland,
        monster=None,
        other_user_flag=False,
        mode=0,
        monster2=None,
        effect_kind_rel="",
        change_val_flag=False,
        effect_kind="",
        accumulate_flag=False,
        global_name=None,
        other_user_flag2=False,
        eternal = False,
        user = None
    ):
        if other_user_flag2 == True:
            other_user_flag = True
        if boland == "":
            return 0
        operator = {
            "SWITCH": (lambda x, y: x if int(y) != 0 else 0 ),
            "SWITCH2": (lambda x, y: x if int(y) == 0 else 0 ),
            "MIN": (lambda x, y: min(x, y)),
            "MAX": (lambda x, y: max(x, y)),
            "+": (lambda x, y: x + y),
            "-": (lambda x, y: x - y),
            "*": (lambda x, y: x * y),
            "/": (lambda x, y: float(x) / y),
        }
        stack = []
        boland = str(boland)
        states = boland.split("$")
        for index, z in enumerate(states):
            if z not in operator.keys():
                if z[0] == "-":
                    minus_flag = True
                    z = z[1:]
                else:
                    minus_flag = False
                if z[0] == "{":
                    if z[1] != "~":
                        if z[1] == "%":
                            z = self.get_val(
                                z,
                                other_user_flag,
                                effect_kind_rel,
                                change_val_flag,
                                effect_kind,
                                accumulate_flag,
                                global_name,
                                1,
                            )
                        else:
                            tmp = z[1:-1].split(":")
                            if (
                                monster is None
                                or monster == 0
                                or tmp[0] != "this"
                            ):
                                z = self.get_val(
                                    z,
                                    other_user_flag,
                                    effect_kind_rel,
                                    change_val_flag,
                                    effect_kind,
                                    accumulate_flag,
                                    global_name,
                                )
                            else:
                                pprint(monster)
                                z = self.get_val_trigger(
                                    z,
                                    monster,
                                    other_user_flag,
                                    effect_kind_rel,
                                    change_val_flag,
                                    effect_kind,
                                    accumulate_flag,
                                    global_name,
                                )
                    else:
                        z = self.get_val_cost(
                            z,
                            other_user_flag,
                            effect_kind_rel,
                            change_val_flag,
                            effect_kind,
                            accumulate_flag,
                            global_name,
                        )
                elif z[0] == "[":
                    z = self.get_val_designated(
                        z,
                        other_user_flag,
                        change_val_flag,
                        effect_kind,
                        accumulate_flag,
                        global_name,
                    )
                elif z[0] == "&":
                    z = self.get_val_sum(
                        z,
                        other_user_flag,
                        change_val_flag,
                        effect_kind,
                        accumulate_flag,
                        global_name,
                        eternal,
                        user
                    )
                elif z[0] == "|":
                    z = self.get_val_sum_field(
                        z,
                        other_user_flag,
                        change_val_flag,
                        effect_kind,
                        accumulate_flag,
                        global_name,
                        eternal
                    )
                elif z[0] == "=":
                    t = stack.pop()
                    z = self.get_val_floor(z, t, other_user_flag, effect_kind)
                elif z[0] == "#":
                    z = self.get_val_variable_mess(z, other_user_flag, effect_kind)
                elif z[0] == "^":
                    z = self.get_val_global(z, other_user_flag, effect_kind,other_user_flag2)
                else:
                    if z[0] == "r":
                        if user  == 1:
                            z = float(z[2:])
                        else:
                            z = -float(z[2:])
                    else:
                        z = float(z)
                if z == "NoneEffect":
                    return 0
                if minus_flag == True:
                    z = -z
                stack.append(z)
                continue
            y = stack.pop()
            x = stack.pop()
            stack.append(operator[z](float(x), float(y)))
        if isinstance(stack[0], str):
            return stack[0]
        if mode == 0:
            return max(float(stack[0]), 0)
        elif mode == 1:
            return float(stack[0])

    def end_cost_flag(self, cost_user):
        if not self.cost_result:
            return
        cost = self.cost_result
        if "flag" in cost:
            if "field" in cost["variable"]:
                field = self.field
                for tmp in cost["variable"]["field"]:
                    x = tmp["x"]
                    y = tmp["y"]
                    place_unique_id = tmp["place_unique_id"]
                    if self.config.sort is True:
                        x = self.search_place_unique_id(y,place_unique_id)
                        if x == -1:
                            continue
                    else:
                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                            continue
                    if "change_flag" in tmp:
                        flag = tmp["change_flag"]
                    else:
                        flag = 0
                    field[x][y]["det"]["flag"] = flag

                self.field = field

            if "deck" in cost["flag"]:
                for tmp in cost["variable"]["flag"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        user_decks = self.decks[deck_id]["mydeck"]
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        user_decks = self.decks[deck_id]["otherdeck"]
                    elif user == 3:
                        user_decks = self.decks[deck_id]["commondeck"]
                    for key in range(len(user_decks)):
                        user_deck = user_decks[key]
                        if place_unique_id == user_deck["place_unique_id"]:
                            change_flag = tmp["change_flag"]
                            user_deck["flag"] = change_flag
                        user_decks[key] = user_deck
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif user == 3:
                        self.decks[deck_id]["commondeck"] = user_decks

            if "grave" in cost["flag"]:
                for tmp in cost["flag"]["grave"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        user_graves = self.graves[deck_id]["mygrave"]
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        user_graves = self.graves[deck_id]["othergrave"]
                    elif user == 3:
                        user_graves = self.graves[deck_id]["commongrave"]
                    for key in range(len(user_graves)):
                        user_grave = user_graves[key]
                        if place_unique_id == user_grave["place_unique_id"]:
                            change_flag = tmp["change_flag"]
                            user_grave["flag"] = change_flag
                        user_graves[key] = user_grave
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif (user == 2 and 1 == self.user) or user == 1 and 2 == self.user:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif user == 3:
                        self.graves[deck_id]["commongrave"] = user_graves

            if "hand" in cost["flag"]:
                for tmp in cost["flag"]["hand"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        user_hands = self.hands[deck_id]["myhand"]
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        user_hands = self.hands[deck_id]["otherhand"]
                    elif user == 3:
                        user_hands = self.hands[deck_id]["commonhand"]
                    for key in range(len(user_hands)):
                        user_hand = user_hands[key]
                        if place_unique_id == user_hand["place_unique_id"]:
                            change_flag = tmp["change_flag"]
                            user_hand["flag"] = change_flag
                        user_hands[key] = user_hand
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        self.hands[deck_id]["myhand"] = user_hands
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif user == 3:
                        self.hands[deck_id]["commonhand"] = user_hands

    def end_cost_variable(self, cost_user):
        if not self.cost_result:
            return
        cost = self.cost_result
        if "variable" in cost:
            if "field" in cost["variable"]:
                field = self.field
                for tmp in cost["variable"]["field"]:
                    x = tmp["x"]
                    y = tmp["y"]
                    place_unique_id = tmp["place_unique_id"]
                    tmp2 = {}
                    tmp2["det"] = field[x][y]["det"]
                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                    tmp2["user"] = cost_user
                    tmp2["place"] = "field"
                    tmp2["deck_id"] = 0
                    tmp2["x"] = x
                    tmp2["y"] = y
                    tmp2["place_unique_id"] = field[x][y]["det"][
                        "place_unique_id"
                    ]
                    if self.config.sort is True:
                        x = self.search_place_unique_id(y,place_unique_id)
                        if x == -1:
                            continue
                    else:
                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                            continue
                    change_val_eternal = tmp["change_variable"]
                    if "eternal" not in field[x][y]["det"]:
                        field[x][y]["det"]["eternal"] = []
                    field[x][y]["det"]["eternal"].append(change_val_eternal)
                    for change_tmp in change_val_eternal["variables"].keys():
                        self.raise_trigger_monster_change_val(tmp2, change_val_eternal["variables"][change_tmp]["value"], "cost",
                                                      change_val_eternal["variables"][change_tmp]["effect_kind"], cost_user, 1, change_tmp)
                self.field = field

            if "deck" in cost["variable"]:
                for tmp in cost["variable"]["deck"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        user_decks = self.decks[deck_id]["mydeck"]
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        user_decks = self.decks[deck_id]["otherdeck"]
                    elif user == 3:
                        user_decks = self.decks[deck_id]["commondeck"]
                    for key in range(len(user_decks)):
                        user_deck = user_decks[key]
                        if place_unique_id == user_deck["place_unique_id"]:
                            change_val_eternal = tmp["change_variable"]
                            if "eternal" not in user_deck:
                                user_deck["eternal"] = []
                            user_deck["eternal"].append(change_val_eternal)
                            tmp2 = {}
                            tmp2["det"] = user_deck
                            tmp2["mine_or_other"] = user
                            tmp2["user"] = cost_user
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_deck[
                                "place_unique_id"
                            ]
                            self.raise_trigger_monster_change_val(tmp2, change_val_eternal["variable_name"],
                                                              "cost",
                                                              change_val_eternal["effect_kind"], cost_user, 1,
                                                              change_val_eternal["variable_name"])
                        user_decks[key] = user_deck
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif user == 3:
                        self.decks[deck_id]["commondeck"] = user_decks

            if "grave" in cost["variable"]:
                for tmp in cost["variable"]["grave"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        user_graves = self.graves[deck_id]["mygrave"]
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        user_graves = self.graves[deck_id]["othergrave"]
                    elif user == 3:
                        user_graves = self.graves[deck_id]["commongrave"]
                    for key in range(len(user_graves)):
                        user_grave = user_graves[key]
                        if place_unique_id == user_grave["place_unique_id"]:
                            change_val_eternal = tmp["change_variable"]
                            if "eternal" not in user_grave:
                                user_grave["eternal"] = []
                            user_grave["eternal"].append(change_val_eternal)
                            tmp2 = {}
                            tmp2["det"] = user_grave
                            tmp2["mine_or_other"] = user
                            tmp2["user"] = cost_user
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_grave[
                                "place_unique_id"
                            ]
                            self.raise_trigger_monster_change_val(tmp2, change_val_eternal["variable_name"],
                                                              "cost",
                                                              change_val_eternal["effect_kind"], cost_user, 1,
                                                              change_val_eternal["variable_name"])
                        user_graves[key] = user_grave
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif user == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
            if "hand" in cost["variable"]:
                for tmp in cost["variable"]["hand"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        user_hands = self.hands[deck_id]["myhand"]
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        user_hands = self.hands[deck_id]["otherhand"]
                    elif user == 3:
                        user_hands = self.hands[deck_id]["commonhand"]
                    for key in range(len(user_hands)):
                        user_hand = user_hands[key]
                        if place_unique_id == user_hand["place_unique_id"]:
                            change_val_eternal = tmp["change_variable"]
                            if "eternal" not in user_hand:
                                user_hand["eternal"] = []
                            user_hand["eternal"].append(change_val_eternal)
                            tmp2 = {}
                            tmp2["det"] = user_hand
                            tmp2["mine_or_other"] = user
                            tmp2["user"] = cost_user
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_hand[
                                "place_unique_id"
                            ]
                            for change_tmp in change_val_eternal["variables"]:
                                self.raise_trigger_monster_change_val(tmp2,
                                                              change_val_eternal["variables"][change_tmp]["value"], "cost",
                                change_val_eternal["effect_kind"], cost_user, 1, change_tmp)
                        user_hands[key] = user_hand
                    if (user == 1 and 1 == self.user) or (user == 2 and 2 == self.user):
                        self.hands[deck_id]["myhand"] = user_hands
                    elif (user == 2 and 1 == self.user) or (
                        user == 1 and 2 == self.user
                    ):
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif user == 3:
                        self.hands[deck_id]["commonhand"] = user_hands

    def end_cost_remove(self, cost_user):
        if not self.cost_result:
            return
        cost = self.cost_result
        if "remove" in cost:
            if "field" in cost["remove"]:
                field = self.field
                for tmp in cost["remove"]["field"]:
                    x = tmp["x"]
                    y = tmp["y"]
                    place_unique_id = tmp["place_unique_id"]
                    if self.config.sort is True:
                        x = self.search_place_unique_id(y,place_unique_id)
                        if x == -1:
                            continue
                    else:
                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                            continue
                    field[x][y]["det"] = None
                    self.effect += "field_move;"+str(x)+";"+str(y)+"|"
                    self.effect2 += "field_move;"+str(x)+";"+str(y)+"|"
                    if self.config.sort is True:
                        field = self.sortField(field,y)
                self.field = field
            if "under" in cost["remove"]:
                field = self.field
                for tmp in cost["remove"]["field"]:
                    x = tmp["x"]
                    y = tmp["y"]
                    place_unique_id = tmp["place_unique_id"]
                    if self.config.sort is True:
                        x = self.search_place_unique_id(y,place_unique_id)
                        if x == -1:
                            continue
                    else:
                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                            continue
                    for under in range(len(field[x][y]["det"]["under"])):
                        if (
                            field[x][y]["det"]["under"][under]["place_unique_id"]
                            == tmp["under_id"]
                        ):
                            field[x][y]["det"]["under"].pop(under)
                self.field = field

            if "deck" in cost["remove"]:
                for tmp in cost["remove"]["deck"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and self.user == 1) or (user == 2 and self.user == 2):
                        user_decks = self.decks[deck_id]["mydeck"]
                    elif (user == 2 and self.user == 1) or (user == 1 and self.user == 2):
                        user_decks = self.decks[deck_id]["otherdeck"]
                    elif user == 3:
                        user_decks = self.decks[deck_id]["commondeck"]
                    for user_deck in user_decks:
                        if place_unique_id == user_deck["place_unique_id"]:
                            user_decks.remove(user_deck)
                    if (user == 1 and self.user == 1) or (user == 2 and self.user == 2):
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif (user == 2 and self.user == 1) or (user == 1 and self.user == 2):
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif user == 3:
                        self.decks[deck_id]["commondeck"] = user_decks

            if "grave" in cost["remove"]:
                for tmp in cost["remove"]["grave"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and self.user == 1) or ( user == 2 and self.user == 2):
                        user_graves = self.graves[deck_id]["mygrave"]
                    elif (user == 2 and self.user == 1) or (user == 1 and self.user == 2):
                        user_graves = self.graves[deck_id]["othergrave"]
                    elif user == 3:
                        user_graves = self.graves[deck_id]["commongrave"]
                    for user_grave in user_graves:
                        if place_unique_id == user_grave["place_unique_id"]:
                            user_graves.remove(user_grave)
                    if (user == 1 and self.user == 1) or (user == 2 and self.user == 2):
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif (user == 2 and self.user == 1) or (user == 1 and self.user == 2):
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif user == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
            if "hand" in cost["remove"]:
                for tmp in cost["remove"]["hand"]:
                    deck_id = tmp["deck_id"]
                    user = tmp["user"]
                    place_unique_id = tmp["place_unique_id"]
                    if (user == 1 and self.user == 1) or (user == 2 and self.user == 2):
                        user_hands = self.hands[deck_id]["myhand"]
                    elif (user == 2 and self.user == 1) or (user == 1 and self.user == 2):
                        user_hands = self.hands[deck_id]["otherhand"]
                    elif user == 3:
                        user_hands = self.hands[deck_id]["commonhand"]
                    for user_hand in user_hands:
                        if place_unique_id == user_hand["place_unique_id"]:
                            user_hands.remove(user_hand)
                    if (user == 1 and self.user == 1) or (user == 2 and self.user == 2):
                        self.hands[deck_id]["myhand"] = user_hands
                    elif (user == 2 and self.user == 1) or (user == 1 and self.user == 2):
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif user == 3:
                        self.hands[deck_id]["commonhand"] = user_hands

    def pay_cost_copy(self, cost, user,org_chain):
        self.in_execute = True
        duel = self.duel

        if cost is None:
            return None
        cost_unwrap = cost.cost
        duel.in_cost = True
        while copy == 1 and cost_unwrap.effect_flag is False:
            if cost_unwrap.cost_val == 0:
                cost_condition = json.loads(cost_unwrap.cost_condition)
                duel.cost_log += self.write_log(cost.log, user)
                if self.check_cost_condition(cost_condition, cost.cost_kind):
                    if cost.pac:
                        cost_next = self._pac_cost(cost.pac)
                    else:
                        if cost.cost_next:
                            cost_next = cost.cost_next
                        else:
                            cost_next = self.pop_pac_cost(user)
                else:
                    if cost.pac2:
                        cost_next = self._pac_cost(cost.pac2)
                    else:
                        if cost.cost_next2:
                            cost_next = cost.cost_next2
                        else:
                            cost_next = self.pop_pac_cost2(user)

            else:
                if cost.pac:
                    cost_next = self._pac_cost(cost.pac)
                else:
                    if cost.cost_next:
                        cost_next = cost.cost_next
                    else:
                        cost_next = self.pop_pac_cost(user)
                if not cost_next or cost_next == -2:
                    return None
            cost = cost_next
            cost_unwrap = cost.cost
        return cost

    def pay_cost_force(self, cost, user,org_chain,trigger):
        self.in_execute = True
        duel = self.duel
        duel.in_copying = True
        in_copying_org = duel.in_copying
        chain = duel.chain - 1
        self.tmp_chain  = chain

        if cost is None:
            self.end_cost(user,org_chain,trigger)
            if self.copying_flag >= 2:
                if trigger.chain_flag is True:
                    self.duel.virtual_chain += 1
                self.duel.chain += 1
            return True
        strategy = cost.strategy
        strategy_up_or_down = cost.strategy_up_or_down
        cost_unwrap = cost.cost
        duel.in_cost = True
        chain_user_json = json.loads(self.duel.chain_user)
        chain_user = chain_user_json[str(chain)]
        if chain_user == 1:
            chain_no_user = 2
        elif chain_user == 2:
            chain_no_user = 1
        duel.cost_det = cost.id
        if cost_unwrap.cost_val == 5:
            if self.duel.is_ai is False:
                self.duel.ask = 3
                return False
            else:
                if duel.user_turn == 1:
                    self.duel.ask = 1
                    self.answer_ai(strategy,strategy_up_or_down)
                else:
                    self.duel.ask = 2
                    self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 3:
            cost_text = json.loads(cost_unwrap.cost)
            whether_monster = cost_text["whether_monster"]
            exclude = cost_text["exclude"]
            cost_text = cost_text["monster"][0]
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if self.check_monster_exists(
                        cost_text,
                        min,
                        max,
                        chain_user,
                        cost.cost_kind,
                        True,
                        whether_monster,
                        exclude,
                ):
                    if duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 4:
            cost_text = json.loads(cost_unwrap.cost)
            whether_monster = cost_text["whether_monster"]
            exclude = cost_text["exclude"]
            cost_text = cost_text["monster"][0]
            min = self.calculate_boland(cost_text["min_equation_number"], None,True,eternal=True)
            max = self.calculate_boland(cost_text["max_equation_number"], None,True,eternal=True)
            if min != 0 or max != 0:
                if self.check_monster_exists(
                        cost_text,
                        min,
                        max,
                        chain_no_user,
                        cost.cost_kind,
                        True,
                        whether_monster,
                        exclude,
                ):

                    if duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 27 or cost_unwrap.cost_val == 63:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 1:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)

        elif cost_unwrap.cost_val == 28 or cost_unwrap.cost_val == 64:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None,True)
            max = self.calculate_boland(cost_text["max_equation_number"], None,True)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 2:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 16:
            if duel.is_ai is False or chain_user == 1:
                if duel.user_turn == chain_user:
                    self.duel.ask = 1
                else:
                    self.duel.ask = 2
                return False
            else:
                self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 26:
            if duel.is_ai is False or chain_user == 2:
                if duel.user_turn == chain_user:
                    self.duel.ask = 2
                else:
                    self.duel.ask = 1
                return False
            else:
                self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 27 or cost_unwrap.cost_val == 63:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 1:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 28 or cost_unwrap.cost_val == 64:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None,True)
            max = self.calculate_boland(cost_text["max_equation_number"], None,True)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 2:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
        duel.cost_det = cost.id
        cost_next = self.invoke_cost(cost, chain)
        if cost_next == -4:
            return  -1
        while cost_next and cost_next != -2:
            pprint(cost_next)
            if cost_next == -1:
                return False
            else:
                cost_det = cost_next.id
                duel.cost_det = cost_det
                cost = cost_next
                cost_unwrap = cost.cost
                if cost_unwrap.cost_val == 5:
                    if self.duel.is_ai is False:
                        self.duel.ask = 3
                    else:
                        if duel.user_turn == 1:
                            self.duel.ask = 1
                            self.answer_ai(strategy,strategy_up_or_down)
                        else:
                            self.duel.ask = 2
                            self.answer_ai(strategy,strategy_up_or_down)
                    return False

                elif cost_unwrap.cost_val == 3:
                    cost_text = json.loads(cost_unwrap.cost)
                    whether_monster = cost_text["whether_monster"]
                    exclude = cost_text["exclude"]
                    cost_text = cost_text["monster"][0]
                    min = self.calculate_boland(cost_text["min_equation_number"], None)
                    max = self.calculate_boland(cost_text["max_equation_number"], None)
                    if min != 0 or max != 0:
                        if self.check_monster_exists(
                                cost_text,
                                min,
                                max,
                                chain_user,
                                cost.cost_kind,
                                True,
                                whether_monster,
                                exclude,
                        ):
                            if duel.is_ai is False or chain_user == 1:
                                if duel.user_turn == chain_user:
                                    self.duel.ask = 1
                                else:
                                    self.duel.ask = 2
                                return False
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 4:
                    cost_text = json.loads(cost_unwrap.cost)
                    whether_monster = cost_text["whether_monster"]
                    exclude = cost_text["exclude"]
                    cost_text = cost_text["monster"][0]
                    min = self.calculate_boland(cost_text["min_equation_number"], None,True,eternal=True)
                    max = self.calculate_boland(cost_text["max_equation_number"], None,True,eternal=True)
                    if self.check_monster_exists(
                            cost_text,
                            min,
                            max,
                            chain_no_user,
                            cost_unwrap.cost_kind,
                            cost.cost_kind,
                            True,
                            whether_monster,
                            exclude,
                    ):
                        if min != 0 or max != 0:
                            if duel.is_ai is False or chain_user == 2:
                                if duel.user_turn == chain_user:
                                    self.duel.ask = 2
                                else:
                                    self.duel.ask = 1
                                return False
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
                elif cost.unwrap.cost_val == 16:
                    if duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 26:
                    if duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 27 or cost_unwrap.cost_val == 63:
                    cost_text = json.loads(cost_unwrap.cost)
                    min = self.calculate_boland(cost_text["min_equation_number"], None)
                    max = self.calculate_boland(cost_text["max_equation_number"], None)
                    if min != 0 or max != 0:
                        if duel.is_ai is False or chain_user == 1:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 1
                            else:
                                self.duel.ask = 2
                            return False
                        else:
                            self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 28 or cost_unwrap.cost_val == 64:
                    cost_text = json.loads(cost_unwrap.cost)
                    min = self.calculate_boland(cost_text["min_equation_number"], None,True)
                    max = self.calculate_boland(cost_text["max_equation_number"], None,True)
                    if min != 0 or max != 0:
                        if duel.is_ai is False or chain_user == 2:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 2
                            else:
                                self.duel.ask = 1
                            return False
                        else:
                            self.answer_ai(strategy,strategy_up_or_down)
                cost_next = self.invoke_cost(cost, chain)
                if cost_next == -4:
                    return  -1
        self.end_cost(user,org_chain,trigger)
        if self.copying_flag >= 2:
            if trigger.chain_flag is True:
               self.duel.virtual_chain += 1
            self.duel.chain += 1
        return True
    def pay_cost(self, cost, user,org_chain, trigger,copy=0):
        self.in_execute = True
        duel = self.duel
        pprint(cost)
        if copy != 0:
            duel.in_copying = True
        in_copying_org = duel.in_copying
        if duel.in_copying is True:
            chain = duel.chain - 1
        else:
            chain = duel.chain
        self.tmp_chain = str(chain)
        if cost is None:
            self.change_once_per_turn()
            self.end_cost(user,org_chain,trigger,False,copy)
            if in_copying_org == 0 or self.copying_flag >= 2:
                if trigger.chain_flag is True:
                    self.duel.virtual_chain += 1
                self.duel.chain += 1
            return True
        strategy = cost.strategy
        strategy_up_or_down = cost.strategy_up_or_down
        cost_unwrap = cost.cost
        duel.in_cost = True
        while copy == 1 and cost_unwrap.effect_flag is False:
            if cost_unwrap.cost_val == 0:
                cost_condition = json.loads(cost_unwrap.cost_condition)
                duel.cost_log += self.write_log(cost.log, user)
                if self.check_cost_condition(cost_condition, cost.cost_kind):
                    if cost.pac:
                        cost_next = self._pac_cost(cost.pac)
                    else:
                        if cost.cost_next:
                            cost_next = cost.cost_next
                        else:
                            cost_next = self.pop_pac_cost(user)
                else:
                    if cost.pac2:
                        cost_next = self._pac_cost(cost.pac2)
                    else:
                        if cost.cost_next2:
                            cost_next = cost.cost_next2
                        else:
                            cost_next = self.pop_pac_cost2(user)
            else:
                if cost.pac:
                    cost_next = self._pac_cost(cost.pac)
                else:
                    if cost.cost_next:
                        cost_next = cost.cost_next
                    else:
                        cost_next = self.pop_pac_cost(user)
            pprint(cost_next)
            if not cost_next or cost_next == -2:
                self.end_cost(user,org_chain,trigger,Flase,copy)
                if in_copying_org == 0 or self.copying_flag >= 2:
                    if trigger.chain_flag is True:
                        self.duel.virtual_chain += 1
                    self.duel.chain += 1
            return True
        strategy = cost.strategy
        strategy_up_or_down = cost.strategy_up_or_down
        cost_unwrap = cost.cost
        duel.in_cost = True
        while copy == 1 and cost_unwrap.effect_flag is False:
            if cost_unwrap.cost_val == 0:
                cost_condition = json.loads(cost_unwrap.cost_condition)
                duel.cost_log += self.write_log(cost.log, user)
                if self.check_cost_condition(cost_condition, cost.cost_kind):
                    if cost.pac:
                        cost_next = self._pac_cost(cost.pac)
                    else:
                        if cost.cost_next:
                            cost_next = cost.cost_next
                        else:
                            cost_next = self.pop_pac_cost(user)
                else:
                    if cost.pac2:
                        cost_next = self._pac_cost(cost.pac2)
                    else:
                        if cost.cost_next2:
                            cost_next = cost.cost_next2
                        else:
                            cost_next = self.pop_pac_cost2(user)
            else:
                if cost.pac:
                    cost_next = self._pac_cost(cost.pac)
                else:
                    if cost.cost_next:
                        cost_next = cost.cost_next
                    else:
                        cost_next = self.pop_pac_cost(user)
            if not cost_next or cost_next == -2:
                self.end_cost(user,org_chain,trigger,Flase,copy)
                if in_copying_org == 0 or self.copying_flag >= 2:
                    if trigger.chain_flag is True:
                        self.duel.virtual_chain += 1
                    self.duel.chain += 1
                self.change_once_per_turn()
                return True
            cost = cost_next
            cost_unwrap = cost.cost

        chain_user_json = json.loads(self.duel.chain_user)
        chain_user = chain_user_json[str(chain)]
        if chain_user == 1:
            chain_no_user = 2
        elif chain_user == 2:
            chain_no_user = 1
        self.duel.cost_det = cost.id
        if cost_unwrap.cost_val == 5:
            if self.duel.is_ai is False:
                self.duel.ask = 3
            else:
                if duel.user_turn == 1:
                    self.duel.ask = 1
                    self.answer_ai(strategy,strategy_up_or_down)
                else:
                    self.duel.ask = 2
                    self.answer_ai(strategy,strategy_up_or_down)
            return False
        elif cost_unwrap.cost_val == 3:
            cost_text = json.loads(cost_unwrap.cost)
            whether_monster = cost_text["whether_monster"]
            exclude = cost_text["exclude"]
            cost_text = cost_text["monster"][0]
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if self.check_monster_exists(
                    cost_text,
                    min,
                    max,
                    chain_user,
                    cost.cost_kind,
                    True,
                    whether_monster,
                    exclude,
                ):
                    if duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
            else:
                self.invoke_flag = True
        elif cost_unwrap.cost_val == 4:
            cost_text = json.loads(cost_unwrap.cost)
            whether_monster = cost_text["whether_monster"]
            exclude = cost_text["exclude"]
            cost_text = cost_text["monster"][0]
            min = self.calculate_boland(cost_text["min_equation_number"], None,True,eternal=True)
            max = self.calculate_boland(cost_text["max_equation_number"], None,True,eternal=True)
            if min != 0 or max != 0:
                if self.check_monster_exists(
                    cost_text,
                    min,
                    max,
                    chain_no_user,
                    cost.cost_kind,
                    True,
                    whether_monster,
                    exclude,
                ):
                    if duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
            else:
                self.invoke_flag = True
        elif cost_unwrap.cost_val == 27 or cost_unwrap.cost_val == 63:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 1:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
            else:
                self.invoke_flag = True
        elif cost_unwrap.cost_val == 28 or cost_unwrap.cost_val == 64:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None, True)
            max = self.calculate_boland(cost_text["max_equation_number"], None, True)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 2:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
            else:
                self.invoke_flag = True
        elif cost_unwrap.cost_val == 16:
            if duel.is_ai is False or chain_user == 1:
                if duel.user_turn == chain_user:
                    self.duel.ask = 1
                else:
                    self.duel.ask = 2
                return False
            else:
                self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 26:
            if duel.is_ai is False or chain_user == 2:
                if duel.user_turn == chain_user:
                    self.duel.ask = 2
                else:
                    self.duel.ask = 1
                return False
            else:
                self.answer_ai(strategy,strategy_up_or_down)
        elif cost_unwrap.cost_val == 27 or cost_unwrap.cost_val == 63:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 1:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
            else:
                self.invoke_flag = True
        elif cost_unwrap.cost_val == 28 or cost_unwrap.cost_val == 64:
            cost_text = json.loads(cost_unwrap.cost)
            min = self.calculate_boland(cost_text["min_equation_number"], None)
            max = self.calculate_boland(cost_text["max_equation_number"], None)
            if min != 0 or max != 0:
                if duel.is_ai is False or chain_user == 2:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                    return False
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
            else:
                self.invoke_flag = True
        duel.cost_det = cost.id
        cost_next = self.invoke_cost(cost, chain)
        if cost_next == -4:
            return -1
        while cost_next and cost_next != -2 and cost_next != -3:
            pprint(cost_next)
            if cost_next == -1:
                return False
            else:
                cost_det = cost_next.id
                duel.cost_det = cost_det
                cost = cost_next
                cost_unwrap = cost.cost
                if copy == 1 and cost_unwrap.effect_flag is False:

                    if cost.pac:
                        cost_next = self._pac_cost(cost.pac)
                    else:
                        if cost.cost_next:
                            cost_next = cost.cost_next
                        else:
                            cost_next = self.pop_pac_cost(user)
                    continue

                if cost_unwrap.cost_val == 5:

                    if self.duel.is_ai is False:
                        self.duel.ask = 3
                    else:
                        if duel.user_turn == 1:
                            self.duel.ask = 1
                            self.answer_ai(strategy,strategy_up_or_down)
                        else:
                            self.duel.ask = 2
                            self.answer_ai(strategy,strategy_up_or_down)
                    return False
                elif cost_unwrap.cost_val == 3:
                    cost_text = json.loads(cost_unwrap.cost)
                    whether_monster = cost_text["whether_monster"]
                    exclude = cost_text["exclude"]
                    cost_text = cost_text["monster"][0]
                    min = self.calculate_boland(cost_text["min_equation_number"], None)
                    max = self.calculate_boland(cost_text["max_equation_number"], None)
                    if min != 0 or max != 0:
                        if self.check_monster_exists(
                            cost_text,
                            min,
                            max,
                            chain_user,
                            cost.cost_kind,
                            True,
                            whether_monster,
                            exclude,
                        ):
                            if duel.is_ai is False or chain_user == 1:
                                if duel.user_turn == chain_user:
                                    self.duel.ask = 1
                                else:
                                    self.duel.ask = 2
                                return False
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
                    else:
                        self.invoke_flag = True
                elif cost_unwrap.cost_val == 4:
                    cost_text = json.loads(cost_unwrap.cost)
                    whether_monster = cost_text["whether_monster"]
                    exclude = cost_text["exclude"]
                    cost_text = cost_text["monster"][0]
                    min = self.calculate_boland(cost_text["min_equation_number"], None,True,eternal=True)
                    max = self.calculate_boland(cost_text["max_equation_number"], None,True,eternal=True)
                    if self.check_monster_exists(
                        cost_text,
                        min,
                        max,
                        chain_no_user,
                        cost_unwrap.cost_kind,
                        cost.cost_kind,
                        True,
                        whether_monster,
                        exclude,
                    ):
                        if min != 0 or max != 0:
                            if duel.is_ai is False or chain_user == 2:
                                if duel.user_turn == chain_user:
                                    self.duel.ask = 2
                                else:
                                    self.duel.ask = 1
                                return False
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
                    else:
                        self.invoke_flag = True
                elif cost_unwrap.cost_val == 16:
                    if duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 26:
                    if duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
                        return False
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 27 or cost_unwrap.cost_val == 63:
                    cost_text = json.loads(cost_unwrap.cost)
                    min = self.calculate_boland(cost_text["min_equation_number"], None)
                    max = self.calculate_boland(cost_text["max_equation_number"], None)
                    if min != 0 or max != 0:
                        if duel.is_ai is False or chain_user == 1:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 1
                            else:
                                self.duel.ask = 2
                            return False
                        else:
                            self.answer_ai(strategy,strategy_up_or_down)
                elif cost_unwrap.cost_val == 28 or cost_unwrap.cost_val == 64:
                    cost_text = json.loads(cost_unwrap.cost)
                    min = self.calculate_boland(cost_text["min_equation_number"], None,True)
                    max = self.calculate_boland(cost_text["max_equation_number"], None,True)
                    if min != 0 or max != 0:
                        if duel.is_ai is False or chain_user == 2:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 2
                            else:
                                self.duel.ask = 1
                            return False
                        else:
                            self.answer_ai(strategy,strategy_up_or_down)
                    else:
                        self.invoke_flag = True
                cost_next = self.invoke_cost(cost, chain)
                if cost_next == -4:
                    return -1
        self.end_cost(user,org_chain,trigger)
        # -3はcopy_special_effectでコピーした時
        if (in_copying_org == 0 or self.copying_flag >=2) and cost_next != -3:
            if trigger.chain_flag is True:
               self.duel.virtual_chain += 1
            self.duel.chain += 1
        self.change_once_per_turn()
        return True
    def invoke_force_trigger(
            self,
            trigger,
            place,
            trigger_monster,
            mine_or_other,
            user,
            deck_id,
            x=0,
            y=0,
            monster_from=None,
            place_from=None,
            deck_id_from=None,
            from_x=None,
            from_y=None,
    ):
        duel = self.duel
        chain = duel.chain-1
        chain_user_json = {}
        if place != "":
            variable_mess = self.variable_mess
            variable_mess[str(chain)] = 0
            self.variable_mess = variable_mess
            tmp = self.mess
            tmp2 = {}
            tmp2["x"] = x
            tmp2["y"] = y
            tmp2["from_x"] = from_x
            tmp2["from_y"] = from_y
            tmp2["deck_id_from"] = deck_id_from
            tmp2["place_from"] = place_from
            if monster_from is not None:
                tmp2["place_unique_id_from"] = monster_from["place_unique_id"]
            else:
                tmp2["place_unique_id_from"] = None
            tmp2["det_from"] = monster_from
            tmp2["det"] = trigger_monster
            tmp2["place_unique_id"] = trigger_monster["place_unique_id"]
            tmp2["card_unique_id"] = trigger_monster["card_unique_id"]
            tmp2["mine_or_other"] = mine_or_other
            tmp2["user"] = user
            tmp2["place"] = place
            tmp2["deck_id"] = deck_id
            tmp[str(chain)] = {}
            tmp[str(chain)]["trigger"] = []
            tmp[str(chain)]["trigger"].append(tmp2)
            tmp[str(chain)]["trigger_org"] = []
            tmp[str(chain)]["trigger_org"].append(tmp2)
            if monster_from is not None:
                tmp_from = {}
                tmp_from["x"] = from_x
                tmp_from["y"] = from_y
                tmp_from["deck_id"] = deck_id_from
                tmp_from["place"] = place_from
                tmp_from["place_unique_id"] = monster_from["place_unique_id"]
                tmp_from["det"] = monster_from
                tmp[str(chain)]["trigger_from"] = []
                tmp[str(chain)]["trigger_from"].append(tmp2)
            tmp_cost = self.cost
            tmp_cost[str(chain)] = {}
            tmp_cost[str(chain)]["~trigger"] = []
            tmp_cost[str(chain)]["~trigger"].append(tmp2)
            tmp_cost[str(chain)]["~trigger_org"] = []
            tmp_cost[str(chain)]["~trigger_org"].append(tmp2)
            self.mess = tmp
            tmp_cost[str(chain)]["trigger_relate"] = []
            tmp_cost[str(chain)]["trigger_relate"].append(tmp2)
            tmp_cost[str(chain)]["trigger_org_relate"] = []
            tmp_cost[str(chain)]["trigger_org_relate"].append(tmp2)
            self.cost = tmp_cost
        else:
            variable_mess = self.variable_mess
            variable_mess[str(chain)] = 0
            self.variable_mess = variable_mess
            tmp = self.mess
            tmp[str(chain)] = {}
            self.mess = tmp
            tmp_cost = self.cost
            tmp_cost[str(chain)] = {}
            self.cost = tmp_cost
            tmp2 = None
        duel.ask = 0
        if self.duel.chain_user != "":
            chain_user_json = json.loads(self.duel.chain_user)
        chain_user_json[str(chain)] = user
        self.duel.chain_user = json.dumps(chain_user_json)

        if trigger.trigger_cost_pac is not None:
            cost = self._pac_cost(trigger.trigger_cost_pac)
        else:
            cost = trigger.trigger_cost
        self.duel.cost_user = user
        copied_cost = self.pay_cost_force(cost, user,duel.chain,trigger)
        chain_det_json = {}
        chain_det_trigger_json = {}
        if self.duel.chain_det != "":
            chain_det_json = json.loads(self.duel.chain_det)
        if self.duel.chain_det_trigger != "":
            chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
        if trigger.pac:
            effect = self._pac(trigger.pac)
        else:
            effect = trigger.next_effect
        if effect is not None:
            chain_det_json[str(chain)] = effect.id
        else:
            chain_det_json[str(chain)] = 0
        self.duel.chain_det = json.dumps(chain_det_json)
        self.duel.log_turn += self.write_log(trigger_monster["monster_name"]+"を使った",user)
        self.duel.log += self.write_log(trigger_monster["monster_name"]+"を使った",user)
        self.current_log += self.write_log(trigger_monster["monster_name"]+"を使った",user)
        return copied_cost
    def invoke_copy_trigger(
        self,
        trigger,
        place,
        trigger_monster,
        mine_or_other,
        user,
        deck_id,
        x=0,
        y=0,
        monster_from=None,
        place_from=None,
        deck_id_from=None,
        from_x=None,
        from_y=None,
    ):
        duel = self.duel
        org_chain = self.tmp_chain
        chain_user_json = {}
        if self.duel.chain_user != "":
            chain_user_json = json.loads(self.duel.chain_user)
        chain_user_json[str(org_chain)] = user
        self.duel.chain_user = json.dumps(chain_user_json)

        cost = trigger.trigger_cost
        self.duel.cost_user = user
        copied_cost = self.pay_cost_copy(cost, user,org_chaintrigger)
        chain_det_json = {}
        chain_det_trigger_json = {}
        if self.duel.chain_det != "":
            chain_det_json = json.loads(self.duel.chain_det)
        if self.duel.chain_det_trigger != "":
            chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
        if trigger.pac:
            effect = self._pac(trigger.pac)
        else:
            effect = trigger.next_effect
        if effect is not None:
            chain_det_json[str(org_chain)] = effect.id
        else:
            chain_det_json[str(org_chain)] = 0
        self.duel.chain_det = json.dumps(chain_det_json)
        duel.cost_det = copied_cost
        return copied_cost
    def invoke_trigger(
        self,
        trigger,
        place,
        trigger_monster,
        mine_or_other,
        user,
        deck_id,
        x=0,
        y=0,
        monster_from=None,
        place_from=None,
        deck_id_from=None,
        from_x=None,
        from_y=None,
        copy=0,
        null_relate=None,
        change_val=0,
        place_relate=None,
        monster_relate=None,
        mine_or_other_relate=None,
        deck_id_relate=None,
        x_relate=None,
        y_relate=None,
        move_from_relate=None,
        place_from_relate=None,
        deck_id_from_relate=None,
        from_x_relate=None,
        from_y_relate=None,
        place_exist=None,
        monster_exist=None,
        mine_or_other_exist=None,
        deck_id_exist=None,
        x_exist=None,
        y_exist=None,
        copy_flag = False,
        who=0,
        waiting = False
    ):
        if user == 1:
            other_user = 2
        else:
            other_user = 1
        if trigger.immidiate_flag is True:
            self.do_immidiate_trigger(trigger,user)
            return;
        self.duel.none = False
        duel = self.duel
        if copy == 0 or self.copying_flag >= 2:
            org_chain = duel.chain
        else:
            org_chain = duel.chain - 1
        chain_user_json = {}
        if self.duel.chain_user != "":
            chain_user_json = json.loads(self.duel.chain_user)
        chain_user_json[str(org_chain)] = user
        self.duel.chain_user = json.dumps(chain_user_json)
        if copy_flag == False:
            if  user == 1:
                self.duel.tmponce_per_turn1 = str(trigger.id) 
            else:
                self.duel.tmponce_per_turn2 = str(trigger.id) 
            if  user == 1:
                self.duel.tmponce_per_duel1 = str(trigger.id) 
            else:
                self.duel.tmponce_per_duel2 = str(trigger.id) 
            if trigger.once_per_turn_group != 0:
                if  user == 1:
                    self.duel.tmponce_per_turn_group1 = str(trigger.once_per_turn_group) 
                else:
                    self.duel.tmponce_per_turn_group2 = str(trigger.once_per_turn_group) 
        if place != "":
            if copy_flag == False:
                if user == 1:
                    self.duel.tmponce_per_turn_monster1 = str(trigger.id)+"*"+ trigger_monster["place_unique_id"]
                else:
                    self.duel.tmponce_per_turn_monster2 = str(trigger.id)+"*"+ trigger_monster["place_unique_id"]
                if trigger.once_per_turn_monster_group != 0:
                    if  user == 1:
                        self.duel.tmponce_per_turn_monster_group1 = str(trigger.once_per_turn_monster_group)+"*"+str( trigger_monster["place_unique_id"]) 
                    else:
                        self.duel.tmponce_per_turn_monster_group2 = str(trigger.once_per_turn_monster_group)+"*"+str(trigger_monster["place_unique_id"]) 

            variable_mess = self.variable_mess
            variable_mess[str(org_chain)] = change_val
            self.variable_mess = variable_mess
            tmp = self.mess
            tmp2 = {}
            tmp2["x"] = x
            tmp2["y"] = y
            tmp2["from_x"] = from_x
            tmp2["from_y"] = from_y
            tmp2["deck_id_from"] = deck_id_from
            tmp2["place_from"] = place_from
            if monster_from is not None:
                tmp2["place_unique_id_from"] = monster_from["place_unique_id"]
            else:
                tmp2["place_unique_id_from"] = None
            tmp2["det_from"] = monster_from
            tmp2["det"] = trigger_monster
            tmp2["place_unique_id"] = trigger_monster["place_unique_id"]
            tmp2["card_unique_id"] = trigger_monster["card_unique_id"]
            tmp2["mine_or_other"] = mine_or_other
            tmp2["user"] = user
            tmp2["place"] = place
            tmp2["deck_id"] = deck_id
            tmp[str(org_chain)] = {}
            tmp[str(org_chain)]["trigger"] = []
            tmp[str(org_chain)]["trigger"].append(tmp2)
            tmp[str(org_chain)]["trigger_org"] = []
            tmp[str(org_chain)]["trigger_org"].append(tmp2)
            if who == 0:
                tmp[str(org_chain)]["trigger_all"] = []
                tmp[str(org_chain)]["trigger_all"].append(tmp2)
            tmp_cost = self.cost
            tmp_cost[str(org_chain)] = {}
            tmp_cost[str(org_chain)]["~trigger"] = []
            tmp_cost[str(org_chain)]["~trigger"].append(tmp2)
            tmp_cost[str(org_chain)]["~trigger_org"] = []
            tmp_cost[str(org_chain)]["~trigger_org"].append(tmp2)
            if who == 0:
                tmp_cost[str(org_chain)]["~trigger_all"] = []
                tmp_cost[str(org_chain)]["~trigger_all"].append(tmp2)
            if monster_from is not None:
                tmp_from = {}
                tmp_from["x"] = from_x
                tmp_from["y"] = from_y
                tmp_from["deck_id"] = deck_id_from
                tmp_from["place"] = place_from
                tmp_from["place_unique_id"] = monster_from["place_unique_id"]
                tmp_from["det"] = monster_from
                tmp[str(org_chain)]["trigger_from"] = []
                tmp[str(org_chain)]["trigger_from"].append(tmp_from)
            if null_relate is not None:
                tmp[str(org_chain)]["null_relate"] = []
                tmp[str(org_chain)]["null_relate"].append(null_relate)
            if monster_relate is not None:
                '''
                if user == 1:
                    duel.tmponce_per_turn_relate1 = monster_relate["place_unique_id"]
                else:
                    duel.tmponce_per_turn_relate2 = monster_relate["place_unique_id"]
                '''
                tmp2 = {}
                tmp2["x"] = x_relate
                tmp2["y"] = y_relate
                tmp2["from_x"] = from_x_relate
                tmp2["from_y"] = from_y_relate
                tmp2["deck_id_from"] = deck_id_from_relate
                tmp2["place_from"] = place_from_relate
                if move_from_relate is not None:
                    tmp2["place_unique_id_from"] = move_from_relate["det"][
                        "place_unique_id"
                    ]
                else:
                    tmp2["place_unique_id_from"] = None
                tmp2["det_from"] = move_from_relate
                tmp2["det"] = monster_relate
                tmp2["place_unique_id"] = monster_relate["place_unique_id"]
                tmp2["card_unique_id"] = monster_relate["card_unique_id"]
                tmp2["mine_or_other"] = mine_or_other_relate
                tmp2["user"] = user
                tmp2["place"] = place_relate
                tmp2["deck_id"] = deck_id_relate
                tmp[str(org_chain)]["trigger_relate"] = []
                tmp[str(org_chain)]["trigger_relate"].append(tmp2)
                tmp[str(org_chain)]["trigger_org_relate"] = []
                tmp[str(org_chain)]["trigger_org_relate"].append(tmp2)
                tmp_cost[str(org_chain)]["~trigger_relate"] = []
                tmp_cost[str(org_chain)]["~trigger_relate"].append(tmp2)
                tmp_cost[str(org_chain)]["~trigger_org_relate"] = []
                tmp_cost[str(org_chain)]["~trigger_org_relate"].append(tmp2)
                if who == 2:
                    tmp_cost[str(org_chain)]["~trigger_all"] = []
                    tmp_cost[str(org_chain)]["~trigger_all"].append(tmp2)
                    tmp[str(org_chain)]["trigger_all"] = []
                    tmp[str(org_chain)]["trigger_all"].append(tmp2)
            if monster_exist is not None:
                '''
                if user == 1:
                    duel.tmponce_per_turn_exist1 = monster_exist["place_unique_id"]
                else:
                    duel.tmponce_per_turn_exist2 = monster_exist["place_unique_id"]
                '''
                tmp2["x"] = x_exist
                tmp2["y"] = y_exist
                tmp2["det"] = monster_exist
                tmp2["place_unique_id"] = monster_exist["place_unique_id"]
                tmp2["card_unique_id"] = monster_exist["card_unique_id"]
                tmp2["mine_or_other"] = mine_or_other_exist
                tmp2["user"] = user
                tmp2["place"] = place_exist
                tmp2["deck_id"] = deck_id_exist
                tmp[str(org_chain)]["trigger_exist"] = []
                tmp[str(org_chain)]["trigger_exist"].append(tmp2)
                tmp[str(org_chain)]["trigger_org_exist"] = []
                tmp[str(org_chain)]["trigger_org_exist"].append(tmp2)
                tmp_cost[str(org_chain)]["trigger_exist"] = []
                tmp_cost[str(org_chain)]["trigger_exist"].append(tmp2)
                tmp_cost[str(org_chain)]["trigger_org_exist"] = []
                tmp_cost[str(org_chain)]["trigger_org_exist"].append(tmp2)
                if who == 1:
                    tmp_cost[str(org_chain)]["~trigger_all"] = []
                    tmp_cost[str(org_chain)]["~trigger_all"].append(tmp2)
                    tmp[str(org_chain)]["trigger_all"] = []
                    tmp[str(org_chain)]["trigger_all"].append(tmp2)
            self.mess = tmp
            self.cost = tmp_cost
        else:
            variable_mess = self.variable_mess
            variable_mess[str(org_chain)] = change_val
            self.variable_mess = variable_mess
            tmp = self.mess
            tmp[str(org_chain)] = {}
            if null_relate is not None:
                tmp[str(org_chain)]["null_relate"] = []
                tmp[str(org_chain)]["null_relate"].append(null_relate)
            self.mess = tmp
            tmp_cost = self.cost
            tmp_cost[str(org_chain)] = {}
            self.cost = tmp_cost
            tmp2 = None
        data = {}
        data["monsters"] = []
        data["monsters"].append(tmp2)
        self.duel.trigger_log = self.write_log(trigger.log, user, data)

        flag = True
        if trigger.trigger_cost_pac is not None:
            cost = self._pac_cost(trigger.trigger_cost_pac)
        else:
            cost = trigger.trigger_cost
        self.duel.cost_user = user
        flag =  self.pay_cost(cost, user,org_chain, trigger,copy) 
        if flag == -1:
            return  -1
        chain_det_json = {}
        chain_det_trigger = {}
        if self.duel.chain_det != "":
            chain_det_json = json.loads(self.duel.chain_det)
        if self.duel.chain_det_trigger != "":
            chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
        if trigger.pac:
            effect = self._pac(trigger.pac, org_chain)
        else:
            effect = trigger.next_effect
        if effect is not None:
            chain_det_json[str(org_chain)] = effect.id
        else:
            chain_det_json[str(org_chain)] = 0
        self.duel.chain_det = json.dumps(chain_det_json)
        '''
        if copy == 0:
            self.duel.canbechained = trigger.canbechained
        else:
            self.duel.canbechained = False
        '''
        if flag:
            if duel.appoint == other_user:
                duel.appoint = user
            else:
                duel.appoint = other_user

        return flag

    def check_trigger(self, decks, graves, hands, phase, turn, user, other_user,force_flag=0):
        duel = self.duel
        force_count = 0
        return_value = []
        if duel.canbechained is False:
            return_value.append(None)
            if duel.current_priority > 1:
                return_value.append(1)
            else:
                return_value.append(0)
            return return_value
        available_trigger = []
        triggers = Trigger.objects.filter(Q(phase__isnull=True) | Q(phase=phase))
        if duel.is_ai is False:
            triggers = triggers.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            triggers = triggers.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        triggers = triggers.filter(
            Q(chain__isnull=True)
            | (Q(chain_kind=0) & Q(chain__lte=duel.virtual_chain))
            | (Q(chain_kind=1) & Q(chain__gte=duel.virtual_chain))
            | (Q(chain_kind=2) & Q(chain=duel.virtual_chain))
        )
        if duel.timing is not None:
            triggers = triggers.filter(Q(timing=duel.timing))
        else:
            triggers = triggers.filter(Q(none_timing=True))

        if duel.timing2 is not None:
            triggers = triggers.filter(Q(timing2=duel.timing2))
        else:
            triggers = triggers.filter(Q(none_timing2=True))
        if duel.timing3 is not None:
            triggers = triggers.filter(Q(timing3=duel.timing3))
        else:
            triggers = triggers.filter(Q(none_timing3=True))
        triggers = triggers.filter(priority__lt=duel.current_priority)
        triggers = triggers.filter(trigger_timing=False)
        #if user == duel.user_turn:
        #    triggers = triggers.filter(Q(turn=0) | Q(turn=1))
        #else:
        #    triggers = triggers.filter(Q(turn=0) | Q(turn=2))
        if duel.is_ai is True:
            if user == 1:
                triggers = triggers.filter(Q(enemy_own = 0) |  Q(enemy_own = 1))
            else:
                triggers = triggers.filter(Q(enemy_own = 1) |  Q(enemy_own = 2))
        else:
            triggers = triggers.filter(Q(enemy_own = 0) |  Q(enemy_own = 1))
        triggers = triggers.order_by("-priority").all()
        pprint(triggers)
        trigger_first = triggers.first()
        if trigger_first is None:
            if force_flag == 1:
                return 0
            return_value.append(None)
            return_value.append(0)
            return_value.append(0)
            return return_value
        priority = trigger_first.priority
        none_triggers = triggers.filter(priority=priority, trigger_none_monster=True)
        for trigger in none_triggers:
            if not self.check_launch_trigger( trigger, self.duel.phase, self.duel.user_turn, user, other_user, user):
                continue
            if self.check_trigger_condition(trigger, user):
                tmp = {}
                if force_flag == 2:
                        self.invoke_trigger(
                            trigger, "", "", "", self.duel.user_turn, "",who=0
                        )
                        return
                if trigger.force >= 1 or (duel.is_ai is True and user == 2):
                    tmp["force"] = True
                    force_count+=1
                else:
                    tmp["force"] = False
                tmp["sentence"] = trigger.trigger_sentence
                tmp["id"] = trigger.id
                available_trigger.append(tmp)
        if force_flag == 1:
            return force_count
        trigger_monster = self.check_monster_trigger(
            decks, graves, hands, user, other_user, priority,1
        )
        trigger_num = trigger_monster[0]
        force_count += trigger_monster[1]

        self.update = True
        self.trigger_waiting_for_ai = []
        if len(available_trigger) > 1 and (self.duel.is_ai is False or user == 1):
            return_value.append(available_trigger)
            return_value.append(priority)
            return_value.append(force_count)
            return return_value
        elif len(available_trigger) > 1 and (self.duel.is_ai is True and user == 2):
            flag = False
            for a in available_trigger:
                # if a["force"] is True or (user == 2 and duel.is_ai is True):
                flag = True
                force_trigger = Trigger.objects.get(id=a["id"])
                if force_trigger.timing_trigger:
                    return_value.append(
                        self.invoke_trigger(
                            force_trigger, "", "", "", self.duel.user_turn, "",who=0
                        )
                    )
                else:
                    trigger_waitings = json.loads(duel.trigger_waiting)
                    tmp = {}
                    tmp["monster"] = ""
                    tmp["move_from"] = None
                    tmp["trigger"] = force_trigger.id
                    tmp["priority"] = force_trigger.priority
                    tmp["storategy_priority"] = force_trigger.storategy_priority
                    tmp["mine_or_other"] = user
                    tmp["user"] = user
                    tmp["place"] = ""
                    tmp["deck_id"] = ""
                    tmp["place_from"] = ""
                    tmp["deck_id_from"] = ""
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["from_x"] = 0
                    tmp["from_y"] = 0
                    tmp["strategy_value"] = 0
                    trigger_waitings.append(tmp)
                    duel.trigger_waiting = json.dumps(trigger_waitings)
                    duel.in_trigger_waiting = True
                    duel.in_cost_force = True
            if flag is True:
               return_value.append(True)
            else:
                return_value.append(None)
            return_value.append(priority)
            return_value.append(force_count)
            return return_value
                
            self.update = True
        elif len(available_trigger) == 1 and trigger_num is False:
            if available_trigger[0]["force"] is True or (user == 2 and duel.is_ai is True):

                force_trigger = Trigger.objects.get(id=available_trigger[0]["id"])
                if force_trigger.timing_trigger:
                    return_value.append(
                        self.invoke_trigger(
                            force_trigger, "", "", "", self.duel.user_turn, "",who=0
                        )
                    )
                else:
                    trigger_waitings = json.loads(duel.trigger_waiting)
                    tmp = {}
                    tmp["monster"] = ""
                    tmp["move_from"] = None
                    tmp["trigger"] = force_trigger.id
                    tmp["priority"] = force_trigger.priority
                    tmp["storategy_priority"] = force_trigger.storategy_priority
                    tmp["mine_or_other"] = user
                    tmp["user"] = user
                    tmp["place"] = ""
                    tmp["deck_id"] = ""
                    tmp["place_from"] = ""
                    tmp["deck_id_from"] = ""
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["from_x"] = 0
                    tmp["from_y"] = 0
                    tmp["strategy_value"] = 0
                    if not self.check_launch_trigger(force_trigger, self.duel.phase, self.duel.user_turn, user, other_user,
                                                     user):
                        return_value.append(None)
                        return_value.append(priority)
                        return_value.append(0)
                        return return_value
                    trigger_waitings.append(tmp)
                    duel.trigger_waiting = json.dumps(trigger_waitings)
                    duel.in_trigger_waiting = True
                    duel.in_cost_force = True
                    #return_value.append(True)
                self.update = True
                return_value.append(available_trigger)
                return_value.append(priority)
                return_value.append(force_count)
                return return_value
            else:
                return_value.append(available_trigger)
                return_value.append(priority)
                return_value.append(force_count)
                return return_value
        elif len(available_trigger) == 1 and trigger_num is True:
            if available_trigger[0]["force"] is True or (user == 2 and duel.is_ai is True):
                force_trigger = Trigger.objects.get(id=available_trigger[0]["id"])
                if force_trigger.timing_trigger:
                    return_value.append(
                        self.invoke_trigger(
                            force_trigger, "", "", "", self.duel.user_turn, "",who=0
                        )
                    )
                else:
                    trigger_waitings = json.loads(duel.trigger_waiting)
                    tmp = {}
                    tmp["monster"] = ""
                    tmp["move_from"] = None
                    tmp["trigger"] = force_trigger.id
                    tmp["priority"] = force_trigger.priority
                    tmp["storategy_priority"] = force_trigger.storategy_priority
                    tmp["mine_or_other"] = user
                    tmp["user"] = user
                    tmp["place"] = ""
                    tmp["deck_id"] = ""
                    tmp["place_from"] = ""
                    tmp["deck_id_from"] = ""
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["from_x"] = 0
                    tmp["from_y"] = 0
                    tmp["strategy_value"] = 0
                    if not self.check_launch_trigger(force_trigger, self.duel.phase, self.duel.user_turn, user, other_user,
                                                     user):
                        return_value.append(None)
                        return_value.append(priority)
                        return_value.append(0)
                        return return_value
                    trigger_waitings.append(tmp)
                    duel.trigger_waiting = json.dumps(trigger_waitings)
                    duel.in_trigger_waiting = True
                    duel.in_cost_force = True
                    return_value.append(True)
                self.update = True
                return_value.append(priority)
                if duel.appoint == 2 and duel.is_ai == True and duel.trigger_force != "[]":
                    self.invoke_trigger_waiting(None,0,2)
                return return_value
            return_value.append(available_trigger)
            return_value.append(priority)
            return_value.append(force_count)
            return return_value

        elif len(available_trigger) == 0 and trigger_num is False:
            return_value.append(None)
            return_value.append(priority)
            return_value.append(0)
            return return_value
        else:
            return_value.append("monster_trigger")
            return_value.append(priority)
            return_value.append(force_count)
            if duel.appoint == 2 and duel.is_ai is True:
                self.invoke_trigger_waiting(None,0,2)
            return return_value
        return return_value

    def check_monster_trigger(self, decks, graves, hands, user, other_user, priority,mode2 = 0):
        flag = False
        return_value = {}
        force_count = 0
        deck_info = self.get_deck_info(decks, user, other_user)
        return_value["deck_info"] = copy.deepcopy(deck_info)
        tmp =  self.modify_deck_info(
            return_value["deck_info"], self.count_deck(decks), user, other_user, priority, 1,mode2
        )
        if tmp[0] is True:
            flag =  True
        force_count += tmp[1]
        grave_info = self.get_grave_info(graves, user, other_user)
        return_value["grave_info"] = copy.deepcopy(grave_info)

        tmp = self.modify_grave_info(
                return_value["grave_info"], graves.count(), user, other_user, priority, 1,mode2
        )
        if tmp[0] is True:
            flag =  True
        force_count += tmp[1]
        hand_info = self.get_hand_info(hands, user, other_user)
        return_value["hand_info"] = copy.deepcopy(hand_info)

        tmp = self.modify_hand_info(
            return_value["hand_info"], hands.count(), user, other_user, priority, 1,mode2
        )
        if tmp[0] is True:
            flag =  True
        force_count += tmp[1]
        field = copy.deepcopy(self.field)
        tmp =  self.modify_field_info(field, user, other_user, priority, 1)
        if tmp[0] is True:
            flag =  True
        force_count += tmp[1]
        return [flag,force_count]

    def init_all(self, user, other_user, room_number,mode=0):
        self.trigger_waiting_for_ai = False
        self.turn_changed = False
        self.tmp_val = {}
        self.init_deck_info(user, other_user, room_number)
        self.init_grave_info(user, other_user, room_number)
        self.init_hand_info(user, other_user, room_number)
        self.init_virtual_variable(user, other_user, room_number)
        self.triggers = {}
        self.copying_flag = 0
        duel = self.duel
        if hasattr(self,"sound_effect"):
                pass
        else:
            self.sound_effect = ""
        #pprint(self.effect)
        self.effect = duel.effect
        self.effect2 = duel.effect2
        '''
        if(duel.change_turn_flag is True):
        else:
            if user == 1:
                self.effect = "&"
                self.effect2 = duel.effect2
            else:
                self.effect = duel.effect
                self.effect2 = "&"
        '''
        # ターン変動ではないがデックトリガの時必要
        if mode == 1:
            duel.change_turn_flag = True
        else:
            duel.change_turn_flag = False
        self.log_initial = duel.current_log
        self.current_log = ""
        self.in_execute = duel.in_execute
        self.field = json.loads(duel.field)
        self.mess = json.loads(duel.mess)
        self.variable_mess = json.loads(duel.variable_mess)
        self.cost = json.loads(duel.cost)
        self.cost_result = json.loads(duel.cost_result)
        self.timing_mess = json.loads(duel.timing_mess)
        self.config = Config.objects.get()
        self.field_free = self.config.field_free
        limit_time = self.config.limit_time
        time_win = self.config.time_win
        self.tmp_chain = 0
        self.acc_global = json.loads(duel.accumulate_global)
        if user == duel.appoint or (duel.user_turn == other_user and duel.ask == 2) or (duel.user_turn == 1 and duel.ask ==1) or duel.ask == 3:
            if user == 1:
                if time() - duel.time_1 > limit_time:
                    duel.log_turn += self.write_log(time_win, other_user)
                    duel.log += self.write_log(time_win, other_user)
                    self.current_log += self.write_log(time_win, other_user)
                    self.lose_the_game_by_time()
            else:
                if time() - duel.time_2 > limit_time:
                    duel.log_turn += self.write_log(time_win, other_user)
                    duel.log += self.write_log(time_win, other_user)
                    self.current_log += self.write_log(time_win, other_user)
                    self.lose_the_game_by_time()
        else:
            if user == 1:
                if time() - duel.time_1 > limit_time:
                    duel.log_turn += self.write_log(time_win, user)
                    duel.log += self.write_log(time_win, user)
                    self.current_log += self.write_log(time_win, user)
                    self.win_the_game_by_time()
            else:
                if time() - duel.time_2 > limit_time:
                    duel.log_turn += self.write_log(time_win, user)
                    duel.log += self.write_log(time_win, user)
                    self.current_log += self.write_log(time_win, user)
                    self.win_the_game_by_time()
        

    def save_all(self, user, other_user, room_number):
        duel = self.duel
        game_name = self.config.game_name
        pwd = os.path.dirname(__file__)
        if user == 1:
            duel.effect = "&" 
            duel.effect2 = self.effect2
        else:
            duel.effect = self.effect
            duel.effect2 = "&"

        if duel.cost_det is None:
            duel.cost_det = 0
        if self.config.cheat is True or self.config.detail_log is True or (self.turn_changed is True and self.config.initial_turn_log is True):
            self.log = open(pwd + "/logger_" + game_name, mode="a", encoding="utf-8")
            if(self.turn_changed is True):
                if  self.duel.user_turn == 1:
                    self.log2 = open(pwd + "/logger2_" + game_name, mode="w", encoding="utf-8")
                else:
                    self.log2 = open(pwd + "/logger3_" + game_name, mode="w", encoding="utf-8")
            self.log.write("-----------------------\n")
        self.save_deck_info(user, other_user, room_number)
        self.save_grave_info(user, other_user, room_number)
        self.save_hand_info(user, other_user, room_number)
        if self.current_log != "":
            duel.current_log = self.current_log
        duel.log_turn = duel.log_turn
        duel.log = duel.log
        duel.variable_mess = json.dumps(self.variable_mess)
        duel.mess = json.dumps(self.mess)
        duel.cost = json.dumps(self.cost)
        duel.cost_result = json.dumps(self.cost_result)
        duel.timing_mess = json.dumps(self.timing_mess)
        duel.field = json.dumps(self.field)
        duel.in_execute = self.in_execute
        duel.accumulate_global = json.dumps(self.acc_global)
        reset_queries()
        duel.time_1 = time()
        duel.time_2 = time()
        duel.save()
        if self.config.cheat is True or self.config.detail_log is True or (self.turn_changed is True and self.config.initial_turn_log is True):
            self.log_write()
            self.log.close()

    def log_write(self):
        if self.config.detail_log is True or (self.turn_changed is True and self.config.initial_turn_log is True):
            for history in connection.queries:
                self.log.write(history["sql"] + ";\n")
        if self.config.cheat is True and self.turn_changed is True :
            for history in connection.queries:
                self.log2.write(history["sql"] + ";\n")
        reset_queries()

        return

    def save_deck_info(self, user, other_user, room_number):
        decks = self.deck_structure
        i = 0
        for deck in decks:
            if deck.mine_or_other == 1:
                tmp = DuelDeck.objects.filter(
                    room_number=room_number, mine_or_other=3, deck_id=i + 1
                ).first()
                if tmp is None:
                    continue
                tmp.deck_content = json.dumps(self.decks[i + 1]["commondeck"])
                reset_queries()
                tmp.save()
                self.log_write()
            else:
                tmp = DuelDeck.objects.filter(
                    room_number=room_number, mine_or_other=user, deck_id=i + 1
                ).first()
                if tmp is None:
                    continue
                tmp.deck_content = json.dumps(self.decks[i + 1]["mydeck"])
                reset_queries()
                tmp.save()
                self.log_write()
                tmp = DuelDeck.objects.filter(
                    room_number=room_number, mine_or_other=other_user, deck_id=i + 1
                ).first()
                if tmp is None:
                    continue
                tmp.deck_content = json.dumps(self.decks[i + 1]["otherdeck"])
                reset_queries()
                tmp.save()
                self.log_write()
            i += 1

    def save_grave_info(self, user, other_user, room_number):
        graves = self.grave_structure
        i = 0
        for grave in graves:
            if grave.mine_or_other == 1:
                tmp = DuelGrave.objects.filter(
                    room_number=room_number, mine_or_other=3, grave_id=i + 1
                ).first()
                tmp.grave_content = json.dumps(self.graves[i + 1]["commongrave"])
                reset_queries()
                tmp.save()
                self.log_write()
            else:
                tmp = DuelGrave.objects.filter(
                    room_number=room_number, mine_or_other=user, grave_id=i + 1
                ).first()
                tmp.grave_content = json.dumps(self.graves[i + 1]["mygrave"])
                reset_queries()
                tmp.save()
                self.log_write()
                tmp = DuelGrave.objects.filter(
                    room_number=room_number, mine_or_other=other_user, grave_id=i + 1
                ).first()
                tmp.grave_content = json.dumps(self.graves[i + 1]["othergrave"])
                reset_queries()
                tmp.save()
                self.log_write()
            i += 1

    def save_hand_info(self, user, other_user, room_number):
        hands = self.hand_structure
        i = 0
        for hand in hands:
            if hand.mine_or_other == 1:
                tmp = DuelHand.objects.filter(
                    room_number=room_number, mine_or_other=3, hand_id=i + 1
                ).first()
                tmp.hand_content = json.dumps(self.hands[i + 1]["commonhand"])
                reset_queries()
                tmp.save()
                self.log_write()
            else:
                tmp = DuelHand.objects.filter(
                    room_number=room_number, mine_or_other=user, hand_id=i + 1
                ).first()
                tmp.hand_content = json.dumps(self.hands[i + 1]["myhand"])
                reset_queries()
                tmp.save()
                self.log_write()
                tmp = DuelHand.objects.filter(
                    room_number=room_number, mine_or_other=other_user, hand_id=i + 1
                ).first()
                tmp.hand_content = json.dumps(self.hands[i + 1]["otherhand"])
                reset_queries()
                tmp.save()
                self.log_write()
            i += 1

    def init_virtual_variable(self, user, other_user, room_number):
        virtual_variables = VirtualVariable.objects.all()
        result_virtual_variables = {}
        for virtual_variable in virtual_variables:
            tmp = {}
            tmp["variable_name"] = virtual_variable.variable_name
            tmp["priority"] = virtual_variable.priority
            tmp["1_show"] = virtual_variable.show
            tmp["2_show"] = virtual_variable.show
            tmp["mine_or_other"] = virtual_variable.mine_or_other
            if virtual_variable.mine_or_other == 0:
                if self.user == 1:
                    tmp["1_value"] = self.calculate_boland(virtual_variable.value,user=1)
                    tmp["2_value"] = self.calculate_boland(
                        virtual_variable.value, None, True,user=1
                    )
                else:
                    tmp["1_value"] = self.calculate_boland(
                        virtual_variable.value, None, True,user = 2
                    )
                    tmp["2_value"] = self.calculate_boland(virtual_variable.value, None,user=2)
            else:
                tmp["value"] = self.calculate_boland(virtual_variable.value)
            result_virtual_variables[virtual_variable.variable_name] = tmp
        self.virtual_variables = result_virtual_variables

    def init_deck_info(self, user, other_user, room_number):
        self.deck_structure = Deck.objects.all()
        decks = self.deck_structure

        i = 0
        result_decks = []
        result_decks.append(None)
        for deck in decks:
            result_decks.append({})
            result_decks[i + 1]["deck_name"] = deck.deck_name
            if deck.mine_or_other == 1:
                tmp = DuelDeck.objects.filter(
                    room_number=room_number, mine_or_other=3, deck_id=i + 1
                ).first()
                result_decks[i + 1]["deck_name"] = tmp.deck_name
                if tmp is not None:
                    tmp = json.loads(tmp.deck_content)
                    result_decks[i + 1]["commondeck"] = tmp
                else:
                    result_decks[i + 1]["commondeck"] = []
            else:
                tmp = DuelDeck.objects.filter(
                    room_number=room_number, mine_or_other=user, deck_id=i + 1
                ).first()
                result_decks[i + 1]["deck_name"] = tmp.deck_name
                if tmp is not None:
                    tmp = json.loads(tmp.deck_content)
                    result_decks[i + 1]["mydeck"] = tmp
                else:
                    result_decks[i + 1]["mydeck"] = []
                tmp = DuelDeck.objects.filter(
                    room_number=room_number, mine_or_other=other_user, deck_id=i + 1
                ).first()
                result_decks[i + 1]["deck_name"] = tmp.deck_name
                if tmp is not None:
                    tmp = json.loads(tmp.deck_content)
                    result_decks[i + 1]["otherdeck"] = tmp
                else:
                    result_decks[i + 1]["otherdeck"] = []
            i += 1

        self.decks = result_decks

    def init_grave_info(self, user, other_user, room_number):
        self.grave_structure = Grave.objects.all()
        graves = self.grave_structure
        result_graves = []
        result_graves.append(None)
        i = 0
        for grave in graves:
            result_graves.append({})
            result_graves[i + 1]["grave_name"] = grave.grave_name
            if grave.mine_or_other == 1:
                tmp = DuelGrave.objects.filter(
                    room_number=room_number, mine_or_other=3, grave_id=i + 1
                ).first()
                result_graves[i + 1]["deck_name"] = tmp.grave_name
                tmp = json.loads(tmp.grave_content)
                result_graves[i + 1]["commongrave"] = tmp
            else:
                tmp = DuelGrave.objects.filter(
                    room_number=room_number, mine_or_other=user, grave_id=i + 1
                ).first()
                result_graves[i + 1]["deck_name"] = tmp.grave_name
                tmp = json.loads(tmp.grave_content)
                result_graves[i + 1]["mygrave"] = tmp
                tmp = DuelGrave.objects.filter(
                    room_number=room_number, mine_or_other=other_user, grave_id=i + 1
                ).first()
                tmp = json.loads(tmp.grave_content)
                result_graves[i + 1]["othergrave"] = tmp
            i += 1

        self.graves = result_graves

    def init_hand_info(self, user, other_user, room_number):
        self.hand_structure = Hand.objects.all()
        hands = self.hand_structure
        result_hands = []
        result_hands.append(None)
        i = 0
        for hand in hands:
            result_hands.append({})
            result_hands[i + 1]["hand_name"] = hand.hand_name
            if hand.mine_or_other == 1:
                tmp = DuelHand.objects.filter(
                    room_number=room_number, mine_or_other=3, hand_id=i + 1
                ).first()
                result_hands[i + 1]["deck_name"] = tmp.hand_name
                tmp = json.loads(tmp.grave_content)
                tmp = json.loads(tmp.hand_content)
                result_hands[i + 1]["commonhand"] = tmp
            else:
                tmp = DuelHand.objects.filter(
                    room_number=room_number, mine_or_other=user, hand_id=i + 1
                ).first()
                result_hands[i + 1]["deck_name"] = tmp.hand_name
                tmp = json.loads(tmp.hand_content)
                result_hands[i + 1]["myhand"] = tmp
                tmp = DuelHand.objects.filter(
                    room_number=room_number, mine_or_other=other_user, hand_id=i + 1
                ).first()
                tmp = json.loads(tmp.hand_content)
                result_hands[i + 1]["otherhand"] = tmp
            i += 1

        self.hands = result_hands

    def get_grave_with_effect(
        self,
        user_decks,
        effect_det,
        effect_kind,
        exclude,
        user,
        place,
        deck_id,
        x,
        y,
        mine_or_other,
        cost,
    ):
        return self.get_deck_with_effect(
            user_decks,
            effect_det,
            effect_kind,
            exclude,
            user,
            place,
            deck_id,
            x,
            y,
            mine_or_other,
            cost,
        )

    def get_hand_with_effect(
        self,
        user_decks,
        effect_det,
        effect_kind,
        exclude,
        user,
        place,
        deck_id,
        x,
        y,
        mine_or_other,
        cost,
    ):
        return self.get_deck_with_effect(
            user_decks,
            effect_det,
            effect_kind,
            exclude,
            user,
            place,
            deck_id,
            x,
            y,
            mine_or_other,
            cost,
        )

    def get_deck_with_effect(
        self,
        user_decks,
        effect_det,
        effect_kind,
        exclude,
        user,
        place,
        deck_id,
        x,
        y,
        mine_or_other,
        cost_flag,
    ):
        duel = self.duel
        return_deck = []
        cost = self.cost
        mess = self.mess
        if duel.in_cost is True:
            if str(self.tmp_chain) in cost:
                cost = cost[str(self.tmp_chain)]
            else:
                cost = []
        else:
            if str(duel.chain - 1) in cost:
                cost = cost[str(duel.chain - 1)]
            else:
                cost = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        timing_mess = self.timing_mess
        for index in range(len(user_decks)):
            monster = user_decks[index]
            effect_flag = False
            if effect_kind != "":
                if self.check_no_choose(
                    user_decks[index],
                    user,
                    effect_kind,
                    place,
                    deck_id,
                    x,
                    y,
                    mine_or_other,
                    cost_flag,
                ):
                    effect_flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:
                    if exclude_det[0] == "~":
                        if exclude_det in cost:
                            for cost_det in cost[exclude_det]:
                                if (
                                    user_decks[index]["place_unique_id"]
                                    == cost_det["det"]["place_unique_id"]
                                ):
                                    effect_flag = True
                                    continue
                    if exclude_det[0] == "%":
                        if exclude_det in timing_mess:
                            for timing_det in timing_mess[exclude_det]:
                                if (
                                    user_decks[index]["place_unique_id"]
                                    == timing_det["det"]["place_unique_id"]
                                ):
                                    effect_flag = True
                                    continue
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if (
                                user_decks[index]["place_unique_id"]
                                == mess_det["det"]["place_unique_id"]
                            ):
                                effect_flag = True
                                continue

            current_and_or = "and"
            monster_name_kind = effect_det["monster"]["monster_name_kind"]
            monster_names = self.check_change_name(user_decks[index], user, place, deck_id, x, y, -1)
            name_flag = True
            if (
                "monster_effect" in effect_det["monster"]
                and effect_det["monster"]["monster_effect"] != 0 and effect_det["monster"]["monster_effect"] != "0"
            ):
                id = self.get_monster_id(
                    user_decks[index],
                    place,
                    user_decks[index]["owner"],
                    deck_id,
                    0,
                    0,
                    mine_or_other,
                )
                if str(effect_det["monster"]["monster_effect"]) != "":
                    monster_effect_monster_ary = str(effect_det["monster"]["monster_effect"]).split("_")
                    monster_effect_flag = False
                    for monster_effect_monster in monster_effect_monster_ary:
                        if monster_effect_monster[0] == "!":
                            if id == int(monster_effect_monster[1:]):
                                return False
                        elif id == int(monster_effect_monster):
                            monster_effect_flag = True
                            break
                    if monster_effect_flag is False:
                        continue
            name_flag = True
            if len(monster_name_kind) != 1 or monster_name_kind[0]["operator"] != "":
                for name_kind in monster_name_kind:
                    if name_kind != "":
                        name_flag2 = False
                        for monster_name in monster_names:
                            if name_kind["operator"] == "=":
                                if monster_name == self.get_name(
                                    name_kind["monster_name"], 0, user_decks[index]
                                ):
                                    name_flag2 = True
                                    break
                            elif name_kind["operator"] == "!=":
                                if monster_name != self.get_name(
                                    name_kind["monster_name"], 0, user_decks[index]
                                ):
                                    name_flag2 = True
                                    break
                            elif name_kind["operator"] == "like":
                                if (
                                    monster_name.find(
                                        self.get_name(
                                            name_kind["monster_name"], 0, user_decks[index]
                                        )
                                    )
                                    == -1
                                ):
                                     name_flag2 = True
                                     break
                            elif name_kind["operator"] == "notlike":
                                if (
                                    user_decks[index]["monster_name"].find(
                                        self.get_name(
                                            name_kind["monster_name"], 0, user_decks[index]
                                        )
                                    )
                                    != -1
                                ):
                                    name_flag2 = True
                                    break
                        if current_and_or == "and":
                            if name_flag is True:
                                name_flag = name_flag2
                        else:
                            if name_flag is False:
                                name_flag = name_flag2
                        current_and_or = name_kind["and_or"]
            if name_flag is False:
                continue
            check_flag = effect_det["monster"]["flag"]
            if check_flag is not None and check_flag != "":
                if check_flag["operator"] == "=":
                    if user_decks[index]["flag"] != int(check_flag["flag_det"]):
                        continue
                elif check_flag["operator"] == "&":
                    if user_decks[index]["flag"] & int(check_flag["flag_det"]) == 0:
                        continue
                elif check_flag["operator"] == "^":
                    if user_decks[index]["flag"] & int(check_flag["flag_det"]) != 0:
                        continue
            monster_condition_val = effect_det["monster"]["monster_condition"]
            if monster_condition_val:
                for cond_det in monster_condition_val:
                    cond_flag = True
                    current_and_or = "and"
                    tmp_flag = True

                    for cond_val in cond_det:
                        if not cond_val:
                            continue
                        name = self.check_swap_val(
                            monster,
                            mine_or_other,
                            place,
                            deck_id,
                            x,
                            y,
                            cond_val["name"],
                            mine_or_other,
                        )
                        name2 = self.check_swap_init_val(
                            monster,
                            mine_or_other,
                            place,
                            deck_id,
                            x,
                            y,
                            cond_val["name"],
                            mine_or_other,
                        )
                        tmp = user_decks[index]["variables"][cond_val["name"]]
                        if not tmp["value"].isnumeric():
                            value = tmp["value"]
                        else:
                            if cond_val["init"] == 0:
                                value = int(tmp["value"])
                                value = self.check_change_val(
                                    monster,
                                    mine_or_other,
                                    place,
                                    deck_id,
                                    x,
                                    y,
                                    name,
                                    mine_or_other,
                                    value
                                )
                            elif cond_val["init"] == 1:
                                tmp = user_decks[index]["variables"][name2]
                                value = int(tmp["i_val"])
                            elif cond_val["init"] == 2:
                                value = int(tmp["i_i_val"])
                        if cond_val["operator"] == "=" or cond_val["operator"] == "":
                            if str(float(value)) != str(self.calculate_boland(
                                cond_val["num"], None
                            )):
                                tmp_flag = False
                        elif cond_val["operator"] == "<=":
                            if str(value) > str(self.calculate_boland(
                                cond_val["num"], None
                            )):
                                tmp_flag = False
                        elif cond_val["operator"] == ">=":
                            if str(value) < str(self.calculate_boland(
                                cond_val["num"], None
                            )):
                                tmp_flag = False
                        elif cond_val["operator"] == "!=":
                            if str(value) == str(self.calculate_boland(
                                cond_val["num"], None
                            )):
                                tmp_flag = False
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag

                        else:
                            if cond_flag is False:
                                cond_flag = tmp_flag

                if cond_flag is False:
                    continue
            if effect_flag is False:
                return_deck.append(index)
        return return_deck

    def count_deck(self,decks):
        i = 0
        for deck in decks:
            if deck.show != 5:
                i += 1
        return i
    def get_deck_info(self, decks, user, other_user, mode=0):
        dueldeck = self.decks
        return_value = []

        i = 0
        j= 0
        for deck in decks:
            if deck.show == 5:
                i += 1
                continue
            return_value.append({})
            return_value[j]["deck_name"] = deck.deck_name
            return_value[j]["eternal"] = deck.eternal
            return_value[j]["invoke"] = deck.invoke
            return_value[j]["id"] = deck.id
            if deck.mine_or_other == 1:
                tmp = dueldeck[i + 1]["commondeck"]
                if mode == 1:
                    if deck.show >= 1:
                        return_value[j]["commondeck"] = tmp
                else:
                    return_value[j]["commondeck"] = tmp
                return_value[j]["commondecknum"] = len(tmp)
            else:
                tmp = dueldeck[i + 1]["mydeck"]
                return_value[j]["mydecknum"] = len(tmp)
                if mode == 1:
                    if deck.show >= 1:
                        return_value[j]["mydeck"] = tmp
                else:
                    return_value[j]["mydeck"] = tmp
                tmp = dueldeck[i + 1]["otherdeck"]
                return_value[j]["otherdecknum"] = len(tmp)
                if mode == 1:
                    if deck.show >= 2:
                        return_value[j]["otherdeck"] = tmp
                else:
                    return_value[j]["otherdeck"] = tmp
            i += 1
            j += 1
        return return_value

    def get_grave_info(self, graves, user, other_user, mode=0):
        duelgrave = self.graves
        return_value = []

        i = 0
        for grave in graves:
            return_value.append({})
            return_value[i]["grave_name"] = grave.grave_name
            return_value[i]["eternal"] = grave.eternal
            return_value[i]["invoke"] = grave.invoke
            return_value[i]["id"] = grave.id
            if grave.mine_or_other == 1:
                tmp = duelgrave[i + 1]["commongrave"]
                if mode == 1:
                    if grave.show >= 1:
                        return_value[i]["commongrave"] = tmp
                else:
                    return_value[i]["commongrave"] = tmp
                return_value[i]["commongravenum"] = len(tmp)
            else:
                tmp = duelgrave[i + 1]["mygrave"]
                return_value[i]["mygravenum"] = len(tmp)
                if mode == 1:
                    if grave.show >= 1:
                        return_value[i]["mygrave"] = tmp
                else:
                    return_value[i]["mygrave"] = tmp
                tmp = duelgrave[i + 1]["othergrave"]
                return_value[i]["othergravenum"] = len(tmp)
                if mode == 1:
                    if grave.show >= 2:
                        return_value[i]["othergrave"] = tmp
                else:
                    return_value[i]["othergrave"] = tmp
            i += 1
        return return_value

    def watch_hand(self, hands):
        return self.get_hand_info(hands, 0, 0, mode=2)

    def get_hand_info(self, hands, user, other_user, mode=0):
        duelhand = self.hands
        return_value = []

        i = 0
        for hand in hands:
            return_value.append({})
            return_value[i]["hand_name"] = hand.hand_name
            return_value[i]["eternal"] = hand.eternal
            return_value[i]["invoke"] = hand.invoke
            return_value[i]["id"] = hand.id
            return_value[i]["show"] = hand.show
            if hand.mine_or_other == 1:
                tmp = duelhand[i + 1]["commonhand"]
                if mode == 1 or mode == 2 or mode == 3:
                    if hand.show >= 1 and hand.show != 5:
                        return_value[i]["commonhand"] = tmp
                else:
                    return_value[i]["commonhand"] = tmp
                return_value[i]["commonhandnum"] = len(tmp)
            else:
                tmp = duelhand[i + 1]["myhand"]
                return_value[i]["myhandnum"] = len(tmp)
                if mode == 1 or mode == 3:
                    if hand.show >= 1 and hand.show != 5:
                        return_value[i]["myhand"] = tmp
                elif mode == 2:
                    if hand.show == 2 or hand.show != 5:
                        return_value[i]["myhand"] = tmp
                else:
                    return_value[i]["myhand"] = tmp
                tmp = duelhand[i + 1]["otherhand"]
                return_value[i]["otherhandnum"] = len(tmp)
                if mode == 1 or mode == 2:
                    if hand.show == 2 and hand.show != 5:
                        return_value[i]["otherhand"] = tmp
                    else:
                        if (hand.show == 3 or hand.show == 4) and mode != 3:
                            return_value[i]["otherhand"] = []
                            for val  in tmp:
                                show = self.check_change_val(val, user, "hand", i+1, 0, 0, "show", 2,int(val["variables"]["show"]["value"]) )
                                if(show == 1):
                                    return_value[i]["otherhand"].append(val)
                                else:
                                    tmp_monster = {}
                                    tmp_monster["id"] = 0
                                    tmp_relate = {}
                                    tmp_relate["monster"] = tmp_monster
                                    tmp_relate["det"] = tmp_monster
                                    tmp_relate["place_unique_id"] = -1
                                    tmp_relate["card_unique_id"] = -1
                                    tmp_relate["mine_or_other"] = other_user
                                    tmp_relate["user"] = other_user
                                    tmp_relate["place"] = "hand"
                                    tmp_relate["deck_id"] = i +1
                                    tmp_relate["x"] = 0
                                    tmp_relate["y"] = 0
                                    return_value[i]["otherhand"].append(tmp_relate)
                else:
                    return_value[i]["otherhand"] = tmp
            i += 1
        return return_value

    def invoke_eternal_effect_det(self, eternal, effect_user):
        duel = self.duel
        eternal_effect = eternal["eternal"]
        turn = eternal_effect.turn
        if(eternal_effect.eternal_effect_val == 8 or eternal_effect.eternal_effect_val == 9):
            name_flag = True
        else:
            name_flag = False

        if turn != 0:
            if effect_user == 1:
                if (
                    duel.user_turn == 1
                    and turn == 1
                    or duel.user_turn == 2
                    and turn == 2
                ):
                    pass
                else:
                    return
            elif effect_user == 2:
                if (
                    duel.user_turn == 2
                    and turn == 1
                    or duel.user_turn == 1
                    and turn == 2
                ):
                    pass
                else:
                    return
        if duel.timing is not None:
            if duel.timing not in eternal_effect.timing.all():
                return False
        elif eternal_effect.none_timing is False:
            return False
        if duel.timing2 is not None:
            if duel.timing2 not in eternal_effect.timing2.all():
                return False
        elif eternal_effect.none_timing2 is False:
            return False
        if duel.timing3 is not None:
            if duel.timing3 not in eternal_effect.timing3.all():
                return False
        elif eternal_effect.none_timing3 is False:
            return False
        if eternal_effect.eternal_effect_condition != "":
            eternal_condition = json.loads(eternal_effect.eternal_effect_condition)
            if (
                self.check_monster_condition(
                    eternal_condition["monster"],
                    effect_user,
                    False,
                    None,
                    [],
                    0,
                    eternal_effect.eternal_kind,
                    name_flag = name_flag
                )
                is False
            ):
                return

        if (eternal_effect.invalid_monster) != "":
            invalid_monsters = json.loads(eternal_effect.invalid_monster)
        else:
            invalid_monsters = ""
        val = eternal_effect.eternal_effect_val
        val2 = eternal_effect.eternal_effect_val2
        ignore = eternal_effect.ignore
        val_name = eternal_effect.val_name
        change_val = eternal_effect.value
        global_id = eternal_effect.eternal_global_variable
        effect_kinds = eternal_effect.eternal_kind
        invalid_kinds = eternal_effect.invalid_eternal_kind
        tmp_val = eternal_effect.eternal_tmp_val
        cost_or_effect = eternal_effect.cost_or_effect
        mine_or_other_effect = eternal_effect.mine_or_other_effect
        if eternal_effect.eternal_monster != "":
            eternal_monsters = json.loads(eternal_effect.eternal_monster)
            eternal_monster = eternal_monsters["monster"][0]
            eternal_monster_place_ary = eternal_monsters["monster"][0]["monster"]["place"]
                
        else:
            if "place_unique_id" in eternal:
                place_unique_id = eternal["place_unique_id"]
            else:
                place_unique_id = None
            if val == 0:
                if val2 == 0 or val2 == 2 or val2 == 4:
                    self.no_eternal_effect(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val2 == 1 or val2 == 2 or val2 == 4:
                    self.invoke_invalid_effect(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val2 == 3:
                    self.not_effected_effect(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
            if val == 1:
                self.change_variable_effect(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    val_name,
                    change_val,
                    tmp_val,
                    mine_or_other_effect,
                )
            if val == 2 or (val == 0 and val2 == 4):
                self.no_invoke_effect(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    tmp_val,
                    mine_or_other_effect,
                )
            if val == 3:
                self.no_choose_effect(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    tmp_val,
                    cost_or_effect,
                    mine_or_other_effect,
                )
            if val == 4:
                self.change_destination_effect(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    val_name,
                    change_val,
                    tmp_val,
                    mine_or_other_effect,
                )
            if val == 5:
                self.swap_variable_effect(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    val_name,
                    change_val,
                    tmp_val,
                    mine_or_other_effect,
                )
            elif val == 8:
                self.swap_init_variable_effect(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    val_name,
                    change_val,
                    tmp_val,
                    mine_or_other_effect,
                )
            if val == 6:
                if ignore == 1:
                    self.check_chain(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 2:
                    self.check_chain_user(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 3:
                    self.check_chain_kind(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        eternal_effect.ignore_effect_kind,
                        mine_or_other_effect,
                    )
                elif ignore == 4:
                    self.check_same_chain(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 5:
                    self.check_same_monster_chain(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 6:
                    self.check_same_monster_exist_chain(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 7:
                    self.check_eternal_phase(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        eternal_effect.ignore_phase.all(),
                        mine_or_other_effect,
                    )
                elif ignore == 8:
                    self.check_eternal_mine_or_other(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 9:
                    self.check_eternal_no_invoke(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 10:
                    self.check_eternal_timing(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        eternal_effect.ignore_timing.all(),
                        mine_or_other_effect,
                    )
                elif ignore == 11:
                    self.check_eternal_monster_place(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 12:
                    self.check_eternal_monster_place_condition(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 13:
                    self.check_eternal_turn(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 14:
                    self.check_eternal_monster_condition(
                        eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
                    )
                elif ignore == 15:
                    self.check_eternal_monster_variable(
                        eternal,
                        invalid_kinds,
                        place_unique_id,
                        global_id,
                        eternal_effect.ignore_variable,
                        mine_or_other_effect,
                    )
            elif val == 7:
                self.take_variable_instead_func(
                    eternal,
                    invalid_kinds,
                    place_unique_id,
                    global_id,
                    val_name,
                    change_val,
                    tmp_val,
                    cost_or_effect,
                    mine_or_other_effect,
                )

            return
        if invalid_monsters != "":
            invalid_monster = invalid_monsters["monster"][0]["monster"]
        else:
            invalid_monster = ""
        persist = eternal_effect.persist
        eternal["persist"] = persist
        eternal["invalid_kinds"] = invalid_kinds
        for eternal_monster_place in eternal_monster_place_ary:
                
            eternal_places = eternal_monster_place["det"].split("_")
            if (effect_user == 1 and int(eternal_places[2]) == 1) or (
                effect_user == 2 and int(eternal_places[2]) == 2
            ):
                mine_or_other4 = 1
            elif (
                effect_user == 2
                and int(eternal_places[2]) == 1
                or (effect_user == 2 and int(eternal_places[2]) == 1)
            ):
                mine_or_other4 = 2
            else:
                mine_or_other4 = 3
            eternal["mine_or_other"] = mine_or_other4
            if eternal["place"] == "" or eternal["place"] is None:
                flag = True
                det = {}
                det["place_unique_id"] = ""
            elif eternal["place"] != eternal_places[0]:
                continue
            elif eternal["place"] == "field":
                fields = self.field
                x = int(eternal["x"])
                y = int(eternal["y"])
                mine_or_other = int(fields[x][y]["mine_or_other"])
                kind = fields[x][y]["kind"]
                tmp = kind.split("_")
                if mine_or_other != mine_or_other4 or eternal_places[1] not in tmp:
                    continue
                else:
                    det = fields[x][y]["det"]
                    if det is None:
                        continue
                    tmp2 = {}
                    tmp2["det"] = fields[x][y]["det"]
                    tmp2["mine_or_other"] = fields[x][y]["mine_or_other"]
                    tmp2["user"] = effect_user
                    tmp2["place"] = "field"
                    tmp2["deck_id"] = 0
                    tmp2["x"] = x
                    tmp2["y"] = y
                    tmp2["place_unique_id"] = fields[x][y]["det"]["place_unique_id"]
                    if not self.check_monster_condition_det(
                            eternal_monster, fields[x][y]["det"], effect_user
                    ):
                        continue

                    eternal["place_unique_id"] = det["place_unique_id"]
                    eternal["relate_monster"] = []
                    eternal["mine_or_other"] = fields[x][y]["mine_or_other"]
                    if (
                        invalid_monster != ""
                        and len(invalid_monster["relation"]) != 0
                        and "rel" in det
                    ):
                        for index in range(len(invalid_monster["relation"])):
                            relation_kind = invalid_monster["relation_kind"][index]
                            relation_to = int(invalid_monster["relation_to"][index])
                            relation = invalid_monster["relation"][index]
                            if relation_kind in det["rel"]:
                                for relation_det in det["rel"][relation_kind]:
                                    if (
                                        relation_det["name"] == relation
                                        and int(relation_det["to"]) == relation_to
                                    ):
                                        eternal["relate_monster"].append(relation_det)
                    if not self.check_eternal_invalid(
                        det,
                        effect_user,
                        effect_kinds,
                        "field",
                        0,
                        x,
                        y,
                        fields[x][y]["mine_or_other"],
                    ):
                        fields[x][y]["det"]["already"] = 1
                        flag = True
                        self.field = fields
                    else:
                        fields[x][y]["det"]["already"] = 0
                        flag = False
                        self.field = fields
            elif eternal["place"] == "deck":
                deck_id = int(eternal["deck_id"])
                mine_or_other = eternal["mine_or_other"]
                if (self.user == 1 and mine_or_other == 1) or (
                    self.user == 2 and mine_or_other == 2
                ):
                    mine_or_other2 = 1
                elif (self.user == 2 and mine_or_other == 1) or (
                    self.user == 1 and mine_or_other == 2
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3
                if mine_or_other4 != mine_or_other or deck_id != int(eternal_places[1]):
                    continue
                else:
                    if mine_or_other2 == 1:
                        decks = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        decks = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        decks = self.decks[deck_id]["commondeck"]
                    if "index" in eternal:
                        i = eternal["index"]
                    else:
                        i = -1
                        for deck_i in range(len(decks)):
                            if (
                                decks[deck_i]["place_unique_id"]
                                == eternal["place_unique_id"]
                            ):
                                if not self.check_monster_condition_det(
                                    eternal_monster, decks[deck_i], effect_user
                                ):
                                    break
                                i = deck_i
                                break
                        if i == -1:
                            continue
                    det = decks[i]
                    tmp2 = {}
                    tmp2["det"] = decks[i]
                    tmp2["mine_or_other"] = mine_or_other
                    tmp2["user"] = effect_user
                    tmp2["place"] = "deck"
                    tmp2["deck_id"] = deck_id
                    tmp2["x"] = 0
                    tmp2["y"] = 0
                    tmp2["place_unique_id"] = decks[i]["place_unique_id"]
                    eternal["place_unique_id"] = decks[i]["place_unique_id"]
                    if (
                        invalid_monster != ""
                        and len(invalid_monster["relation"]) != 0
                        and "rel" in det
                    ):
                        for index in range(len(invalid_monster["relation"])):
                            relation_kind = invalid_monster["relation_kind"][index]
                            relation_to = invalid_monster["relation_to"][index]
                            relation = invalid_monster["relation"][index]
                            if relation_kind in det["rel"]:
                                for relation_det in det["rel"][relation_kind]:
                                    if (
                                        relation_det["name"] == relation
                                        and relation_det["to"] == relation_to
                                    ):
                                        eternal["relate_monster"].append(
                                            det["rel"][relation_kind]
                                        )
                    if not self.check_eternal_invalid(
                        decks[i],
                        effect_user,
                        effect_kinds,
                        "deck",
                        deck_id,
                        0,
                        0,
                        mine_or_other2,
                    ):
                        decks[i]["already"] = 1
                        flag = True
                    else:
                        flag = False
                        decks[i]["already"] = 0
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = decks
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = decks
                    elif mine_or_other2 == 3:
                        self.decks[deck_id]["commondeck"] = decks
            elif eternal["place"] == "grave":
                deck_id = int(eternal["deck_id"])
                mine_or_other = eternal["mine_or_other"]
                if (self.user == 1 and mine_or_other == 1) or (
                    self.user == 2 and mine_or_other == 2
                ):
                    mine_or_other2 = 1
                elif (self.user == 2 and mine_or_other == 1) or (
                    self.user == 1 and mine_or_other == 2
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3
                if mine_or_other4 != mine_or_other or deck_id != int(eternal_places[1]):
                    continue
                else:
                    if mine_or_other2 == 1:
                        graves = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        graves = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        graves = self.graves[deck_id]["commongrave"]
                    if "index" in eternal:
                        i = eternal["index"]
                    else:
                        i = -1
                        for grave_i in range(len(graves)):
                            if (
                                graves[grave_i]["place_unique_id"]
                                == eternal["place_unique_id"]
                            ):
                                if not self.check_monster_condition_det(
                                    eternal_monster, graves[grave_i], effect_user
                                ):
                                    break
                                i = grave_i
                                break
                        if i == -1:
                            continue
                    det = graves[i]
                    tmp2 = {}
                    tmp2["det"] = det
                    tmp2["mine_or_other"] = mine_or_other
                    tmp2["user"] = effect_user
                    tmp2["place"] = "grave"
                    tmp2["deck_id"] = deck_id
                    tmp2["x"] = 0
                    tmp2["y"] = 0
                    tmp2["place_unique_id"] = det["place_unique_id"]
                    eternal["place_unique_id"] = det["place_unique_id"]
                    if (
                        invalid_monster != ""
                        and len(invalid_monster["relation"]) != 0
                        and "rel" in det
                    ):
                        for index in range(len(invalid_monster["relation"])):
                            relation_kind = invalid_monster["relation_kind"][index]
                            relation_to = invalid_monster["relation_to"][index]
                            relation = invalid_monster["relation"][index]
                            if relation_kind in det["rel"]:
                                for relation_det in det["rel"][relation_kind]:
                                    if (
                                        relation_det["name"] == relation
                                        and relation_det["to"] == relation_to
                                    ):
                                        eternal["relate_monster"].append(
                                            det["rel"][relation_kind]
                                        )
                    if not self.check_eternal_invalid(
                        graves[i],
                        effect_user,
                        effect_kinds,
                        "grave",
                        deck_id,
                        0,
                        0,
                        mine_or_other2,
                    ):
                        graves[i]["already"] = 1
                        flag = True
                    else:
                        flag = False
                        graves[i]["already"] = 0
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = graves
            elif eternal["place"] == "hand":
                deck_id = int(eternal["deck_id"])
                mine_or_other = eternal["mine_or_other"]
                if (self.user == 1 and mine_or_other == 1) or (
                    self.user == 2 and mine_or_other == 2
                ):
                    mine_or_other2 = 1
                elif (self.user == 2 and mine_or_other == 1) or (
                    self.user == 1 and mine_or_other == 2
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3

                if mine_or_other4 != mine_or_other or deck_id != int(eternal_places[1]):
                    continue
                else:
                    if mine_or_other2 == 1:
                        hands = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        hands = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        hands = self.hands[deck_id]["commonhand"]
                    if "index" in eternal:
                        i = eternal["index"]
                    else:
                        i = -1
                        for hand_i in range(len(hands)):
                            if (
                                hands[hand_i]["place_unique_id"]
                                == eternal["place_unique_id"]
                            ):
                                if not self.check_monster_condition_det(
                                    eternal_monster, hands[hand_i], effect_user
                                ):
                                    break
                                i = hand_i
                                break
                    if i != -1:
                        det = hands[i]
                        tmp2 = {}
                        tmp2["det"] = det
                        tmp2["mine_or_other"] = mine_or_other
                        tmp2["user"] = effect_user
                        tmp2["place"] = "hand"
                        tmp2["deck_id"] = deck_id
                        tmp2["x"] = 0
                        tmp2["y"] = 0
                        tmp2["place_unique_id"] = det["place_unique_id"]
                        eternal["place_unique_id"] = det["place_unique_id"]
                    else:
                        continue
                    if (
                        invalid_monster != ""
                        and len(invalid_monster["relation"]) != 0
                        and "rel" in det
                    ):
                        eternal["relate_monster"] = []
                        for index in range(len(invalid_monster["relation"])):
                            relation_kind = invalid_monster["relation_kind"][index]
                            relation_to = invalid_monster["relation_to"][index]
                            relation = invalid_monster["relation"][index]
                            if relation_kind in det["rel"]:
                                for relation_det in det["rel"][relation_kind]:
                                    if (
                                        relation_det["name"] == relation
                                        and relation_det["to"] == relation_to
                                    ):
                                        eternal["relate_monster"].append(
                                            det["rel"][relation_kind]
                                        )
                    if not self.check_eternal_invalid(
                        hands[i],
                        effect_user,
                        effect_kinds,
                        "hand",
                        deck_id,
                        0,
                        0,
                        mine_or_other2,
                    ):
                        hands[i]["already"] = 1
                        flag = True
                    else:
                        flag = False
                        hands[i]["already"] = 0
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = hands
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = hands
                    elif mine_or_other2 == 3:
                        self.hands[deck_id]["commonhand"] = hands
            if tmp_val != "" and val != 8 and val != 9:
                tmp_val = self.calculate_boland(tmp_val, tmp2)
            if flag is True:
                if val == 0:
                    if val2 == 0 or val2 == 2 or val2 == 4:
                        self.no_eternal_effect(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            tmp_val,
                            mine_or_other_effect,
                        )
                    if val2 == 1 or val2 == 2 or val2 == 4:
                        self.invoke_invalid_effect(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            tmp_val,
                            mine_or_other_effect,
                        )
                    if val2 == 3:
                        self.not_effected_effect(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            tmp_val,
                            cost_or_effect,
                            mine_or_other_effect,
                        )
                if val == 1:
                    self.change_variable_effect(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 2 or (val == 0 and val2 == 4):
                    self.no_invoke_effect(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 3:
                    self.no_choose_effect(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
                if val == 4:
                    self.change_destination_effect(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 5:
                    self.swap_variable_effect(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 8:
                    self.swap_init_variable_effect(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 6:
                    if ignore == 1:
                        self.check_chain(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 2:
                        self.check_chain_user(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 3:
                        self.check_chain_kind(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_effect_kind,
                            mine_or_other_effect,
                        )
                    elif ignore == 4:
                        self.check_same_chain(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 5:
                        self.check_same_monster_chain(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 6:
                        self.check_same_monster_exist_chain(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 7:
                        self.check_eternal_phase(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_phase.all(),
                            mine_or_other_effect,
                        )
                    elif ignore == 8:
                        self.check_eternal_mine_or_other(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 9:
                        self.check_eternal_no_invoke(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 10:
                        self.check_eternal_timing(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_timing.all(),
                            mine_or_other_effect,
                        )
                    elif ignore == 11:
                        self.check_eternal_monster_place(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 12:
                        self.check_eternal_monster_place_condition(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 13:
                        self.check_eternal_turn(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 14:
                        self.check_eternal_monster_condition(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 15:
                        self.check_eternal_monster_variable(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_variable,
                            mine_or_other_effect,
                        )
                elif val == 7:
                    self.take_variable_instead_func(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
                elif val == 8:
                    self.change_name_func(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
                elif val == 9:
                    self.change_name_add_func(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
            else:
                if val == 0:
                    if val2 == 0 or val2 == 2 or val2 == 4:
                        self.no_eternal_effect_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            tmp_val,
                            mine_or_other_effect,
                        )
                    if val2 == 1 or val2 == 2 or val2 == 4:
                        self.invoke_invalid_effect_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            tmp_val,
                            mine_or_other_effect,
                        )
                    if val2 == 3:
                        self.not_effected_effect_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            tmp_val,
                            cost_or_effect,
                            mine_or_other_effect,
                        )
                if val == 1:
                    self.change_variable_effect_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 2 or (val == 0 and val2 == 4):
                    self.no_invoke_effect_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 3:
                    self.no_choose_effect_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
                if val == 4:
                    self.change_destination_effect_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 5:
                    self.swap_variable_effect_remove(
                        eternal,
                        invalid_kinds,
                        None,
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                elif val == 8:
                    self.swap_init_variable_effect_remove(
                        eternal,
                        invalid_kinds,
                        None,
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        mine_or_other_effect,
                    )
                if val == 6:
                    if ignore == 1:
                        self.check_chain_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                            mine_or_other_effect,
                        )
                    elif ignore == 2:
                        self.check_chain_user_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 3:
                        self.check_chain_kind_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_effect_kind,
                            mine_or_other_effect,
                        )
                    elif ignore == 4:
                        self.check_same_chain_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 5:
                        self.check_same_monster_chain_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 6:
                        self.check_same_monster_exist_chain_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 7:
                        self.check_eternal_phase_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_phase.all(),
                            mine_or_other_effect,
                        )
                    elif ignore == 8:
                        self.check_eternal_mine_or_other_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 9:
                        self.check_eternal_no_invoke_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 10:
                        self.check_eternal_timing_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_timing.all(),
                            mine_or_other_effect,
                        )
                    elif ignore == 11:
                        self.check_eternal_monster_place_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 12:
                        self.check_eternal_monster_place_condition_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 13:
                        self.check_eternal_turn_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 14:
                        self.check_eternal_monster_condition_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            mine_or_other_effect,
                        )
                    elif ignore == 15:
                        self.check_eternal_monster_variable_remove(
                            eternal,
                            invalid_kinds,
                            det["place_unique_id"],
                            global_id,
                            eternal_effect.ignore_variable,
                            mine_or_other_effect,
                        )
                if val == 7:
                    self.take_variable_instead_func_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
                elif val == 8:
                    self.change_name_func_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
                elif val == 9:
                    self.change_name_add_func_remove(
                        eternal,
                        invalid_kinds,
                        det["place_unique_id"],
                        global_id,
                        val_name,
                        change_val,
                        tmp_val,
                        cost_or_effect,
                        mine_or_other_effect,
                    )
        return

    def no_choose_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["cost_or_effect"] = cost_or_effect
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.no_choose_eternal_effect:
            self.no_choose_eternal_effect.remove(eternal)

    def no_choose_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["cost_or_effect"] = cost_or_effect
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.no_choose_eternal_effect:
            self.no_choose_eternal_effect.append(eternal)

    def change_variable_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        if eternal in self.change_val_eternal_effect:
            self.change_val_eternal_effect.remove(eternal)

    def check_eternal_monster_variable(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        ignore_variable,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["ignore_variable"] = ignore_variable
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_monster_variable:
            self.check_monster_variable.append(eternal)

    def check_eternal_monster_variable_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        ignore_variable,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["ignore_variable"] = ignore_variable
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_monster_variable:
            self.check_monster_variable.remove(eternal)

    def check_eternal_monster_condition(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_monster_condition_list:
            self.check_monster_condition_list.append(eternal)

    def check_eternal_monster_condition_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_monster_condition_list:
            self.check_monster_condition_list.remove(eternal)

    def check_eternal_turn(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_turn:
            self.check_turn.append(eternal)

    def check_eternal_turn_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_turn:
            self.check_turn.remove(eternal)

    def check_eternal_monster_place_condition(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_monster_place_condition:
            self.check_monster_place_condition.append(eternal)

    def check_eternal_monster_place(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_monster_place_condition:
            self.check_monster_place_condition.append(eternal)

    def check_eternal_monster_place_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_monster_place_condition:
            self.check_monster_place_condition.remove(eternal)

    def check_eternal_timing(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        timings,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["timings"] = timings
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_timing:
            self.check_ignore_timing.append(eternal)

    def check_eternal_timing_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        timings,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["timings"] = timings
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_timing:
            self.check_ignore_timing.remove(eternal)

    def check_eternal_no_invoke(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_no_invoke:
            self.check_ignore_no_invoke.append(eternal)

    def check_eternal_no_invoke_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_no_invoke:
            self.check_ignore_no_invoke.remove(eternal)

    def check_eternal_mine_or_other(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_mine_or_other:
            self.check_ignore_mine_or_other.append(eternal)

    def check_eternal_mine_or_other_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_mine_or_other:
            self.check_ignore_mine_or_other.remove(eternal)

    def check_eternal_phase(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        phases,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["phases"] = phases
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_phase:
            self.check_ignore_phase.append(eternal)

    def check_eternal_phase_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        phases,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["phases"] = phases
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_phase:
            self.check_ignore_phase.remove(eternal)

    def check_same_monster_exist_chain(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_same_monster_exist_chain:
            self.check_ignore_chain_same_monster_exist_chain.append(eternal)

    def check_same_monster_exist_chain_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_same_monster_exist_chain:
            self.check_ignore_same_monster_exist_chain.remove(eternal)

    def check_same_monster_chain(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_same_monster_chain:
            self.check_ignore_chain_same_monster_chain.append(eternal)

    def check_same_monster_chain_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_same_monster_chain:
            self.check_ignore_same_monster_chain.remove(eternal)

    def check_same_chain(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_same_chain:
            self.check_ignore_chain_same_chain.append(eternal)

    def check_same_chain_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_same_chain:
            self.check_ignore_same_chain.remove(eternal)

    def check_chain_kind(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        ignore_kind,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["ignore_kind"] = ignore_kind
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_chain_kind:
            self.check_ignore_chain_user_kind.append(eternal)

    def check_chain_kind_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        ignore_kind,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["ignore_kind"] = ignore_kind
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_chain_kind:
            self.check_ignore_chain_kind.remove(eternal)

    def check_chain_user(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_chain_user_only:
            self.check_ignore_chain_user_only.append(eternal)

    def check_chain_user_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_chain_user_only:
            self.check_ignore_chain_user_only.remove(eternal)

    def check_chain(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.check_ignore_chain:
            self.check_ignore_chain.append(eternal)

    def check_chain_remove(
        self, eternal, invalid_kinds, place_unique_id, global_id, mine_or_other_effect
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.check_ignore_chain:
            self.check_ignore_chain.remove(eternal)

    def swap_init_variable_effect_remove(
            self,
            eternal,
            invalid_kinds,
            place_unique_id,
            global_id,
            val_name,
            change_val,
            tmp_val,
            mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.swap_init_val_eternal_effect:
            self.swap_init_val_eternal_effect.remove(eternal)
    def swap_variable_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.swap_val_eternal_effect:
            self.swap_val_eternal_effect.remove(eternal)

    def take_variable_instead_func_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["tmp_val"] = tmp_val
        eternal["val"] = change_val
        eternal["cost_or_effect"] = cost_or_effect
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.take_variable_instead:
            self.take_variable_instead.remove(eternal)

    def change_name_add_func_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["cost_or_effect"] = cost_or_effect
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.change_name_add_eternal_effect:
            self.change_name_add_eternal_effect.remove(eternal)
    def change_name_add_func(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["cost_or_effect"] = cost_or_effect
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.change_name_add_eternal_effect:
            self.change_name_add_eternal_effect.append(eternal)
    def change_name_func(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["cost_or_effect"] = cost_or_effect
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.change_name_eternal_effect:
            self.change_name_eternal_effect.append(eternal)
    def change_name_func_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["cost_or_effect"] = cost_or_effect
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.change_name_eternal_effect:
            self.change_name_eternal_effect.remove(eternal)
    def take_variable_instead_func(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["cost_or_effect"] = cost_or_effect
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.take_variable_instead:
            self.take_variable_instead.append(eternal)

    def change_destination_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["tmp_val"] = tmp_val
        eternal["val"] = change_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.change_destination_eternal_effect:
            self.change_destination_eternal_effect.remove(eternal)

    def change_destination_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.change_destination_eternal_effect:
            self.change_destination_eternal_effect.append(eternal)

    def change_variable_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.change_val_eternal_effect:
            self.change_val_eternal_effect.append(eternal)
    def swap_variable_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        val_name,
        change_val,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.swap_val_eternal_effect:
            self.swap_val_eternal_effect.append(eternal)
    def swap_init_variable_effect(
            self,
            eternal,
            invalid_kinds,
            place_unique_id,
            global_id,
            val_name,
            change_val,
            tmp_val,
            mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["val_name"] = val_name
        eternal["val"] = change_val
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.swap_init_val_eternal_effect:
            self.swap_init_val_eternal_effect.append(eternal)

    def no_eternal_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.not_eternal_effect:
            self.not_eternal_effect.remove(eternal)

    def no_eternal_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.not_eternal_effect:
            self.not_eternal_effect.append(eternal)

    def not_effected_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["cost_or_effect"] = cost_or_effect
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.not_effected_eternal_effect:
            self.not_effected_eternal_effect.remove(eternal)

    def not_effected_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        cost_or_effect,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["cost_or_effect"] = cost_or_effect
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.not_effected_eternal_effect:
            self.not_effected_eternal_effect.append(eternal)

    def invoke_invalid_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.invoke_invalid_eternal_effect:
            self.invoke_invalid_eternal_effect.remove(eternal)

    def invoke_invalid_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.invoke_invalid_eternal_effect:
            self.invoke_invalid_eternal_effect.append(eternal)

    def no_invoke_effect_remove(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal in self.no_invoke_eternal_effect:
            self.no_invoke_eternal_effect.remove(eternal)

    def no_invoke_effect(
        self,
        eternal,
        invalid_kinds,
        place_unique_id,
        global_id,
        tmp_val,
        mine_or_other_effect,
    ):
        eternal["invalid_kinds"] = invalid_kinds
        eternal["place_unique_id"] = place_unique_id
        eternal["global_name"] = global_id
        eternal["tmp_val"] = tmp_val
        eternal["mine_or_other_effect"] = mine_or_other_effect
        if eternal not in self.no_invoke_eternal_effect:
            self.no_invoke_eternal_effect.append(eternal)

    def invoke_eternal_effect(self, eternal_effects, user, other_user):
        duel = self.duel
        decks = self.deck_structure
        graves = self.grave_structure
        hands = self.hand_structure
        fields = self.field
        eternals = []
        for eternal in eternal_effects:

            if eternal.eternal_global_variable:
                tmp = eternal.eternal_global_variable.split("_")
                mine_or_other = int(tmp[1])
                variable = json.loads(duel.global_variable)
                tmp_val = int(eternal.eternal_global_variable_val)

                user_flag = True
                other_user_flag = True
                if mine_or_other == 3:
                    other_user_flag = False
                    if not variable[tmp[0]]["value"] == tmp_val:
                        user_flag = False
                else:
                    if user == 1:
                        if mine_or_other == 1:
                            if not variable[tmp[0]]["1_value"] == tmp_val:
                                user_flag = False
                            if not variable[tmp[0]]["2_value"] == tmp_val:
                                other_user_flag = False
                        elif mine_or_other == 2:
                            if not variable[tmp[0]]["2_value"] == tmp_val:
                                user_flag = False
                            if not variable[tmp[0]]["1_value"] == tmp_val:
                                other_user_flag = False
                    else:
                        if mine_or_other == 1:
                            if not variable[tmp[0]]["2_value"] == tmp_val:
                                user_flag = False
                            if not variable[tmp[0]]["1_value"] == tmp_val:
                                other_user_flag = False
                        elif mine_or_other == 2:
                            if not variable[tmp[0]]["1_value"] == tmp_val:
                                user_flag = False
                            if not variable[tmp[0]]["2_value"] == tmp_val:
                                other_user_flag = False
                if user_flag is True:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(eternal)
                    tmp["place"] = ""
                    tmp["effect_val"] = eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["already"] = 0
                    tmp["user"] = user
                    tmp["mine_or_other"] = user
                    eternals.append(tmp)
                if other_user_flag is True:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(eternal)
                    tmp["place"] = ""
                    tmp["effect_val"] = eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["already"] = 0
                    tmp["user"] = other_user
                    tmp["mine_or_other"] = other_user
                    eternals.append(tmp)
        variable_eternal = EternalEffect.objects.filter(~Q(eternal_variable=""))
        deck_info = self.get_deck_info(decks, user, other_user, 0)
        grave_info = self.get_grave_info(graves, user, other_user, 0)
        hand_info = self.get_hand_info(hands, user, other_user, 0)
        eternals += self.check_field_eternal(fields, user, other_user, variable_eternal)
        eternals += self.check_deck_eternal(
            deck_info, self.count_deck(decks), user, other_user, variable_eternal
        )
        eternals += self.check_grave_eternal(
            grave_info, graves.count(), user, other_user, variable_eternal
        )
        eternals += self.check_hand_eternal(
            hand_info, hands.count(), user, other_user, variable_eternal
        )
        eternals = sorted(eternals, key=lambda x: x["already"], reverse=True)
        eternals = sorted(eternals, key=lambda x: x["priority"], reverse=True)
        pprint(eternals)
        while True:
            check_ignore_chain = copy.deepcopy(self.check_ignore_chain)
            check_ignore_chain_user_only = copy.deepcopy(self.check_ignore_chain_user_only)
            check_ignore_chain_kind = copy.deepcopy(self.check_ignore_chain_kind)
            check_ignore_same_chain = copy.deepcopy(self.check_ignore_same_chain)
            check_ignore_same_monster_chain = copy.deepcopy(self.check_ignore_same_monster_chain)
            check_ignore_same_monster_exist_chain = (
                copy.deepcopy(self.check_ignore_same_monster_exist_chain)
            )
            check_ignore_phase = copy.deepcopy(self.check_ignore_phase)
            for tmp_for in check_ignore_phase:
                del tmp_for["phases"]
            check_ignore_mine_or_other = copy.deepcopy(self.check_ignore_mine_or_other)
            check_ignore_no_invoke = copy.deepcopy(self.check_ignore_no_invoke)
            check_ignore_timing = copy.deepcopy(self.check_ignore_timing)
            for tmp_for in check_ignore_timing:
                del tmp_for["timings"]
            check_monster_place_condition = copy.deepcopy(self.check_monster_place_condition)
            check_turn = copy.deepcopy(self.check_turn)
            check_monster_condition_list = copy.deepcopy(self.check_monster_condition_list)
            check_monster_variable = copy.deepcopy(self.check_monster_variable)
            change_name_eternal_effect = copy.deepcopy(self.change_name_eternal_effect)
            change_name_add_eternal_effect = copy.deepcopy(self.change_name_add_eternal_effect)
            no_choose_eternal_effect = copy.deepcopy(self.no_choose_eternal_effect)
            change_val_eternal_effect = copy.deepcopy(self.change_val_eternal_effect)
            swap_val_eternal_effect = copy.deepcopy(self.swap_val_eternal_effect)
            swap_init_val_eternal_effect = copy.deepcopy(self.swap_init_val_eternal_effect)
            change_destination_eternal_effect = copy.deepcopy(self.change_destination_eternal_effect)
            invoke_invalid_eternal_effect = copy.deepcopy(self.invoke_invalid_eternal_effect)
            no_invoke_eternal_effect = copy.deepcopy(self.no_invoke_eternal_effect)
            not_effected_eternal_effect = copy.deepcopy(self.not_effected_eternal_effect)
            not_eternal_effect = copy.deepcopy(self.not_eternal_effect)
            take_variable_instead = copy.deepcopy(self.take_variable_instead)
            for eternal in eternals:
                if eternal["user"] == user:
                    self.invoke_eternal_effect_det(eternal, user)
                elif eternal["user"] == other_user:
                    self.invoke_eternal_effect_det(eternal, other_user)
            self_check_ignore_phase_compare = copy.deepcopy(self.check_ignore_phase)
            for val_for in self_check_ignore_phase_compare:
                del val_for["phases"]
            self_check_ignore_timing_compare = copy.deepcopy(self.check_ignore_timing)
            for val_for in self_check_ignore_timing_compare:
                del val_for["timings"]
            if (
                self.no_choose_eternal_effect == no_choose_eternal_effect
                and self.swap_val_eternal_effect == swap_val_eternal_effect
                and self.swap_init_val_eternal_effect == swap_init_val_eternal_effect
                and self.change_val_eternal_effect == change_val_eternal_effect
                and self.change_name_eternal_effect == change_name_eternal_effect
                and self.change_name_add_eternal_effect == change_name_add_eternal_effect
                and self.invoke_invalid_eternal_effect == invoke_invalid_eternal_effect
                and self.not_effected_eternal_effect == not_effected_eternal_effect
                and self.not_eternal_effect == not_eternal_effect
                and self.no_invoke_eternal_effect == no_invoke_eternal_effect
                and change_destination_eternal_effect
                == self.change_destination_eternal_effect
                and check_ignore_chain == self.check_ignore_chain
                and check_ignore_chain_user_only == self.check_ignore_chain_user_only
                and check_ignore_chain_kind == self.check_ignore_chain_kind
                and check_ignore_same_chain == self.check_ignore_same_chain
                and check_ignore_same_monster_chain
                == self.check_ignore_same_monster_chain
                and check_ignore_same_monster_exist_chain
                == self.check_ignore_same_monster_exist_chain
                and check_ignore_phase == self_check_ignore_phase_compare
                and check_ignore_mine_or_other == self.check_ignore_mine_or_other
                and check_ignore_no_invoke == self.check_ignore_no_invoke
                and check_ignore_timing == self_check_ignore_timing_compare
                and check_monster_place_condition == self.check_monster_place_condition
                and check_turn == self.check_turn
                and check_monster_condition_list == self.check_monster_condition_list
                and check_monster_variable == self.check_monster_variable
                and take_variable_instead == self.take_variable_instead
            ):
                break

    def clear_eternal_effect(self, decks, graves, hands):
        self.no_choose_eternal_effect = []
        self.change_val_eternal_effect = []
        self.change_name_eternal_effect = []
        self.change_name_add_eternal_effect = []
        self.swap_val_eternal_effect = []
        self.swap_init_val_eternal_effect = []
        self.change_destination_eternal_effect = []
        self.take_variable_instead = []
        self.invoke_invalid_eternal_effect = []
        self.no_invoke_eternal_effect = []
        self.not_effected_eternal_effect = []
        self.not_eternal_effect = []
        self.check_ignore_chain = []
        self.check_ignore_chain_user_only = []
        self.check_ignore_chain_kind = []
        self.check_ignore_same_chain = []
        self.check_ignore_same_monster_chain = []
        self.check_ignore_same_monster_exist_chain = []
        self.check_ignore_phase = []
        self.check_ignore_mine_or_other = []
        self.check_ignore_no_invoke = []
        self.check_ignore_timing = []
        self.check_monster_place_condition = []
        self.check_turn = []
        self.check_monster_condition_list = []
        self.check_monster_variable = []

    def invoke_after_chain_effect(self, decks, graves, hands, phase, turn, user, other_user):
        none_chain_effect = EndChainEffect.objects.first()
        if none_chain_effect is not None:
            self.invoke_no_chain_effect(none_chain_effect, user, other_user, none_chain_effect.monster_effect_kind)
        self.expire_chain()

    def check_eternal_effect(self, decks, graves, hands, phase, turn, user, other_user):
        self.clear_eternal_effect(decks, graves, hands)
        self.init_virtual_variable(user, other_user, self.room_number)
        duel = self.duel
        eternal_effects = EternalEffect.objects.filter(
            Q(phase=phase) | Q(phase__isnull=True)
        )
        eternal_effects = eternal_effects.filter(
            Q(chain__isnull=True)
            | Q(chain=duel.virtual_chain, chain_kind=2)
            | Q(chain__lte=duel.virtual_chain, chain_kind=0)
            | Q(chain__gte=duel.virtual_chain, chain_kind=1)
        )
        eternal_effects = eternal_effects.filter(none_monster=True)
        if duel.timing is not None:
            eternal_effects = eternal_effects.filter(Q(timing=duel.timing))
        else:
            eternal_effects = eternal_effects.filter(Q(none_timing=True))
        if duel.timing2 is not None:
            eternal_effects = eternal_effects.filter(Q(timing2=duel.timing2))
        else:
            eternal_effects = eternal_effects.filter(Q(none_timing2=True))
        if duel.timing3 is not None:
            eternal_effects = eternal_effects.filter(Q(timing3=duel.timing3))
        else:
            eternal_effects = eternal_effects.filter(Q(none_timing3=True))
        eternal_effects = eternal_effects.order_by("eternal_effect_val")
        eternal_effects = eternal_effects.order_by("-priority")
        self.invoke_eternal_effect(eternal_effects, user, other_user)
        none_chain_effects = EternalTrigger.objects.all()
        if duel.is_ai is False:
            none_chain_effects = none_chain_effects.filter(
                Q(enemy = 0 ) | Q(enemy = 1)
            )
            none_chain_effects = none_chain_effects.filter(
                Q(enemy_own = 0 ) | Q(enemy_own = 1)
            )
        else:
            none_chain_effects = none_chain_effects.filter(
                Q(enemy = 2 ) | Q(enemy = 1)
            )
            if user == 1:
                none_chain_effects = none_chain_effects.filter(
                    Q(enemy_own = 0 ) | Q(enemy_own = 1)
                )
            else:
                none_chain_effects = none_chain_effects.filter(
                    Q(enemy_own = 1 ) | Q(enemy_own = 2)
                )
        none_chain_effects = none_chain_effects.filter(
            Q(phase__isnull=True) | Q(phase=phase)
        )
        none_chain_effects = none_chain_effects.filter(
            Q(chain__isnull=True)
            | (Q(chain_kind=0) & Q(chain__lte=duel.chain))
            | (Q(chain_kind=1) & Q(chain__gte=duel.chain))
            | (Q(chain_kind=2) & Q(chain=duel.chain))
        )
        if duel.timing is not None:
            none_chain_effects = none_chain_effects.filter(Q(timing=duel.timing))
        else:
            none_chain_effects = none_chain_effects.filter(Q(none_timing=True))
        if duel.timing2 is not None:
            none_chain_effects = none_chain_effects.filter(Q(timing2=duel.timing2))
        else:
            none_chain_effects = none_chain_effects.filter(Q(none_timing2=True))
        if duel.timing3 is not None:
            none_chain_effects = none_chain_effects.filter(Q(timing2=duel.timing3))
        else:
            none_chain_effects = none_chain_effects.filter(Q(none_timing3=True))
        none_chain_effects = none_chain_effects.order_by("-priority")
        eternal_det = json.loads(duel.eternal_det)
        flag = True
        for none_chain_effect in none_chain_effects:
            if none_chain_effect.id in eternal_det:
                continue
            eternal_wrapper = none_chain_effect.eternal_effect_next

            kinds = eternal_wrapper.monster_effect_kind
            if (
                self.invoke_no_chain_effect(eternal_wrapper, user, other_user, kinds)
                == 0
            ):
                eternal_det.append(none_chain_effect.id)
            else:
                flag = False
                break
        if flag is True:
            duel.eternal_det = json.dumps([])
        else:
            duel.eternal_det = json.dumps(eternal_det)

    def retrieve_chain(self, decks, graves, hands, phase, user_turn, user, other_user):
        self.retrieve = 1
        self.duel.canbechained = True
        self.duel.none = False

        trigger_waiting = json.loads(self.duel.trigger_waiting)
        tmp = None
        while (
            self.duel.chain != 0
            and self.duel.ask == 0
            and self.duel.in_cost is False
            and tmp != "copy"
        ):
            tmp = self.retrieve_chain_det(
                decks, graves, hands, phase, user_turn, user, other_user
            )
            if self.duel.winner != 0 or self.duel.winner_ai != 0:
                self.duel.chain = 0
                self.duel.virtual_chain = 0
                break
            self.check_eternal_effect(
                decks, graves, hands, phase, user_turn, user, other_user
            )
        self.check_eternal_effect(
            decks, graves, hands, phase, user_turn, user, other_user
        )
        if self.duel.chain == 0:
            if self.duel.in_cost is False:
                self.cost = {}
                self.mess = {}
            self.duel.in_pac = "{}"
            self.duel.chain_det_trigger = "{}"
            self.duel.chain_variable = "{}"
        self.duel.retrieve = 0
        pprint("duel.ask2")
        pprint(self.duel.ask2)
        self.update = True
        if self.duel.is_ai is True:
            if self.duel.chain == 0:
                self.duel.appoint = self.duel.user_turn
            self.save_all(user, other_user, self.duel.id)

    def retrieve_chain_det(
        self, decks, graves, hands, phase, user_turn, user, other_user
    ):
        duel = self.duel
        self.tmp_chain = str(duel.chain)
        chain_det = json.loads(self.duel.chain_det)
        chain_user_ary = json.loads(self.duel.chain_user)
        current_chain = chain_det[str(self.duel.chain - 1)]
        chain_user = chain_user_ary[str(self.duel.chain - 1)]
        chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
        trigger_id = chain_det_trigger_json[str(duel.chain - 1)]
        trigger = Trigger.objects.get(id=trigger_id)
        if chain_user == 1:
            chain_no_user = 2
        elif chain_user == 2:
            chain_no_user = 1
        mess = self.mess
        if str(duel.chain - 1) in mess:

            if "invalid" in mess[str(duel.chain - 1)]:
                del chain_det[str(self.duel.chain - 1)]
                self.duel.chain_det = json.dumps(chain_det)
                self.duel.chain -= 1
                if(trigger.chain_flag is True):
                    self.duel.virtual_chain -= 1
                return None
        if current_chain == 0:
            self.duel.chain -= 1
            if(trigger.chain_flag is True):
               self.duel.virtual_chain -= 1
            return None
        trigger_waiting = json.loads(self.duel.trigger_waiting)
        monster_effect = MonsterEffectWrapper.objects.get(id=current_chain)
        kinds = monster_effect.monster_effect_kind
        monster_effect_next = self.invoke_monster_effect(
            monster_effect, decks, graves, kinds
        )
        if monster_effect_next == "copy":
            return "copy"
        if monster_effect_next is None:
            pac = json.loads(duel.in_pac)
            if str(self.duel.chain - 1) in pac and len(pac[str(duel.chain - 1)]) > 0:
                pac = pac[str(self.duel.chain - 1)]
            else:
                pac = []
            if pac != []:
                pac_id = pac.pop()
                pac = PacWrapper.objects.get(id=pac_id)
                monster_effect_next = pac.monster_effect_next
        elif monster_effect_next == -2:
            monster_effect_next = None
        while monster_effect_next:
            if monster_effect_next == "copy":
                return "copy"
            if duel.winner != 0 or duel.winner_ai != 0:
                return None
            if monster_effect_next == -1:
                return None
            else:
                chain_det[str(self.duel.chain - 1)] = monster_effect_next.id
                self.duel.chain_det = json.dumps(chain_det)
                monster_effect = monster_effect_next
                strategy = monster_effect.strategy
                strategy_up_or_down = monster_effect.strategy_up_or_down
                monster_effect_unwrap = monster_effect.monster_effect
                if monster_effect_unwrap.monster_effect_val == 5:
                    duel.ask = 0
                    effect_kind = monster_effect.monster_effect_kind
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    self.duel.ask_kind = effect_kind
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    whether_monster = monster_effect_text["whether_monster"]
                    exclude = monster_effect_text["exclude"]
                    monster_effect_text = monster_effect_text["monster"][0]
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"], None,chain_user
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"], None,chain_user
                    )
                    if self.check_monster_exists(
                         monster_effect_text,
                         min,
                         max,
                         chain_user,
                         effect_kind,
                         0,
                         whether_monster,
                         exclude,
                     ):
                        if duel.is_ai is False:
                            if duel.user_turn == 1 :
                                if chain_user == 1:
                                    self.duel.ask = 1
                                else:
                                    self.duel.ask = 2
                            else:
                                if chain_user == 1:
                                    self.duel.ask = 2
                                else:
                                    self.duel.ask = 1
                        else:
                            if duel.user_turn == 1 :
                                if chain_user == 1:
                                    self.duel.ask = 1
                                else:
                                    self.answer_ai(strategy,strategy_up_or_down)
                            else:
                                if chain_user == 1:
                                    self.duel.ask = 2
                                else:
                                    self.answer_ai(strategy,strategy_up_or_down)
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    whether_monster = monster_effect_text["whether_monster"]
                    exclude = monster_effect_text["exclude"]
                    monster_effect_text = monster_effect_text["monster"][1]
                    if chain_user == 1:
                        tmp_user = 2
                    else:
                        tmp_user = 1
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"], None
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"], None
                    )
                    if self.check_monster_exists(
                         monster_effect_text,
                         min,
                         max,
                         tmp_user,
                         effect_kind,
                         0,
                         whether_monster,
                         exclude,
                     ):
                        if duel.is_ai is False:
                            if duel.user_turn == 2 :
                                if chain_user == 1:
                                    self.duel.ask += 1
                                else:
                                    self.duel.ask += 2
                            else:
                                if chain_user == 1:
                                    self.duel.ask += 2
                                else:
                                    self.duel.ask += 1
                        else:
                            if duel.user_turn == 2: 
                                if chain_user == 1:
                                    self.answer_ai(strategy,strategy_up_or_down)
                                else:
                                    self.duel.ask += 2
                            else:
                                if chain_user == 1:
                                    self.duel.ask += 2
                                else:
                                    self.answer_ai(strategy,strategy_up_or_down)
                elif (
                    monster_effect_unwrap.monster_effect_val == 3
                    or monster_effect_unwrap.monster_effect_val == 44
                ):
                    effect_kind = monster_effect.monster_effect_kind
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    whether_monster = monster_effect_text["whether_monster"]
                    exclude = monster_effect_text["exclude"]
                    monster_effect_text = monster_effect_text["monster"][0]
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"], None
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"], None
                    )
                    if min != 0 or max != 0:
                        pac = json.loads(duel.in_pac)
                        if (
                            str(self.duel.chain - 1) in pac
                            and len(pac[str(duel.chain - 1)]) > 0
                        ):
                            pac = pac[str(self.duel.chain - 1)]
                            pac_id = pac.pop()
                            pac = PacWrapper.objects.get(id=pac_id)
                            if pac.monster_effect_kind != "":
                                effect_kind = pac.monster_effect_kind
                        if self.check_monster_exists(
                            monster_effect_text,
                            min,
                            max,
                            chain_user,
                            effect_kind,
                            0,
                            whether_monster,
                            exclude,
                        ):
                            self.duel.ask_kind = effect_kind
                            if self.duel.is_ai is False or chain_user == 1:
                                if duel.user_turn == chain_user:
                                    self.duel.ask = 1
                                else:
                                    self.duel.ask = 2

                elif monster_effect_unwrap.monster_effect_val == 4:
                    effect_kind = monster_effect.monster_effect_kind
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    whether_monster = monster_effect_text["whether_monster"]
                    exclude = monster_effect_text["exclude"]
                    monster_effect_text = monster_effect_text["monster"][0]
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"], None,True,eternal = True
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"], None,True,eternal = True
                    )
                    if min != 0 or max != 0:
                        pac = json.loads(duel.in_pac)
                        if (
                            str(self.duel.chain - 1) in pac
                            and len(pac[str(duel.chain - 1)]) > 0
                        ):
                            pac = pac[str(self.duel.chain - 1)]
                            pac_id = pac.pop()
                            pac = PacWrapper.objects.get(id=pac_id)
                            if pac.monster_effect_kind != "":
                                effect_kind = pac.monster_effect_kind
                        self.duel.ask_kind = effect_kind
                        if self.check_monster_exists(
                            monster_effect_text,
                            min,
                            max,
                            chain_no_user,
                            effect_kind,
                            0,
                            whether_monster,
                            exclude,
                        ):
                            if self.duel.is_ai is False or chain_user == 2:
                                if duel.user_turn == chain_user:
                                    self.duel.ask = 2
                                else:
                                    self.duel.ask = 1
                elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 66:
                    effect_kind = monster_effect.monster_effect_kind
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    if self.duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 66:
                    effect_kind = monster_effect.monster_effect_kind
                    pac = json.loads(duel.in_pac)
                    if (
                            str(self.duel.chain - 1) in pac
                            and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    if self.duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 26 or monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 67 :
                    effect_kind = monster_effect.monster_effect_kind
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    if self.duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
                elif monster_effect_unwrap.monster_effect_val == 27 or monster_effect_unwrap.monster_effect_val == 63:
                    effect_kind = monster_effect.monster_effect_kind
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"]
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"]
                    )
                    if min != 0 or max != 0:
                        pac = json.loads(duel.in_pac)
                        if (
                            str(self.duel.chain - 1) in pac
                            and len(pac[str(duel.chain - 1)]) > 0
                        ):
                            pac = pac[str(self.duel.chain - 1)]
                            pac_id = pac.pop()
                            pac = PacWrapper.objects.get(id=pac_id)
                            if pac.monster_effect_kind != "":
                                effect_kind = pac.monster_effect_kind
                        self.duel.ask_kind = effect_kind
                        if self.duel.is_ai is False or chain_user == 1:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 1
                            else:
                                self.duel.ask = 2
                    else:
                        if monster_effect.pac:
                            return self._pac(monster_effect.pac)
                        else:
                            if monster_effect.monster_effect_next is not None:
                                return monster_effect.monster_effect_next
                            else:
                                return self.pop_pac(user)
                elif monster_effect_unwrap.monster_effect_val == 28 or monster_effect_unwrap.monster_effect_val == 64:
                    effect_kind = monster_effect.monster_effect_kind
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"],True
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"],True
                    )
                    if min != 0 or max != 0:
                        pac = json.loads(duel.in_pac)
                        if (
                            str(self.duel.chain - 1) in pac
                            and len(pac[str(duel.chain - 1)]) > 0
                        ):
                            pac = pac[str(self.duel.chain - 1)]
                            pac_id = pac.pop()
                            pac = PacWrapper.objects.get(id=pac_id)
                            if pac.monster_effect_kind != "":
                                effect_kind = pac.monster_effect_kind
                        self.duel.ask_kind = effect_kind
                        if self.duel.is_ai is False or chain_user == 2:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 2
                            else:
                                self.duel.ask = 1
                    else:
                        if monster_effect.pac:
                            return self._pac(monster_effect.pac)
                        else:
                            if monster_effect.monster_effect_next is not None:
                                return monster_effect.monster_effect_next
                            else:
                                return self.pop_pac(user)
                elif monster_effect_unwrap.monster_effect_val == 30:
                    effect_kind = monster_effect.monster_effect_kind
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    monster_condition = monster_effect_unwrap.monster_condition
                    if monster_condition != "":
                        monster_condition = json.loads(monster_condition)
                        monster_condition = monster_condition["monster"][0]["monster"]
                    monster_effect_text_org = json.loads(monster_effect_unwrap.monster_effect)
                    if(self.check_multiple(chain_user,effect_kind,monster_effect_text_org,monster_condition)):
                        self.duel.ask_kind = effect_kind
                        if self.duel.is_ai is False or user == 1:
                            if duel.user_turn == user:
                                self.duel.ask = 1
                            else:
                                self.duel.ask = 2
                elif monster_effect_unwrap.monster_effect_val == 31:
                    effect_kind = monster_effect.monster_effect_kind
                    monster_condition = monster_effect_unwrap.monster_condition
                    if monster_condition != "":
                        monster_condition = json.loads(monster_condition)
                        monster_condition = monster_condition["monster"][0]["monster"]
                    monster_effect_text_org = json.loads(monster_effect_unwrap.monster_effect)
                    if(self.check_multiple(chain_no_user,effect_kind,monster_effect_text_org,monster_condition)):
                        self.duel.ask_kind = effect_kind
                        if duel.is_ai is False or user == 1:
                            if duel.user_turn == user:
                                self.duel.ask = 1
                            else:
                                self.duel.ask = 2

                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                if monster_effect_unwrap.eternal_flag is True:
                    self.check_eternal_effect(
                        decks, graves, hands, phase, duel.user_turn, user, other_user
                    )
                effect_kind = monster_effect.monster_effect_kind
                trigger_waiting = json.loads(self.duel.trigger_waiting)
                monster_effect_next = self.invoke_monster_effect(
                    monster_effect, decks, graves, effect_kind
                )
                if monster_effect_next is None:
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        monster_effect_next = pac.monster_effect_next
                elif monster_effect_next == -2:
                    monster_effect_next = None


            if self.duel.ask != 0:
                return None
        del chain_det[str(self.duel.chain - 1)]
        self.duel.chain_det = json.dumps(chain_det)
        self.duel.chain -= 1
        if(trigger.chain_flag is True):
          self.duel.virtual_chain -= 1
        if self.duel.chain != 0:
            chain_det_ary = json.loads(self.duel.chain_det_trigger)
            chain_det2 = chain_det_ary[str(self.duel.chain - 1)]
            current_trigger = Trigger.objects.get(id=chain_det2)
            #if current_trigger.pac:
            #    self._pac(current_trigger.pac)
            chain_user = chain_user_ary[str(self.duel.chain - 1)]
            current_chain = chain_det[str(self.duel.chain - 1)]
            if current_chain == 0:
                if(current_trigger.chain_flag is True):
                    self.duel.virtual_chain -= 1
                self.duel.chain -= 1
                return
            monster_effect = MonsterEffectWrapper.objects.get(id=current_chain)
            monster_effect_unwrap = monster_effect.monster_effect
            if monster_effect_unwrap.monster_effect_val == 5:
                    duel.ask = 0
                    effect_kind = monster_effect.monster_effect_kind
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    self.duel.ask_kind = effect_kind
                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    whether_monster = monster_effect_text["whether_monster"]
                    exclude = monster_effect_text["exclude"]
                    monster_effect_text = monster_effect_text["monster"][0]
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"], None
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"], None
                    )
                    if self.check_monster_exists(
                         monster_effect_text,
                         min,
                         max,
                         chain_user,
                         effect_kind,
                         0,
                         whether_monster,
                         exclude,
                     ):
                        if duel.is_ai is False:
                            if duel.user_turn == 1:
                                if chain_user == 1:
                                    self.duel.ask = 1
                                else:
                                    self.duel.ask = 2
                            else:
                                if chain_user == 1:
                                    self.duel.ask = 2
                                else:
                                    self.duel.ask = 1
                        else:
                            if duel.user_turn == 1:
                                if chain_user == 1:
                                    self.duel.ask = 1
                                else:
                                    self.answer_ai(strategy,strategy_up_or_down)
                            else:
                                if chain_user == 1:
                                    self.answer_ai(strategy,strategy_up_or_down)
                                else:
                                    self.duel.ask = 1

                    monster_effect_text = json.loads(
                        monster_effect_unwrap.monster_effect
                    )
                    whether_monster = monster_effect_text["whether_monster"]
                    exclude = monster_effect_text["exclude"]
                    monster_effect_text = monster_effect_text["monster"][1]
                    min = self.calculate_boland(
                        monster_effect_text["min_equation_number"], None
                    )
                    max = self.calculate_boland(
                        monster_effect_text["max_equation_number"], None
                    )
                    if chain_user == 1:
                        tmp_user = 2
                    else:
                        tmp_user = 1
                    if self.check_monster_exists(
                         monster_effect_text,
                         min,
                         max,
                         tmp_user,
                         effect_kind,
                         0,
                         whether_monster,
                         exclude,
                     ):
                        if duel.is_ai is False:
                            if duel.user_turn == 2:
                                if chain_user == 1:
                                    self.duel.ask += 1
                                else:
                                    self.duel.ask += 2
                            else:
                                if chain_user == 2:
                                    self.duel.ask += 2
                                else:
                                    self.duel.ask += 1
                        else:
                            if duel.user_turn == 2:
                                if chain_user == 1:
                                    self.duel.ask += 1
                                else:
                                    self.answer_ai(strategy,strategy_up_or_down)
                            else:
                                if chain_user == 1:
                                    self.answer_ai(strategy,strategy_up_or_down)
                                else:
                                    self.duel.ask += 1
            elif (
                monster_effect_unwrap.monster_effect_val == 3
                or monster_effect_unwrap.monster_effect_val == 44
            ):
                effect_kind = monster_effect.monster_effect_kind
                monster_effect_text = json.loads(
                    monster_effect.monster_effect.monster_effect
                )
                whether_monster = monster_effect_text["whether_monster"]
                exclude = monster_effect_text["exclude"]
                monster_effect_text = monster_effect_text["monster"][0]
                min = self.calculate_boland(monster_effect_text["min_equation_number"])
                max = self.calculate_boland(monster_effect_text["max_equation_number"])
                if min != 0 or max != 0:
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    if self.check_monster_exists(
                        monster_effect_text,
                        min,
                        max,
                        chain_user,
                        effect_kind,
                        0,
                        whether_monster,
                        exclude,
                    ):
                        self.duel.ask_kind = effect_kind
                        if duel.is_ai is False or chain_user == 1:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 1
                            else:
                                self.duel.ask = 2

            elif monster_effect_unwrap.monster_effect_val == 4:
                effect_kind = monster_effect.monster_effect_kind
                monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
                whether_monster = monster_effect_text["whether_monster"]
                exclude = monster_effect_text["exclude"]
                monster_effect_text = monster_effect_text["monster"][0]
                min = self.calculate_boland(monster_effect_text["min_equation_number"],other_user_flag=True,eternal=True)
                max = self.calculate_boland(monster_effect_text["max_equation_number"],other_user_flag=True,eternal=True)
                if min != 0 or max != 0:
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    if self.check_monster_exists(
                        monster_effect_text,
                        min,
                        max,
                        chain_no_user,
                        effect_kind,
                        0,
                        whether_monster,
                        exclude,
                    ):
                        self.duel.ask_kind = effect_kind
                        if duel.is_ai is False or chain_user == 2:
                            if duel.user_turn == chain_user:
                                self.duel.ask = 2
                            else:
                                self.duel.ask = 1
            elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 66:
                effect_kind = monster_effect.monster_effect_kind
                pac = json.loads(duel.in_pac)
                if (
                    str(self.duel.chain - 1) in pac
                    and len(pac[str(duel.chain - 1)]) > 0
                ):
                    pac = pac[str(self.duel.chain - 1)]
                    pac_id = pac.pop()
                    pac = PacWrapper.objects.get(id=pac_id)
                    if pac.monster_effect_kind != "":
                        effect_kind = pac.monster_effect_kind

                    if duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
            elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 26 or monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 67 :
                effect_kind = monster_effect.monster_effect_kind
                pac = json.loads(duel.in_pac)
                if (
                    str(self.duel.chain - 1) in pac
                    and len(pac[str(duel.chain - 1)]) > 0
                ):
                    pac = pac[str(self.duel.chain - 1)]
                    pac_id = pac.pop()
                    pac = PacWrapper.objects.get(id=pac_id)
                    if pac.monster_effect_kind != "":
                        effect_kind = pac.monster_effect_kind
                    if duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
            elif monster_effect_unwrap.monster_effect_val == 27 or monster_effect_unwrap.monster_effect_val == 63:
                effect_kind = monster_effect.monster_effect_kind
                monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
                min = self.calculate_boland(monster_effect_text["min_equation_number"])
                max = self.calculate_boland(monster_effect_text["max_equation_number"])
                if min != 0 or max != 0:
                    pac = json.loads(duel.in_pac)
                    if str(self.duel.chain - 1) in pac:
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    self.duel.ask_kind = effect_kind
                    if duel.is_ai is False or chain_user == 1:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
            elif monster_effect_unwrap.monster_effect_val == 28 or monster_effect_unwrap.monster_effect_val == 64:
                effect_kind = monster_effect.monster_effect_kind
                monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
                min = self.calculate_boland(
                    monster_effect_text["min_equation_number"], None, True
                )
                max = self.calculate_boland(
                    monster_effect_text["max_equation_number"], None, True
                )
                if min != 0 or max != 0:
                    pac = json.loads(duel.in_pac)
                    if (
                        str(self.duel.chain - 1) in pac
                        and len(pac[str(duel.chain - 1)]) > 0
                    ):
                        pac = pac[str(self.duel.chain - 1)]
                        pac_id = pac.pop()
                        pac = PacWrapper.objects.get(id=pac_id)
                        if pac.monster_effect_kind != "":
                            effect_kind = pac.monster_effect_kind
                    self.duel.ask_kind = effect_kind
                    if duel.is_ai is False or chain_user == 2:
                        if duel.user_turn == chain_user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
            elif monster_effect_unwrap.monster_effect_val == 30:
                effect_kind = monster_effect.monster_effect_kind
                monster_effect_text = json.loads(
                    monster_effect.monster_effect.monster_effect
                )
                pac = json.loads(duel.in_pac)
                if (
                    str(self.duel.chain - 1) in pac
                    and len(pac[str(duel.chain - 1)]) > 0
                ):
                    pac = pac[str(self.duel.chain - 1)]
                    pac_id = pac.pop()
                    pac = PacWrapper.objects.get(id=pac_id)
                    if pac.monster_effect_kind != "":
                        effect_kind = pac.monster_effect_kind
                self.duel.ask_kind = effect_kind
                if duel.is_ai is False or chain_user == 1:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
            elif monster_effect_unwrap.monster_effect_val == 31:
                effect_kind = monster_effect.monster_effect_kind
                if str(self.duel.chain - 1) in pac:
                    pac = pac[str(self.duel.chain - 1)]
                    pac_id = pac.pop()
                    pac = PacWrapper.objects.get(id=pac_id)
                    if pac.monster_effect_kind != "":
                        effect_kind = pac.monster_effect_kind
                self.duel.ask_kind = effect_kind
                if duel.is_ai is False or chain_user == 2:
                    if duel.user_turn == chain_user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                else:
                    self.answer_ai(strategy,strategy_up_or_down)

    def invoke_cost(self, cost, chain):
        duel = self.duel
        cost_unwrap = cost.cost
        chain_user = json.loads(duel.chain_user)
        user = chain_user[str(chain)]
        effect_kind = self.get_pac_cost_effect_kind()
        if effect_kind is None:
            effect_kind = cost.cost_kind
        if cost_unwrap.cost_val == 0:
            cost_condition = json.loads(cost_unwrap.cost_condition)
            duel.cost_log += self.write_log(cost.log, user)
            if self.check_cost_condition(cost_condition, effect_kind):
                if cost.pac:
                    return self._pac_cost(cost.pac)
                else:
                    if cost.cost_next:
                        return cost.cost_next
                    else:
                        return self.pop_pac_cost(user)
            else:
                if cost.pac2:
                    return self._pac_cost(cost.pac2)
                else:
                    if cost.cost_next2:
                        return cost.cost_next2
                    else:
                        return self.pop_pac_cost2(user)

        elif cost_unwrap.cost_val == 35:
            data_tmp = self.copy_monster_cost(
                cost_unwrap.cost, cost_unwrap.cost_condition, effect_kind
            )
            log_tmp = self.write_log(cost.log, user, data_tmp)
            duel.cost_log += log_tmp
            if cost.pac:
                return self._pac_cost(cost.pac)
            else:
                if cost.cost_next:
                    return cost.cost_next
                else:
                    return self.pop_pac_cost(user)

        elif cost_unwrap.cost_val == 48:
            return_value =  self.copy_special_effect(cost_unwrap, effect_kind)
            if isinstance(return_value,int):
                return return_value
            data = {}
            data["monsters"] = return_value[1]
            log_tmp = self.write_log(cost.log, user,data)
            duel.cost_log += log_tmp
            return return_value[0]
        elif cost_unwrap.cost_val == 56:
            self.clear_cost_mess(cost_unwrap.cost)
            if cost.pac:
                return self._pac_cost(cost.pac)
            else:
                if cost.cost_next:
                    return cost.cost_next
                else:
                    return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 33:
            log_tmp = self.write_log(cost.log, user)
            duel.cost_log += log_tmp
            self.clear_relation_cost(
                cost_unwrap.cost, effect_kind, cost_unwrap.cost_condition
            )
            if cost.pac:
                return self._pac_cost(cost.pac)
            else:
                if cost.cost_next:
                    return cost.cost_next
                else:
                    return self.pop_pac_cost(user)
        elif (
            cost_unwrap.cost_val == 5
            or cost_unwrap.cost_val == 4
            or cost_unwrap.cost_val == 3
            or cost_unwrap.cost_val == 27
            or cost_unwrap.cost_val == 28
            or cost_unwrap.cost_val == 63
            or cost_unwrap.cost_val == 64
        ):
            duel.cost_log += self.write_log(cost.log, user)
            if self.duel.ask > 0 :
                self.duel.ask_det = cost.cost.cost
                return -1

            else:
                if user == 2 and duel.is_ai is True:
                    return self.do_cost_next_ai(cost,user)
                else:
                    return self.do_cost_next(cost,user)
        elif cost_unwrap.cost_val == 17:
            cost_kind = cost.cost_kind
            duel.cost_log += self.write_log(cost.log, user)
            move_to = self.move_from_monster_simple_cost(cost_kind)

            if move_to is not None:
                self.move_to_monster_cost(move_to, cost_kind)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 25:
            log_tmp = self.write_log(cost.log, user)
            duel.cost_log += log_tmp
            self.change_monster_relation_cost(
                cost_unwrap.cost, effect_kind, cost_unwrap.cost_condition
            )
        elif cost_unwrap.cost_val == 36:
            move_to = self.move_from_monster_cost(effect_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                log_tmp = self.write_log(cost.log, user, data)
                duel.cost_log += log_tmp
            if move_to is not None:
                self.move_to_under_monster_cost(move_to, effect_kind)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 1:
            cost_kind = cost.cost_kind
            move_to = self.move_from_monster_cost(cost_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                log_tmp = self.write_log(cost.log, user, data)
                duel.cost_log += log_tmp

            if move_to is not None:
                self.move_to_monster_cost(move_to, cost_kind)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 40:
            cost_kind = cost.cost_kind
            move_to = self.move_from_monster_relation_cost(cost_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                log_tmp = self.write_log(cost.log, user, data)
                duel.cost_log += log_tmp

            if move_to is not None:
                self.move_to_monster_cost(move_to, cost_kind)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 7:
            duel.cost_log += self.write_log(cost.log, user)
            self.move_phase_cost()
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 8:
            duel.cost_log += self.write_log(cost.log, user)
            self.change_turn_cost()
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 2:
            change_val = self.change_variable_cost()
            data = {}
            data["val"] = change_val
            if change_val != 0:
                duel.cost_log = self.write_log(cost.log, user, data)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 34:
            data_tmp = self.change_variable_by_monster_cost()
            data = {}
            data["monsters"] = data_tmp[0]
            data["val"] = data_tmp[1]
            if data["val"] != 0:
                duel.cost_log += self.write_log(cost.log, user, data)
            if cost.pac:
                return self._pac_cost(cost.pac)
            else:
                if cost.cost_next:
                    return cost.cost_next
                else:
                    return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 9:
            data = {}
            cost_kind = cost.cost_kind
            data2 = self.change_monster_variable_eternal_cost(
                cost_unwrap.cost, cost_kind, cost_unwrap.cost_condition,cost_unwrap.change_val_monster_flag,cost_unwrap.accumulate_flag
            )
            data["monsters"] = data2[0]
            data["val"] = data2[1]
            duel.cost_log += self.write_log(cost.log, user,data)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 29:
            duel.cost_log += self.write_log(cost.log, user)
            self.change_variable_multiple_cost(cost)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 10:
            duel.cost_log += self.write_log(cost.log, user)
            self.shuffle_cost()
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 11:
            duel.cost_log += self.write_log(cost.log, user)
            self.clear_cost()
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 18:
            duel.cost_log += self.write_log(cost.log, user)
            self.move_effect_variable_to_timing(1)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 20:
            duel.cost_log += self.write_log(cost.log, user)
            self.cancel_cost()
            return -4
        elif cost_unwrap.cost_val == 21:
            duel.cost_log += self.write_log(cost.log, user)
            self.play_music(cost_unwrap.cost)
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
        elif cost_unwrap.cost_val == 68:
            duel.cost_log += self.write_log(cost.log, user)
            self.end_cost(user,org_chain,trigger,True)
            self.duel.in_cost_cancel = False
            if cost.pac:
                return self._pac_cost(cost.pac)
            elif cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)

    def play_music(self, music_name):
        self.duel.audio = music_name
        return
    def sound_effect_effect(self, monster_effect,cost = 0,user=None):
        duel = self.duel
        if user is None:
            if cost == 0:
                chain_user = json.loads(duel.chain_user)
                user = chain_user[str(duel.chain - 1)]
            elif cost == 1:
                chain_user = json.loads(duel.chain_user)
                user = chain_user[str(self.tmp_chain)]
            else:
                user = self.user
        data = monster_effect.split(",")
        sound_effect_id = str(uuid.uuid4())
        if(data[0] == "1"):
                if user == 1:
                        if self.duel.sound_effect_1 == "":
                            self.duel.sound_effect_1 = data[1] + "_" + sound_effect_id
                        else:    
                            self.duel.sound_effect_1 += ","+data[1] + "_" + sound_effect_id
                else:
                        if self.duel.sound_effect_2 == "":
                            self.duel.sound_effect_2 = data[1] + "_" + sound_effect_id
                        else:    
                            self.duel.sound_effect_2 += ","+data[1] + "_" + sound_effect_id
        elif(data[0] == "2"):
                if user == 2:
                        if self.duel.sound_effect_1 == "":
                            self.duel.sound_effect_1 = data[1] + "_" + sound_effect_id
                        else:    
                            self.duel.sound_effect_1 += ","+data[1] + "_" + sound_effect_id
                else:
                        if self.duel.sound_effect_2 == "":
                            self.duel.sound_effect_2 = data[1] + "_" + sound_effect_id
                        else:    
                            self.duel.sound_effect_2 += ","+data[1] + "_" + sound_effect_id
        elif(data[0] == "3"):
            if self.duel.sound_effect_1 == "":
                self.duel.sound_effect_1 = data[1] + "_" + sound_effect_id
            else:
                self.duel.sound_effect_1 += ","+data[1] + "_" + sound_effect_id
            if self.duel.sound_effect_2 == "":
                self.duel.sound_effect_2 = data[1] + "_" + sound_effect_id
            else:
                self.duel.sound_effect_2 += ","+data[1] + "_" + sound_effect_id
        return

    def win_the_game_by_time(self):
        duel = self.duel
        self.duel.end_time = time()
        self.turn_changed = True
        user = self.user
        if self.duel.winner == 0:
            self.duel.winner = user
            self.duel.save()
            if user == 1:
                if self.duel.user_1 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_1
                    user_point.win += 1
                    user_point.point += 5
                    user_point.save();
                if self.duel.user_2 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_2
                        user_point2.lose += 1
                        user_point2.save();
            elif user == 2:
                if self.duel.user_2 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_2
                    user_point.win += 1
                    user_point.point += 5
                    user_point.save();
                if self.duel.user_1 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_1
                        user_point2.lose += 1
                        user_point2.save();
    def win_the_game_user(self,user):
        duel = self.duel
        self.duel.end_time = time()
        self.turn_changed = True
        if self.duel.guest_flag is False:
            user1_name = duel.user_1.first_name
        else:    
            user1_name = duel.guest_name
        if self.duel.is_ai is False:
            if self.duel.guest_flag2 is False:
                user2_name = duel.user_2.first_name
            else:    
                user2_name = duel.guest_name2
        else:            
            user2_name = "NPC"
        if user == 1:
            duel.log_turn += user1_name+ "の勝ち"
            duel.log += user1_name+ "の勝ち"
        else:
            duel.log_turn += user2_name+ "の勝ち"
            duel.log += user2_name+ "の勝ち"
        if self.duel.winner == 0 and duel.is_ai is False:
            self.duel.winner = user
            self.duel.save()
            if user == 1:
                if self.duel.user_1 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point is None:
                         user_point = UserPoint()
                         user_point.user = self.duel.user_1
                    user_point.win += 1
                    user_point.point += 10
                    user_point.save();
                if self.duel.user_2 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_2
                    user_point2.lose += 1
                    user_point2.save();
            elif user == 2:
                if self.duel.user_2 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_2
                    user_point.win += 1
                    user_point.point += 10
                    user_point.save();
                if self.duel.user_1 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_1
                    user_point2.lose += 1
                    user_point2.save();
        elif self.duel.winner_ai == 0 and duel.is_ai is True:
            self.duel.winner_ai = user
            self.duel.save()
            if duel.user_1 is not None:
                user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                if user_point is None:
                    user_point = UserPoint()
                    user_point.user = self.duel.user_1
                user_point.point += 5
                user_point.win_ai += 1
                user_point.save();

    def win_the_game(self, cost=0):
        duel = self.duel
        self.duel.end_time = time()
        self.turn_changed = True
        if cost == 0:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        elif cost == 1:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        else:
            user = self.user
        if self.duel.winner == 0 and duel.is_ai is False:
            self.duel.winner = user
            self.duel.save()
            if user == 1:
                if self.duel.user_1 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point is None:
                         user_point = UserPoint()
                         user_point.user = self.duel.user_1
                    user_point.win += 1
                    user_point.point += 10
                    user_point.save();
                if self.duel.user_2 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_2
                    user_point2.lose += 1
                    user_point2.save();
            elif user == 2:
                if self.duel.user_2 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_2
                    user_point.win += 1
                    user_point.point += 10
                    user_point.save();
                if self.duel.user_1 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_1
                    user_point2.lose += 1
                    user_point2.save();
        elif self.duel.winner_ai == 0 and duel.is_ai is True:
            self.duel.winner_ai = user
            self.duel.save()
            if duel.user_1 is not None:
                user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                if user_point is None:
                    user_point = UserPoint()
                    user_point.user = self.duel.user_1
                user_point.point += 5
                user_point.win_ai += 1
                user_point.save();

    def draw_the_game(self, cost=0):
        self.turn_changed = True
        duel = self.duel
        self.duel.end_time = time()
        if cost == 0:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        elif cost == 1:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        else:
            user = self.user
        if self.duel.winner == 0:
            self.duel.winner = 3
            self.duel.save()
        if duel.user_1 is not None:
            user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
            if user_point is None:
                user_point = UserPoint()
                user_point.user = self.duel.user_1
            user_point.draw += 1
            user_point.save()
        if duel.user_2 is not None:
            user_point2 = UserPoint.objects.filter(user = self.duel.user_2).first()
            if user_point2 is None:
                user_point2 = UserPoint()
                user_point2.user = self.duel.user_2
            user_point2.draw += 1
            user_point2.save()
        return

    def lose_the_game_by_time(self):
        self.turn_changed = True
        duel = self.duel
        self.duel.end_time = time()
        user = self.user
        if self.duel.winner == 0 and duel.is_ai is False:
            if user == 1:
                self.duel.winner = 2
            elif user == 2:
                self.duel.winner = 1
            self.duel.save()
            if user == 2:
                if duel.user_1 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_1
                    user_point.win += 1
                    user_point.point += 5
                    user_point.save();
                if duel.user_2 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_2
                    user_point2.lose += 1
                    user_point2.save();
            elif user == 1:
                if duel.user_2 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_2
                    user_point.win += 1
                    user_point.point += 5
                    user_point.save();
                if duel.user_1 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_1
                    user_point2.lose += 1
                    user_point2.save();
        elif self.duel.winner_ai == 0 and duel.is_ai is True:
            if user == 1:
                self.duel.winner_ai = 2
            elif user == 2:
                self.duel.winner_ai = 1
                user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                if user_point is None:
                    user_point = UserPoint()
                    user_point.user = self.duel.user_1
                user_point.win_ai += 1
                user_point.point += 5
                user_point.save();
            self.duel.save()
        return
    def lose_the_game(self, cost=0):
        self.turn_changed = True
        duel = self.duel
        self.duel.end_time = time()
        if cost == 0:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        elif cost == 1:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        else:
            user = self.user
        if self.duel.winner == 0 and duel.is_ai is False:
            if user == 1:
                self.duel.winner = 2
            elif user == 2:
                self.duel.winner = 1
            self.duel.save()
            if user == 2:
                if duel.user_1 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_1
                    user_point.win += 1
                    user_point.point += 10
                    user_point.save();
                if duel.user_2 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_2
                    user_point2.lose += 1
                    user_point2.save();
            elif user == 1:
                if duel.user_2 is not None:
                    user_point = UserPoint.objects.filter(user = self.duel.user_2).first()
                    if user_point is None:
                        user_point = UserPoint()
                        user_point.user = self.duel.user_2
                    user_point.win += 1
                    user_point.point += 10
                    user_point.save();
                if duel.user_1 is not None:
                    user_point2 = UserPoint.objects.filter(user = self.duel.user_1).first()
                    if user_point2 is None:
                        user_point2 = UserPoint()
                        user_point2.user = self.duel.user_1
                    user_point2.lose += 1
                    user_point2.save();
        elif self.duel.winner_ai == 0 and duel.is_ai is True:
            if user == 1:
                self.duel.winner_ai = 2
            elif user == 2:
                user_point = UserPoint.objects.filter(user = self.duel.user_1).first()
                if user_point is None:
                    user_point = UserPoint()
                    user_point.user = self.duel.user_1
                user_point.win_ai += 1
                user_point.point += 5
                user_point.save();
                self.duel.winner_ai = 1
            self.duel.save()
        return

    def cancel_cost(self):
        duel = self.duel
        in_pac = json.loads(duel.in_pac)
        in_pac[str(duel.chain - 1)] = []
        duel.cost_log = ""
        duel.in_cost = False
        self.in_execute = False
        duel.in_pac_cost = "[]"
        cost = self.cost
        if duel.chain == 0:
            del cost[str(self.tmp_chain)]
        elif duel.chain >0:
            del cost[str(duel.chain)]
        self.cost = cost
        self.cost_result = {}
        duel.ask = 0
        duel.canbechained = True
        '''
        if duel.chain > 0:
            chain_det_trigger_json = json.loads(duel.chain_det_trigger)
            del chain_det_trigger_json[str(duel.chain)]
            duel.chain_det_trigger = json.dumps(chain_det_trigger_json)
            trigger_id = chain_det_trigger_json[str(duel.chain - 1)]
            trigger = Trigger.objects.get(id=trigger_id)
            if trigger.pac:
                in_pac[str(duel.chain - 1)].append(trigger.pac.id)
                duel.in_pac = json.dumps(in_pac)
        '''
        self.duel.tmponce_per_turn1  = ""           
        self.duel.tmponce_per_turn_group1 = ""
        self.duel.tmponce_per_turn_group2 = ""
        self.duel.tmponce_per_turn_monster_group1 = ""
        self.duel.tmponce_per_turn_monster_group2 = ""
        self.duel.tmponce_per_turn2 = ""
        self.duel.tmponce_per_turn_monster1 = ""
        self.duel.tmponce_per_turn_monster2 = ""
        self.duel.tmponce_per_turn_exist1 = ""
        self.duel.tmponce_per_turn_exist2 = ""
        self.duel.tmponce_per_turn_relate1 = ""
        self.duel.tmponce_per_turn_relate2 = ""
        self.mess[str(self.duel.chain)] = []
        return
    def check_monster_effect_timing_and_phase_condition(self, monster_effect_condition):

        duel = self.duel
        if "check_phase" in monster_effect_condition:
            check_phases = str(monster_effect_condition["check_phase"]).split("_")
            flag = False
            for check_phase in check_phases:
                if duel.phase.id == int(check_phase):
                    flag = True
            if flag is False:
                return False
        if "check_timing" in monster_effect_condition:
            check_timings = str(monster_effect_condition["check_timing"]).split("_")
            flag = False
            for check_timing in check_timings:
                if duel.timing is None:
                    0 == int(check_timing)
                elif duel.timing.id == int(check_timing):
                    flag = True
            if flag is False:
                return False
        if "check_timing2" in monster_effect_condition:
            check_timings2 = str(monster_effect_condition["check_timing2"]).split("_")
            flag = False
            for check_timing2 in check_timings2:
                if duel.timing2.id == int(check_timing2):
                    flag = True
            if flag is False:
                return False
        if "check_timing3" in monster_effect_condition:
            check_timings3 = str(monster_effect_condition["check_timing3"]).split("_")
            flag = False
            for check_timing3 in check_timings3:
                if duel.timing3.id == int(check_timing3):
                    flag = True
            if flag is False:
                return False
        return True

    def check_cost_condition(self, cost_condition, cost_kind):
        return self.check_monster_effect_condition(cost_condition, cost_kind, 1)

    def check_monster_effect_condition(
        self, monster_effect_condition, effect_kind="", cost=0
    ):
        duel = self.duel
        if cost == 0:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
        elif cost == 1:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
        else:
            user = self.user
        if "monster" in monster_effect_condition:
            if "choose" in monster_effect_condition:
                choose = monster_effect_condition["choose"]
            else:
                choose = 0
            excludes = False
            if "exclude" in monster_effect_condition:
                exclude = monster_effect_condition["exclude"]
                if exclude:
                    excludes = exclude.split(",")
            if (
                self.check_monster_condition(
                    monster_effect_condition["monster"],
                    user,
                    False,
                    None,
                    excludes,
                    choose,
                    effect_kind,
                )
                is False
            ):
                return False
        if "variable" in monster_effect_condition:
            variable_flag = True
            current_and_or = "and"
            for key in range(len(monster_effect_condition["variable"])):
                variable_condition = monster_effect_condition
                variable = monster_effect_condition["variable"][key]["variable"]
                variable = variable.split("_")
                mine_or_other = int(variable[2])
                variable_name = variable[1]
                variable = json.loads(duel.global_variable)
                virtual_variables = self.virtual_variables
                variable.update(virtual_variables)
                if variable_name == "chain":
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not duel.virtual_chain == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not duel.virtual_chain <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not duel.virtual_chain >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not duel.virtual_chain != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif variable_name == "turncount":
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not duel.turn_count == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not duel.turn_count <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not duel.turn_count >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not duel.turn_count != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif mine_or_other == 0:
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not variable[variable_name][
                            "value"
                        ] == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not variable[variable_name][
                            "value"
                        ] <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not variable[variable_name][
                            "value"
                        ] >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not variable[variable_name][
                            "value"
                        ] != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif (
                    mine_or_other == 1 and user == 1 or mine_or_other == 2 and user == 2
                ):
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not variable[variable_name][
                            "1_value"
                        ] == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not variable[variable_name][
                            "1_value"
                        ] <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not variable[variable_name][
                            "1_value"
                        ] >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not variable[variable_name][
                            "1_value"
                        ] != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                elif (
                    mine_or_other == 2 and user == 1 or mine_or_other == 1 and user == 2
                ):
                    if variable_condition["variable"][key]["variable_equation"] == "=":
                        if not variable[variable_name][
                            "2_value"
                        ] == self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "<="
                    ):
                        if not variable[variable_name][
                            "2_value"
                        ] <= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == ">="
                    ):
                        if not variable[variable_name][
                            "2_value"
                        ] >= self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                    elif (
                        variable_condition["variable"][key]["variable_equation"] == "!="
                    ):
                        if not variable[variable_name][
                            "2_value"
                        ] != self.calculate_boland(
                            variable_condition["variable"][key]["variable_val"]
                        ):
                            if current_and_or == "and" or variable_flag is False:
                                variable_flag = False
                        else:
                            if current_and_or == "or" or variable_flag is True:
                                variable_flag = True
                current_and_or = variable_condition["variable"][key]["and_or"]
        return variable_flag

    def pop_pac_cost(self, user):
        duel = self.duel
        if duel.in_pac_cost == "[]":
            return -2
        pac = json.loads(duel.in_pac_cost)

        pac_id = pac.pop()
        duel.in_pac_cost = json.dumps(pac)
        pac = PacCostWrapper.objects.get(id=pac_id)
        duel.cost_log += self.write_log(pac.log, user)
        if pac.pac_next is not None:
            return self._pac_cost(pac.pac_next)
        if pac.cost_next is None:
            return -2
        else:
            return pac.cost_next

    def pop_pac_cost2(self, user):
        duel = self.duel
        if duel.in_pac_cost == "[]":
            return -2
        pac = json.loads(duel.in_pac_cost)

        pac_id = pac.pop()
        duel.in_pac_cost = json.dumps(pac)
        pac = PacCostWrapper.objects.get(id=pac_id)
        duel.cost_log += self.write_log(pac.log, user)
        if pac.pac_next2 is not None:
            return self._pac_cost(pac.pac_next2)
        if pac.cost_next2 is None:
            return -2
        else:
            return pac.cost_next2

    def get_pac_effect_kind(self):
        duel = self.duel
        pac = json.loads(duel.in_pac)
        if str(self.duel.chain - 1) in pac and len(pac[str(duel.chain - 1)]) > 0:
            pac = pac[str(self.duel.chain - 1)]
            pac_id = pac[0]
            pac = PacWrapper.objects.get(id=pac_id)
        else:
            return None
        if pac.monster_effect_kind == "":
            return None
        else:
            return pac.monster_effect_kind

    def get_pac_cost_effect_kind(self):
        duel = self.duel
        if duel.in_pac_cost == "[]":
            return None
        pac = json.loads(duel.in_pac_cost)
        pac_id = pac[0]
        pac = PacCostWrapper.objects.get(id=pac_id)
        if pac.monster_effect_kind == "":
            return None
        else:
            return pac.monster_effect_kind

    def pop_pac(self, user):
        duel = self.duel
        pac = json.loads(duel.in_pac)
        if str(duel.chain - 1) not in pac or len(pac[str(duel.chain - 1)]) == 0:
            return -2
        pac_id = pac[str(duel.chain - 1)].pop()
        duel.in_pac = json.dumps(pac)
        pac = PacWrapper.objects.get(id=pac_id)
        log_tmp = self.write_log(pac.log, user)
        duel.log_turn += log_tmp
        duel.log += log_tmp
        self.current_log += log_tmp
        if pac.pac_next is not None:
            return self._pac(pac.pac_next)
        if pac.monster_effect_next is None:
            return -2
        else:
            return pac.monster_effect_next

    def pop_pac2(self, user):
        duel = self.duel
        pac = json.loads(duel.in_pac)
        if str(duel.chain - 1) not in pac or len(pac[str(duel.chain - 1)]) == 0:
            return -2

        pac_id = pac[str(duel.chain - 1)].pop()
        duel.in_pac = json.dumps(pac)
        pac = PacWrapper.objects.get(id=pac_id)
        log_tmp = self.write_log(pac.log, user)
        duel.log_turn += log_tmp
        duel.log += log_tmp
        self.current_log += log_tmp
        if pac.pac_next2 is not None:
            return self._pac(pac.pac_next2)
        if pac.monster_effect_next2 is None:
            return -2
        else:
            return pac.monster_effect_next2

    def _pac(self, effect_pac, chain=None,flag = 0):
        if flag == 1:
            return effect_pac.pac.pac_next
        duel = self.duel
        pac = json.loads(duel.in_pac)
        if chain is None:
            chain = duel.chain - 1
        if str(chain) not in pac or len(pac[str(chain)]) == 0:
            pac[str(chain)] = []
        pac[str(chain)].append(effect_pac.id)
        duel.in_pac = json.dumps(pac)
        return effect_pac.pac.pac_next

    def _pac_cost(self, cost_pac):
        duel = self.duel
        pac = json.loads(duel.in_pac_cost)
        pac.append(cost_pac.id)
        duel.in_pac_cost = json.dumps(pac)
        return cost_pac.pac_cost.pac_cost_next

    def get_trigger_monster(self):
        duel = self.duel
        mess = self.mess
        if str(duel.chain - 1) not in mess:
            return None
        if 0 not in mess[str(duel.chain - 1)]:
            return None
        trigger = mess[str(duel.chain - 1)][0]
        return trigger

    def do_immidiate_trigger(self,trigger,user):
        duel = self.duel
        monster_effect = trigger.next_effect
        monster_effect_unwrap = monster_effect.monster_effect
        if monster_effect_unwrap.monster_effect_val == 60:
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.sound_effect_effect(monster_effect.monster_effect.monster_effect,2,user)
            return
    def check_invoke_monster_effect(
        self,
        monster,
        user,
        effect_kind,
        place,
        deck_id,
        x,
        y,
        mine_or_other,
        monster_from,
        place_from,
        deck_id_from,
        from_x,
        from_y,
    ):
        if self.check_invoke_invalid(
            monster, user, effect_kind, place, deck_id, x, y, mine_or_other
        ):
            return False
        if self.check_invoke_invalid(
            monster_from,
            user,
            effect_kind,
            place_from,
            deck_id_from,
            from_x,
            from_y,
            mine_or_other,
            1,
        ):
            return False
        return True

    def invoke_no_chain_effect(self, monster_effect, user, other_user, kinds):
        duel = self.duel
        user = self.user

        while monster_effect:
            if duel.winner != 0 or duel.winner_ai != 0:
                return
            # monster_effect_unwrapは効果の実体
            monster_effect_unwrap = monster_effect.monster_effect
            if monster_effect_unwrap.monster_effect_val == 0:
                monster_effect_condition = json.loads(
                    monster_effect.monster_effect.monster_condition
                )
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = monster_effect.monster_effect_kind
                if self.check_monster_effect_condition(
                    monster_effect_condition, effect_kind, 2
                ):
                    monster_effect = monster_effect.monster_effect_next
                else:
                    monster_effect = monster_effect.monster_effect_next2

            elif (
                monster_effect_unwrap.monster_effect_val == 5
                or monster_effect_unwrap.monster_effect_val == 4
                or monster_effect_unwrap.monster_effect_val == 3
            ):
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                if self.duel.ask > 0:
                    duel.in_eternal = True
                    effect_kind = monster_effect.monster_effect_kind
                    self.duel.ask_kind = effect_kind
                    self.duel.ask_det = monster_effect_unwrap.monster_effect
                    return -1

                else:
                    monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 17:
                effect_kind = monster_effect.effect_kind()
                if effect_kind is None:
                    effect_kind = monster_effect.monster_effect_kind
                move_to = self.move_from_monster_simple_eternal(
                    effect_kind, user, monster_effect
                )
                log_tmp = self.write_log(monster_effect.log, user, move_to)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp

                if move_to is not None:
                    self.move_to_monster_eternal(
                        move_to, effect_kind, user, monster_effect
                    )
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 1:
                effect_kind = self.get_pac_effect_kind()
                if effect_kind is None:
                    effect_kind = monster_effect.monster_effect_kind
                move_to = self.move_from_monster_eternal(
                    effect_kind, user, monster_effect
                )
                if move_to is not None:
                    self.move_to_monster_eternal(
                        move_to, effect_kind, user, monster_effect
                    )
                data = {}
                data["monsters"] = move_to
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 40:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = self.get_pac_effect_kind()
                if effect_kind is None:
                    effect_kind = monster_effect.monster_effect_kind
                move_to = self.move_from_monster_relation(effect_kind)

                if move_to is not None:
                    self.move_to_monster(move_to, effect_kind)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 33:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = monster_effect.monster_effect_kind
                self.clear_relation(
                    monster_effect_unwrap.monster_effect,
                    effect_kind,
                    monster_effect_unwrap.monster_condition,
                )
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            elif monster_effect_unwrap.monster_effect_val == 7:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.move_phase()
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 37:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = monster_effect.monster_effect_kind
                return self.copy_effect(monster_effect_unwrap, effect_kind)
            elif monster_effect_unwrap.monster_effect_val == 46:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = monster_effect.monster_effect_kind
                return self.copy_effect2(monster_effect_unwrap, effect_kind)
            elif monster_effect_unwrap.monster_effect_val == 8:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.change_turn(monster_effect_unwrap)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 2:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.change_variable(2,monster_effect_unwrap)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 9:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = monster_effect.monster_effect_kind
                self.change_monster_variable_eternal(
                    monster_effect_unwrap.monster_effect,
                    effect_kind,
                    monster_effect_unwrap.monster_condition,
                    monster_effect_unwrap.change_val_monster_flag,
                    monster_effect_unwrap.accumulate_flag,
                    

                )
            elif monster_effect_unwrap.monster_effect_val == 29:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.change_variable_multiple(0, user, monster_effect)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 25:
                effect_kind = monster_effect.monster_effect_kind
                return_value = self.change_monster_relation(
                    monster_effect_unwrap.monster_effect,
                    effect_kind,
                    monster_effect_unwrap.monster_condition,
                )
                log_tmp = self.write_log_change_monster_relation(
                    monster_effect.log, return_value
                )
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 32:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                effect_kind = monster_effect.monster_effect_kind
                effect_kind_rel = monster_effect.monster_effect_kind_rel
                self.change_monster_variable_relation(
                    monster_effect_unwrap.monster_effect,
                    effect_kind,
                    monster_effect_unwrap.monster_condition,
                    effect_kind_rel,
                )
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 10:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.shuffle()
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 11:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.clear()
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 12:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.raise_by_monster_effect()
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 13:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.change_appointment()
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 14:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                monster_effect_text = json.loads(
                    monster_effect.monster_effect.monster_effect
                )
                timing = Timing.objects.get(
                    id=int(monster_effect_text["move_to_timing"])
                )
                if "timing_fresh" in monster_effect_text:
                    fresh= monster_effect_text["timing_fresh"]
                else:
                    fresh= True
                self.change_timing(timing.id,fresh,int(monster_effect_text["t_num"]))
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 19:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                if duel.timing3 is not None:
                    self.expire_timing(duel.timing3,duel.timing3.next_timing, duel.user_turn)
                    duel.timing3 = duel.timing3.next_timing
                elif duel.timing2 is not None:
                    self.expire_timing(duel.timing2,duel.timing2.next_timing, duel.user_turn)
                    duel.timing2 = duel.timing2.next_timing
                elif duel.timing is not None:
                    self.expire_timing(duel.timing,duel.timing.next_timing, duel.user_turn)
                    duel.timing = duel.timing.next_timing
                    
                if duel.timing is None and duel.timing2 is None and duel.timing3 is None:
                    self.timing_mess = {}
                monster_effect = monster_effect.monster_effect_next

            elif monster_effect_unwrap.monster_effect_val == 18:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.move_effect_variable_to_timing(0)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 60:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.sound_effect_effect(monster_effect.monster_effect.monster_effect,-1)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 61:
                self.change_appoint(monster_effect.monster_effect.monster_effect)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 21:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.play_music(monster_effect.monster_effect.monster_effect)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 22:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.win_the_game(2)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 23:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.lose_the_game(2)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 47:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.draw_the_game(2)
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 30:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.select_multiple()
                monster_effect = monster_effect.monster_effect_next
            elif monster_effect_unwrap.monster_effect_val == 31:
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                self.select_multiple_other()
                monster_effect = monster_effect.monster_effect_next
        return 0

    def invoke_monster_effect(self, monster_effect, decks, graves, kinds):

        duel = self.duel
        trigger_info = self.get_trigger_monster()
        chain_user = json.loads(duel.chain_user)
        user = chain_user[str(duel.chain - 1)]
        if user == 1:
            other_user = 2
        elif user == 2:
            other_user = 1
        if trigger_info is None:
            trigger_det = None
            trigger_place = None
            trigger_deck_id = 0
            trigger_x = 0
            trigger_y = 0
            trigger_det_from = None
            trigger_place_from = None
            trigger_deck_id_from = 0
            trigger_from_x = 0
            trigger_from_y = 0

        if not self.check_invoke_monster_effect(
            trigger_det,
            user,
            kinds,
            trigger_place,
            trigger_deck_id,
            trigger_x,
            trigger_y,
            1,
            trigger_det_from,
            trigger_place_from,
            trigger_deck_id_from,
            trigger_from_x,
            trigger_from_y,
        ):
            return self.do_next(monster_effect,user)
        strategy = monster_effect.strategy
        strategy_up_or_down = monster_effect.strategy_up_or_down
        monster_effect_unwrap = monster_effect.monster_effect
        if monster_effect_unwrap.monster_effect_val == 22:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.win_the_game(2)
            monster_effect = monster_effect.monster_effect_next
        elif monster_effect_unwrap.monster_effect_val == 23:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.lose_the_game(2)
            monster_effect = monster_effect.monster_effect_next
        elif monster_effect_unwrap.monster_effect_val == 47:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.draw_the_game(2)
            monster_effect = monster_effect.monster_effect_next
        if monster_effect_unwrap.monster_effect_val == 62:
            if self.each(monster_effect_unwrap.monster_effect) is True:

                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2 is None:
                        return self.pop_pac2(user)
                    else:
                        return monster_effect.monster_effect_next2
        if monster_effect_unwrap.monster_effect_val == 79:
            multiple_json = json.loads(monster_effect_unwrap.monster_effect)
            rand_i = random.randrange(len((multiple_json["monster_effect_wrapper"])))
            return MonsterEffectWrapper.objects.get(id=int(multiple_json["monster_effect_wrapper"][rand_i]))
        elif monster_effect_unwrap.monster_effect_val == 45:
            rand_i = random.randrange(2)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if rand_i == 0:

                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2 is None:
                        return self.pop_pac2(user)
                    else:
                        return monster_effect.monster_effect_next2
        elif monster_effect_unwrap.monster_effect_val == 53:
            result = self.check_alt_val(
                monster_effect_unwrap.monster_effect, monster_effect.monster_effect_kind
            )
            if result:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2 is None:
                        return self.pop_pac2(user)
                    else:
                        return monster_effect.monster_effect_next2
        if monster_effect_unwrap.monster_effect_val == 42:
            duel.mute = 1
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 52:
            change_val = self.flush_acc(monster_effect_unwrap)
            data = {}
            data["val"] = change_val
            if change_val != 0:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 41:
            monster_effect_condition = json.loads(monster_effect_unwrap.monster_effect)
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if self.check_monster_effect_timing_and_phase_condition(
                monster_effect_condition
            ):

                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2 is None:
                        return self.pop_pac2(user)
                    else:
                        return monster_effect.monster_effect_next2
        if monster_effect_unwrap.monster_effect_val == 0:
            monster_effect_condition = json.loads(
                monster_effect_unwrap.monster_condition
            )
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if self.check_monster_effect_condition(monster_effect_condition):
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        tmp = self.pop_pac(user)
                        return tmp
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2 is None:
                        return self.pop_pac2(user)
                    else:
                        return monster_effect.monster_effect_next2
        if monster_effect_unwrap.monster_effect_val == 43:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            next_effect = self.get_next_effect(
                monster_effect_unwrap.monster_effect, user
            )
            return next_effect
        if monster_effect_unwrap.monster_effect_val == 5:
            duel.ask = 0
            effect_kind = monster_effect.monster_effect_kind
            monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
            whether_monster = monster_effect_text["whether_monster"]
            exclude = monster_effect_text["exclude"]
            monster_effect_text = monster_effect_text["monster"][0]
            min = self.calculate_boland(monster_effect_text["min_equation_number"])
            max = self.calculate_boland(monster_effect_text["max_equation_number"])
            if min != 0 or max != 0:
                if self.check_monster_exists(
                    monster_effect_text,
                    min,
                    max,
                    user,
                    effect_kind,
                    0,
                    whether_monster,
                    exclude,
                ):
                    self.duel.ask_kind = effect_kind
                    if duel.is_ai is False:
                        if duel.user_turn == user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                    else:
                        if duel.user_turn == user:
                            if user == 1:
                                self.duel.ask = 1
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
                        else:
                            if user == 1:
                                self.duel.ask = 2
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
            monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
            whether_monster = monster_effect_text["whether_monster"]
            exclude = monster_effect_text["exclude"]
            monster_effect_text = monster_effect_text["monster"][1]
            min = self.calculate_boland(monster_effect_text["min_equation_number"])
            max = self.calculate_boland(monster_effect_text["max_equation_number"])
            if min != 0 or max != 0:
                if self.check_monster_exists(
                    monster_effect_text,
                    min,
                    max,
                    other_user,
                    effect_kind,
                    0,
                    whether_monster,
                    exclude,
                ):
                    self.duel.ask_kind = effect_kind
                    if duel.is_ai is False :
                        if duel.user_turn == user:
                            self.duel.ask += 2
                        else:
                            self.duel.ask += 1
                    else:
                        if duel.user_turn == other_user:
                            if other_user == 1:
                                self.duel.ask += 1
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
                        else:
                            if other_user == 1:
                                self.duel.ask += 2
                            else:
                                self.answer_ai(strategy,strategy_up_or_down)
            if duel.ask == 0:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 54:
            effect_kind = monster_effect.monster_effect_kind
        elif monster_effect_unwrap.monster_effect_val == 57 or monster_effect_unwrap.monster_effect_val == 65  :
            effect_kind = monster_effect.monster_effect_kind
            if duel.user_turn == 1 or duel.is_ai is False:
                self.duel.ask = 1
            else:
                self.answer_ai(strategy,strategy_up_or_down)
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 55:
            effect_kind = monster_effect.monster_effect_kind
            if duel.user_turn == 2 or duel.is_ai is False:
                self.duel.ask = 2
            else:
                self.answer_ai(strategy,strategy_up_or_down)
                if monster_effect.pac:
                    return self._pac(monster_effect.pac,None)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 3:
            effect_kind = monster_effect.monster_effect_kind
            monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
            whether_monster = monster_effect_text["whether_monster"]
            exclude = monster_effect_text["exclude"]
            monster_effect_text = monster_effect_text["monster"][0]
            min = self.calculate_boland(monster_effect_text["min_equation_number"])
            max = self.calculate_boland(monster_effect_text["max_equation_number"])
            if min != 0 or max != 0:
                if self.check_monster_exists(
                    monster_effect_text,
                    min,
                    max,
                    user,
                    effect_kind,
                    0,
                    whether_monster,
                    exclude,
                ):
                    self.duel.ask_kind = effect_kind
                    if duel.is_ai is False or user == 1:
                        if duel.user_turn == user:
                            self.duel.ask = 1
                        else:
                            self.duel.ask = 2
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
                        if monster_effect.pac:
                            return self._pac(monster_effect.pac,None)
                        else:
                            if monster_effect.monster_effect_next is not None:
                                return monster_effect.monster_effect_next
                            else:
                                return self.pop_pac(user)
                else:
                    return self.do_next(monster_effect,user)
            else:
                return self.do_next(monster_effect,user)
        elif monster_effect_unwrap.monster_effect_val == 4:
            effect_kind = monster_effect.monster_effect_kind
            monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
            whether_monster = monster_effect_text["whether_monster"]
            exclude = monster_effect_text["exclude"]
            monster_effect_text = monster_effect_text["monster"][0]
            min = self.calculate_boland(
                monster_effect_text["min_equation_number"], None, True,eternal=True
            )
            max = self.calculate_boland(
                monster_effect_text["max_equation_number"], None, True,eternal=True
            )
            if min != 0 or max != 0:
                if self.check_monster_exists(
                    monster_effect_text,
                    min,
                    max,
                    other_user,
                    effect_kind,
                    0,
                    whether_monster,
                    exclude,
                ):
                    self.duel.ask_kind = effect_kind
                    if duel.is_ai is False or user == 2:
                        if duel.user_turn == user:
                            self.duel.ask = 2
                        else:
                            self.duel.ask = 1
                    else:
                        self.answer_ai(strategy,strategy_up_or_down)
                        if monster_effect.pac:
                            return self._pac(monster_effect.pac,None)
                        else:
                            if monster_effect.monster_effect_next is not None:
                                return monster_effect.monster_effect_next
                            else:
                                return self.pop_pac(user)
                else:
                    return self.do_next(monster_effect,user)
            else:
                return self.do_next(monster_effect,user)
        elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 66:
            effect_kind = monster_effect.monster_effect_kind
            self.duel.ask_kind = effect_kind
            if duel.is_ai is False or user == 1:
                if duel.user_turn == user:
                    self.duel.ask = 1
                else:
                    self.duel.ask = 2
            else:
                self.answer_ai(strategy,strategy_up_or_down)
                if monster_effect.pac:
                    return self._pac(monster_effect.pac,None)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 26 or monster_effect_unwrap.monster_effect_val == 16 or monster_effect_unwrap.monster_effect_val == 67 :
            effect_kind = monster_effect.monster_effect_kind
            self.duel.ask_kind = effect_kind
            if duel.is_ai is False or user == 2:
                if duel.user_turn == user:
                    self.duel.ask = 2
                else:
                    self.duel.ask = 1
            else:
                self.answer_ai(strategy,strategy_up_or_down)
                if monster_effect.pac:
                    return self._pac(monster_effect.pac,None)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 27 or monster_effect_unwrap.monster_effect_val == 63:
            effect_kind = monster_effect.monster_effect_kind
            monster_effect_text = json.loads(monster_effect_unwrap.monster_effect)
            min = self.calculate_boland(monster_effect_text["min_equation_number"])
            max = self.calculate_boland(monster_effect_text["max_equation_number"])
            if min != 0 or max != 0:
                self.duel.ask_kind = effect_kind
                if duel.is_ai is False or user == 1:
                    if duel.user_turn == user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
                    if monster_effect.pac:
                        return self._pac(monster_effect.pac<None)
                    else:
                        if monster_effect.monster_effect_next is not None:
                            return monster_effect.monster_effect_next
                        else:
                            return self.pop_pac(user)
            else:
                return self.do_next(monster_effect,user)
        elif monster_effect_unwrap.monster_effect_val == 28 or monster_effect_unwrap.monster_effect_val == 64:
            effect_kind = monster_effect.monster_effect_kind
            monster_effect_text = json.loads(
                monster_effect.monster_effect.monster_effect
            )
            min = self.calculate_boland(monster_effect_text["min_equation_number"],None,True)
            max = self.calculate_boland(monster_effect_text["max_equation_number"],None,True)
            if min != 0 or max != 0:
                self.duel.ask_kind = effect_kind
                if duel.is_ai is False or user == 2:
                    if duel.user_turn == user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
                    if monster_effect.pac:
                        return self._pac(monster_effect.pac,None)
                    else:
                        if monster_effect.monster_effect_next is not None:
                            return monster_effect.monster_effect_next
                        else:
                            return self.pop_pac(user)
            else:
                return self.do_next(monster_effect,user)
        elif monster_effect_unwrap.monster_effect_val == 30:
            effect_kind = monster_effect.monster_effect_kind
            monster_condition = monster_effect_unwrap.monster_condition
            if monster_condition != "":
                monster_condition = json.loads(monster_condition)
                monster_condition = monster_condition["monster"][0]["monster"]
            monster_effect_text_org = json.loads(monster_effect_unwrap.monster_effect)
            if(self.check_multiple(user,effect_kind,monster_effect_text_org,monster_condition)):
                self.duel.ask_kind = effect_kind
                if duel.is_ai is False or user == 1:

                    if duel.user_turn == user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
                    if monster_effect.pac:
                        return self._pac(monster_effect.pac,None)
                    else:
                        if monster_effect.monster_effect_next is not None:
                            return monster_effect.monster_effect_next
                        else:
                            return self.pop_pac(user)
            else:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 31:
            effect_kind = monster_effect.monster_effect_kind
            monster_condition = monster_effect_unwrap.monster_condition
            if monster_condition != "":
                monster_condition = json.loads(monster_condition)
                monster_condition = monster_condition["monster"][0]["monster"]
            monster_effect_text_org = json.loads(monster_effect_unwrap.monster_effect)
            if(self.check_multiple(other_user,effect_kind,monster_effect_text_org,monster_condition)):
                self.duel.ask_kind = effect_kind
                if duel.is_ai is False or user == 2:
                    if duel.user_turn == user:
                        self.duel.ask = 2
                    else:
                        self.duel.ask = 1
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
                    if monster_effect.pac:
                        return self._pac(monster_effect.pac,None)
                    else:
                        if monster_effect.monster_effect_next is not None:
                            return monster_effect.monster_effect_next
                        else:
                            return self.pop_pac(user)
            else:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 59:
            effect_kind = monster_effect.monster_effect_kind
            det = json.loads(monster_effect.monster_effect.monster_effect)
            deck_id = det["deck_id"]
            ignore_timing = det["ignore_timing"]
            force_flag =  self.check_force(
                user, effect_kind, deck_id,ignore_timing
            )
            if force_flag is None:
                self.duel.ask_kind = effect_kind

                if duel.is_ai is False or user == 1:
                    if duel.user_turn == user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                else:
                    self.answer_ai(strategy,strategy_up_or_down)
                    if monster_effect.pac:
                        return self._pac(monster_effect.pac,None)
                    else:
                        if monster_effect.monster_effect_next is not None:
                            return monster_effect.monster_effect_next
                        else:
                            return self.pop_pac(user)
            else:
                log_tmp=""
                for tmp in force_flag:
                    log_tmp += "("+tmp["det"]["monster_name"]+")"

                log_tmp += "\n手札に使用可能なカードがなかった"
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        if self.duel.ask > 0:
            effect_kind = monster_effect.monster_effect_kind
            pac = json.loads(self.duel.in_pac)
            if str(duel.chain - 1) in pac and len(pac[str(duel.chain - 1)]) > 0:
                pac = pac[str(duel.chain - 1)]
                pac_id = pac.pop()
                pac = PacWrapper.objects.get(id=pac_id)
                if pac.monster_effect_kind != "":
                    effect_kind = pac.monster_effect_kind
            self.duel.ask_kind = effect_kind
            self.duel.ask_det = monster_effect_unwrap.monster_effect
            return -1

        if monster_effect_unwrap.monster_effect_val == 0:
            monster_effect_condition = json.loads(
                monster_effect.monster_effect.monster_condition
            )
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            effect_kind = monster_effect.monster_effect_kind
            if self.check_monster_effect_condition(
                monster_effect_condition, effect_kind
            ):

                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next is not None:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2 is None:
                        return self.pop_pac2(user)
                    else:
                        return monster_effect.monster_effect_next2
        elif monster_effect_unwrap.monster_effect_val == 43:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            next_effect = self.get_next_effect(
                monster_effect_unwrap.monster_effect, user
            )
            return next_effect
        elif monster_effect_unwrap.monster_effect_val == 56:
            self.clear_mess(monster_effect_unwrap.monster_effect) 
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 58:
            self.reload_mess(monster_effect_unwrap.monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 69:
            self.reload2_mess(monster_effect_unwrap.monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 51:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.move_from_monster_under(effect_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp

            if move_to is not None:
                self.move_to_monster(move_to, effect_kind)
            if monster_effect.if_not_to_2 is False or move_to:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2:
                        return monster_effect.monster_effect_next2
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 17:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.move_from_monster_simple(effect_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp

            if move_to is not None:
                self.move_to_monster(move_to, effect_kind)
            if monster_effect.if_not_to_2 is False or move_to:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2:
                        return monster_effect.monster_effect_next2
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 50:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.move_from_monster(effect_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if move_to is not None:
                self.move_to_over_monster(move_to, effect_kind)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 36:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.move_from_monster(effect_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if move_to is not None:
                self.move_to_under_monster(move_to, effect_kind)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 6:
                self.get_effect(monster_effect, user)
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 76:
            chain_det_ary = json.loads(self.duel.chain_det_trigger)
            chain_det = chain_det_ary[str(self.duel.chain - 1)]
            trigger = Trigger.objects.get(id=chain_det)
            if self.get_fusion_monster(trigger.fusion_monster, user, trigger,1,1):
                if duel.is_ai is False or user == 1:
                    if duel.user_turn == user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                    return -1
                else:
                    if self.answer_ai(strategy,strategy_up_or_down):
                        if monster_effect.pac:
                            return self._pac(monster_effect.pac,None)
                        else:
                            if monster_effect.monster_effect_next is not None:
                                return monster_effect.monster_effect_next
                            else:
                                return self.pop_pac(user)
                    return self.do_next(monster_effect,user)
            else:
                return self.do_next(monster_effect,user)
        elif monster_effect_unwrap.monster_effect_val == 78:
            return self.unique_fusion_effect()
        elif monster_effect_unwrap.monster_effect_val == 77:
            chain_det_ary = json.loads(self.duel.chain_det_trigger)
            chain_det = chain_det_ary[str(self.duel.chain - 1)]
            trigger = Trigger.objects.get(id=chain_det)
            if self.get_fusion_material(monster_effect_unwrap,user, trigger,1,1):
                if duel.is_ai is False or user == 1:
                    if duel.user_turn == user:
                        self.duel.ask = 1
                    else:
                        self.duel.ask = 2
                    return -1
                else:
                    if self.answer_ai(strategy,strategy_up_or_down):
                        if monster_effect.pac:
                            return self._pac(monster_effect.pac,None)
                        else:
                            if monster_effect.monster_effect_next is not None:
                                return monster_effect.monster_effect_next
                            else:
                                return self.pop_pac(user)
                    return self.do_next(monster_effect,user)
            else:
                return self.do_next(monster_effect,user)
        elif monster_effect_unwrap.monster_effect_val == 74:
            self.check_eternal_effect(
                decks, graves, hands, duel.phase, duel.user_turn, user, other_user
            )
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)

        elif monster_effect_unwrap.monster_effect_val == 73:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.move_from_monster(effect_kind)
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user)
                log_tmp = self.write_log(monster_effect.log, user)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)


        elif monster_effect_unwrap.monster_effect_val == 1:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.move_from_monster(effect_kind)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if move_to is not None:
                self.move_to_monster(move_to, effect_kind)
            if monster_effect.if_not_to_2 is False or move_to:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2:
                        return monster_effect.monster_effect_next2
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 40:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            effect_kind_rel = monster_effect.monster_effect_kind_rel
            move_to = self.move_from_monster_relation(effect_kind, effect_kind_rel)
            data = {}
            data["monsters"] = move_to
            if move_to == []:
                pass
            else:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp

            if move_to is not None:
                self.move_to_monster(move_to, effect_kind)
            if monster_effect.if_not_to_2 is False or move_to:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2:
                        return monster_effect.monster_effect_next2
                    else:
                        return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 7:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.move_phase()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 37:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            effect_kind = monster_effect.monster_effect_kind
            return self.copy_effect(monster_effect_unwrap, effect_kind)
        elif monster_effect_unwrap.monster_effect_val == 46:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            effect_kind = monster_effect.monster_effect_kind
            return self.copy_effect2(monster_effect_unwrap, effect_kind)
        elif monster_effect_unwrap.monster_effect_val == 8:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.change_turn(monster_effect_unwrap)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 35:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            data_tmp = self.copy_monster(
                monster_effect_unwrap.monster_effect,
                monster_effect_unwrap.monster_condition,
                effect_kind,
            )
            self.get_effect(monster_effect, user,data_tmp)
            log_tmp = self.write_log(monster_effect.log, user, data_tmp)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 72:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            move_to = self.create_token(monster_effect_unwrap.monster_effect,user)
            if move_to is not None:
                self.move_to_monster(move_to, effect_kind)

            data = {}
            data["monsters"] = move_to
            self.get_effect(monster_effect, user,data)
            log_tmp = self.write_log(monster_effect.log, user, data)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.if_not_to_2 is False or move_to:
                if monster_effect.pac:
                    return self._pac(monster_effect.pac)
                else:
                    if monster_effect.monster_effect_next:
                        return monster_effect.monster_effect_next
                    else:
                        return self.pop_pac(user)
            else:
                if monster_effect.pac2:
                    return self._pac(monster_effect.pac2)
                else:
                    if monster_effect.monster_effect_next2:
                        return monster_effect.monster_effect_next2
                    else:
                        return self.pop_pac(user)

        elif monster_effect_unwrap.monster_effect_val == 71:
            effect_kind = self.get_pac_effect_kind()
            if effect_kind is None:
                effect_kind = monster_effect.monster_effect_kind
            data_tmp = self.copy_monster_specify(
                monster_effect_unwrap.monster_effect,
                monster_effect_unwrap.monster_condition,
                effect_kind,
            )
            self.get_effect(monster_effect, user,data_tmp)
            log_tmp = self.write_log(monster_effect.log, user, data_tmp)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)

        elif monster_effect_unwrap.monster_effect_val == 34:
            data_tmp = self.change_variable_by_monster()
            data = {}
            data["monsters"] = data_tmp[0]
            data["val"] = data_tmp[1]
            if data["val"] != 0:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 80:
            change_show = self.change_show(0,monster_effect_unwrap)
            data = {}
            self.get_effect(monster_effect, user,data)
            log_tmp = self.write_log(monster_effect.log, user, data)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 2:
            change_val = self.change_variable(0,monster_effect_unwrap)
            data = {}
            data["val"] = change_val
            if change_val != 0:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 49:
            change_val = self.change_alt_global()
            data = {}
            data["val"] = change_val
            if change_val != 0:
                self.get_effect(monster_effect, user,data)
                log_tmp = self.write_log(monster_effect.log, user, data)
                duel.log_turn += log_tmp
                duel.log += log_tmp
                self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 9:
            effect_kind = monster_effect.monster_effect_kind
            data2 = self.change_monster_variable_eternal(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
                monster_effect_unwrap.change_val_monster_flag,
                monster_effect_unwrap.accumulate_flag
            )
            if data2 is not None:
                data = {}
                data["monsters"] = data2[0]
                data["val"] = data2[1]
                if data:
                    self.get_effect(monster_effect, user,data)
                    log_tmp = self.write_log(monster_effect.log, user, data)
                    duel.log_turn += log_tmp
                    duel.log += log_tmp
                    self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 29:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.change_variable_multiple(0, None, monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 25:
            effect_kind = monster_effect.monster_effect_kind
            return_value = self.change_monster_relation(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
            )
            self.get_effect(monster_effect, user,return_value)
            log_tmp = self.write_log_change_monster_relation(
                monster_effect.log, return_value
            )
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 39:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            effect_kind = monster_effect.monster_effect_kind
            self.invalid_effect(effect_kind, monster_effect_unwrap.monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)

        elif monster_effect_unwrap.monster_effect_val == 70:
            # 対象クリア
            effect_kind = monster_effect.monster_effect_kind
            specify = self.change_monster_relation_clear(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
            )
            return_value = self.change_monster_relation_specify(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
                specify
            )
            self.get_effect(monster_effect, user,return_value)
            log_tmp = self.write_log_change_monster_relation(
                monster_effect.log, return_value
            )
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 38:
            # 対象クリア
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            effect_kind = monster_effect.monster_effect_kind
            self.change_monster_relation_clear(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
            )
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 33:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            effect_kind = monster_effect.monster_effect_kind
            self.clear_relation(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
            )
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 32:
            effect_kind = monster_effect.monster_effect_kind
            effect_kind_rel = monster_effect.monster_effect_kind_rel
            return_value = self.change_monster_variable_relation(
                monster_effect_unwrap.monster_effect,
                effect_kind,
                monster_effect_unwrap.monster_condition,
                effect_kind_rel,
            )
            self.get_effect(monster_effect, user,return_value)
            log_tmp = self.write_log(monster_effect.log, user, return_value)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 10:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.shuffle()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 11:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.clear()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 12:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.raise_by_monster_effect()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 13:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.change_appointment()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 14:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            monster_effect_text = json.loads(
                monster_effect.monster_effect.monster_effect
            )
            if "timing_fresh" in monster_effect_text:
                fresh= monster_effect_text["timing_fresh"]
            else:
                fresh= True
            self.change_timing(int(monster_effect_text["move_to_timing"]),fresh,int(monster_effect_text["t_num"]))
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 19:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            if duel.timing3 is not None:
                self.expire_timing(duel.timing3,duel.timing3.next_timing, duel.user_turn)
                duel.timing3 = duel.timing3.next_timing
            elif duel.timing2 is not None:
                self.expire_timing(duel.timing2,duel.timing2.next_timing, duel.user_turn)
                duel.timing2 = duel.timing2.next_timing
            elif duel.timing is not None:
                self.expire_timing(duel.timing,duel.timing.next_timing, duel.user_turn)
                timing = duel.timing.next_timing
                duel.timing = timing
            if duel.timing is None and duel.timing2 is None and duel.timing3 is None:
                self.timing_mess = {}
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)

        elif monster_effect_unwrap.monster_effect_val == 18:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.move_effect_variable_to_timing(0)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 60:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.sound_effect_effect(monster_effect.monster_effect.monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 61:
            self.change_appoint(monster_effect.monster_effect.monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 21:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.play_music(monster_effect.monster_effect.monster_effect)
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 30:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.select_multiple()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        elif monster_effect_unwrap.monster_effect_val == 31:
            self.get_effect(monster_effect, user)
            log_tmp = self.write_log(monster_effect.log, user)
            duel.log_turn += log_tmp
            duel.log += log_tmp
            self.current_log += log_tmp
            self.select_multiple_other()
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)

    def write_log_change_monster_relation(self, log, data):
        if self.duel.mute == 1:
            return
        if log == "":
            return ""
        relate_monster = data["relate_monster"]
        related_monster = data["related_monster"]
        result_log = ""
        if not log.find("@") :
            relate_monster = []
            relate_monster.append("dummy")
        for i in range(len(relate_monster)):
            log_text = log
            while 1:
                log_calc = re.search("\(.*?\)", log_text)
                if log_calc is None:
                    break
                dummy = log_calc.group()
                dummy = dummy[1:-1]
                tmp_log = ""
                if dummy == "@":
                    if len(relate_monster) > i:
                        tmp_log = relate_monster[i]["monster_name"]
                    else:
                        tmp_log = ""
                elif dummy == "*":
                    if len(related_monster) > i:
                        tmp_log = related_monster[i]["monster_name"]
                    else:
                        tmp_log = ""
                log_text = log_text.replace(log_calc.group(), tmp_log)
            result_log += log_text + "\n"
        return result_log

    def write_prompt(self,prompt,user):
        duel = self.duel
        prompt_text = prompt
        while 1:
            log_calc = re.search("\(.*?\)", prompt_text)
            if log_calc is None:
               break
            dummy = log_calc.group()
            dummy = dummy[1:-1]
            if(dummy == "@"):
                break
            if(dummy[0] == "{"):
                tmp = self.get_name_all(dummy, 1)
                if len(tmp):
                    tmp = tmp[0]
                else:
                    tmp = ""
            elif dummy[0] == "$":
                tmp = self.get_place_name(dummy,user)
            prompt_text = prompt_text.replace(log_calc.group(), tmp) + "\n"
        return prompt_text

    def get_effect(self,monster_effect,user,data=None):
        flag = False
        if data is None or "monsters" not in data:
            if monster_effect.effect != "":
                effect_ary = monster_effect.effect.split("|")
                for effect in effect_ary:
                    effect2 = effect.split(";") 
                    if effect2[0] == "video" or effect2[0] == "background":
                        if(flag is False):
                             self.effect += "&"+str(self.duel.effect_flag)+"*"
                             self.effect2 += "&"+str(self.duel.effect_flag)+"*"
                        if effect2[0] == "background":
                            self.duel.background_image = effect2[1]
                        self.effect += monster_effect.effect + "|"
                        self.effect2 += monster_effect.effect + "|"
                        flag = True
                    else:
                        pass
            return;
        else:
            if monster_effect.effect != "":
                effect_ary = monster_effect.effect.split("|")
                for effect in effect_ary:
                    monster_i = 0;
                    effect2 = effect.split(";") 
                    if effect2[0] == "video" or effect2[0] == "background":
                        if effect2[0] == "background":
                            
                            if(flag is False):
                                self.effect += "&"+str(self.duel.effect_flag)+"*"
                                self.effect2 += "&"+str(self.duel.effect_flag)+"*"
                            self.duel.background_image = effect2[1]
                            self.effect += monster_effect.effect + "|"
                            self.effect2 += monster_effect.effect + "|"
                            flag = True
                        if(effect2[1] != "number"):
                            if(flag is False):
                                if self.effect[0] != "&":
                                    self.effect = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                    self.effect2 = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                    self.duel.effect_flag +=1
                                else:
                                    self.effect += "&"+str(self.duel.effect_flag)+"*"
                                    self.effect2 += "&"+str(self.duel.effect_flag)+"*"
                                    self.duel.effect_flag +=1
                        self.effect += effect + "|"
                        self.effect2 += effect + "|"
                        flag = True
                    elif effect2[0] == "monster":
                        for monster in data["monsters"]:
                            if monster["deck_id"] != 0:
                               monster_i += 1
                               continue
                            x = str(monster["x"])
                            y = str(monster["y"])
                            if(effect2[1] != "number"):
                                if(flag is False):
                                    if self.effect[0] != "&":
                                        self.effect = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                        self.effect2 = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                        self.duel.effect_flag +=1
                                    else:
                                        self.effect += "&"+str(self.duel.effect_flag)+"*"
                                        self.effect2 += "&"+str(self.duel.effect_flag)+"*"
                                        self.duel.effect_flag +=1
                                self.effect += "monster;"+x+";"+y+";"+effect2[1]+"|"
                                self.effect2 += "monster;"+x+";"+y+";"+effect2[1]+"|"
                                flag = True
                            else:
                                if isinstance(data["val"], list):
                                    if(flag is False):
                                        if self.effect[0] != "&":
                                            self.effect = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                            self.effect2 = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                            self.duel.effect_flag +=1
                                        else:
                                            self.effect += "&"+str(self.duel.effect_flag)+"*"
                                            self.effect2 += "&"+str(self.duel.effect_flag)+"*"
                                            self.duel.effect_flag +=1
                                    self.effect += "monster;"+x+";"+y+";"+effect2[1]+";"+str(abs(int(float(data["val"][monster_i]))))+"|"
                                    self.effect2 += "monster;"+x+";"+y+";"+effect2[1]+";"+str(abs(int(float(data["val"][monster_i]))))+"|"
                                else:
                                    if(flag is False):
                                        if self.effect[0] != "&":
                                            self.effect = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                            self.effect2 = "&"+str(self.duel.effect_flag)+"*"+self.effect
                                            self.duel.effect_flag +=1
                                        else:
                                            self.effect += "&"+str(self.duel.effect_flag)+"*"
                                            self.effect2 += "&"+str(self.duel.effect_flag)+"*"
                                            self.duel.effect_flag +=1
                                    self.effect += "monster;"+x+";"+y+";"+effect2[1]+";"+str(abs(int(float(data["val"]))))+"|"
                                    self.effect2 += "monster;"+x+";"+y+";"+effect2[1]+";"+str(abs(int(float(data["val"]))))+"|"
                                flag = True
                            monster_i += 1
            return;

    def write_log(self, log, user, data=None):
        duel = self.duel
        if self.duel.guest_flag is False:
            user1_name = duel.user_1.first_name
        else:    
            user1_name = duel.guest_name
        if self.duel.is_ai is False:
            if self.duel.guest_flag2 is False:
                user2_name = duel.user_2.first_name
            else:    
                user2_name = duel.guest_name2
        else:            
            user2_name = "NPC"
        result_log = ""
        if log == "":
            return ""
        if log.find("@") == -1 and log.find("#") == -1:
            if log.find("(^)") != -1:
                tmp_log = len(data["monsters"])
                log = log.replace("(^)", str(tmp_log))
            if data is not None and "monsters" in data:
                del data["monsters"]
        if data is None or "monsters" not in data:
            log_text = log
            i = 0
            while 1:
                log_calc = re.search("\(.*?\)", log_text)
                if log_calc is None:
                    break
                dummy = log_calc.group()
                dummy = dummy[1:-1]
                if dummy == "#":
                    tmp_log = ""
                elif dummy[0] == "$":
                    tmp_log = self.get_place_name(dummy,user)
                elif dummy == "@":
                   tmp_log = data["monsters"][i]["det"]["monster_name"]
                elif dummy == "%":
                   if isinstance(data["val"], list):
                       tmp_log = str(int(-float(data["val"][i])))
                   else:
                       tmp_log = str(int(-float(data["val"])))
                elif dummy == "*":
                    if isinstance(data["val"], list):
                        tmp_log = str(int(float(data["val"][i])))
                    else:
                        tmp_log = str(int(float(data["val"])))
                elif dummy == "&":
                    if i >= len(data["monsters2"]):
                       return ""
                    tmp_log = data["monsters2"][i]["det"]["monster_name"]
                elif dummy[0] != "/":
                    tmp = self.get_name_all(dummy, 1)
                    tmp_log = tmp[0]
                elif dummy[1] == "1":
                    if user == 1:
                        tmp_log = user1_name
                    else:
                        tmp_log = user2_name
                elif dummy[1] == "2":
                    if user == 1:
                        tmp_log = user2_name
                    else:
                        tmp_log = user1_name
                elif dummy[1] == "$":
                        tmp_log =  self.get_place_name(dummy,user)
                log_text = log_text.replace(log_calc.group(), tmp_log) + "\n"
                i += 1
            return html.escape(log_text)
        for i in range(len(data["monsters"])):
            log_text = log
            while 1:
                log_calc = re.search("\(.*?\)", log_text)
                if log_calc is None:
                    break
                dummy = log_calc.group()
                dummy = dummy[1:-1]
                if dummy == "#":
                    tmp_log = ""
                elif dummy[0] == "$":
                    tmp_log = self.get_place_name(dummy,user)
                elif dummy == "^":
                    tmp_log = len(data["monsters"][i])
                elif dummy == "@":
                    tmp_log = data["monsters"][i]["det"]["monster_name"]
                elif dummy == "%":
                    if isinstance(data["val"], list):
                        tmp_log = str(-int(float(data["val"][i])))
                    else:
                        tmp_log = str(-int(float(data["val"])))
                elif dummy == "*":
                    if isinstance(data["val"], list):
                        tmp_log = str(int(float(data["val"][i])))
                    else:
                        tmp_log = str(int(float(data["val"])))
                elif dummy == "&":
                    tmp_log = data["monsters2"][i]["det"]["monster_name"]
                elif dummy[0] != "/":
                    tmp = self.get_name_all(dummy, 1)
                    tmp_log = tmp[0]
                elif dummy[1] == "1":
                    if user == 1:
                        tmp_log = user1_name
                    else:
                        tmp_log = user2_name
                elif dummy[1] == "2":
                    if user == 1:
                        tmp_log = user2_name
                    else:
                        tmp_log = user1_name
                elif dummy[1] == "$":
                        tmp_log =  self.get_place_name(dummy,user)
                log_text = log_text.replace(log_calc.group(), tmp_log)

            result_log += log_text + "\n"
        return html.escape(result_log)

    def raise_by_monster_effect(self):
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        monster_effect_wrapper = MonsterEffectWrapper.objects.get(
            id=int(chain_det[str(duel.chain - 1)])
        )
        monster_effect = monster_effect_wrapper.monster_effect
        monster_effect_text = json.loads(monster_effect.monster_effect)
        trigger_waitings = json.loads(duel.trigger_waiting)
        for monster_effect_det in monster_effect_text:
            trigger = Trigger.objects.get(id=monster_effect_det["trigger"]["0"])
            tmp = {}
            tmp["monster"] = ""
            tmp["move_from"] = None
            tmp["trigger"] = monster_effect_det["trigger"]["0"]
            tmp["priority"] = trigger.priority
            tmp["storategy_priority"] = trigger.storategy_priority
            tmp["mine_or_other"] = 1
            tmp["user"] = effect_user
            tmp["place"] = ""
            tmp["deck_id"] = ""
            tmp["place_from"] = ""
            tmp["deck_id_from"] = ""
            tmp["x"] = 0
            tmp["y"] = 0
            tmp["from_x"] = 0
            tmp["from_y"] = 0
            tmp["strategy_value"] = 0
            trigger_waitings.append(tmp)
        duel.trigger_waiting = json.dumps(trigger_waitings)

    def expire_chain(self):
        self.expire_deck_chain()
        self.expire_grave_chain()
        self.expire_hand_chain()
        self.expire_field_chain()
    def expire_turn(self, turn):
        self.expire_deck_turn(turn)
        self.expire_grave_turn(turn)
        self.expire_hand_turn(turn)
        self.expire_field_turn(turn)

    def expire_field_chain(self):
        field = self.field
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is False:
            field_x = field_size.field_x
        else:
            field_x = 20
        for x in range(field_x):
            for y in range(field_size.field_y):
                if field[x][y]["det"] is None:
                    continue
                if "eternal" not in field[x][y]["det"]:
                    continue
                index = 0
                index_list = []
                for eternal in field[x][y]["det"]["eternal"]:
                    if eternal is None:
                        index += 1
                        continue
                    life = eternal["monster_variable_change_life"].split("_")
                    if life[0] != "chain":
                        index += 1
                        continue
                    index_list.append(index)
                    index += 1
                for index3 in reversed(index_list):
                    del field[x][y]["det"]["eternal"][index3]

        self.field = field

    def expire_field_turn(self, turn):
        field = self.field
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is False:
            field_x = field_size.field_x
        else:
            field_x = 20
        for x in range(field_x):
            for y in range(field_size.field_y):
                if field[x][y]["det"] is None:
                    continue
                if "eternal" not in field[x][y]["det"]:
                    continue
                index = 0
                index_list = []
                for eternal in field[x][y]["det"]["eternal"]:
                    if eternal is None:
                        index += 1
                        continue
                    life = eternal["monster_variable_change_life"].split("_")
                    if life[0] != "turn":
                        index += 1
                        continue
                    life = int(life[1])
                    if (
                        life == 3
                        or (((field[x][y]["mine_or_other"] == 1 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 2)) and life == 1)
                        or (((field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 1and self.duel.user_turn == 2)) and life == 2)
                        
                    ):
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ] -= 1
                    if (
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ]
                        <= 0
                    ):
                        index_list.append(index)
                    index += 1
                for index3 in reversed(index_list):
                    del field[x][y]["det"]["eternal"][index3]

        self.field = field

    def expire_hand_turn(self, turn):

        hands = self.hand_structure
        i = 0
        for hand in hands:
            i += 1
            if hand.mine_or_other == 0:
                myhands = self.hands[i]["myhand"]
                otherhands = self.hands[i]["otherhand"]
                index2 = -1
                for myhand in myhands:
                    index2 += 1
                    if "eternal" not in myhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in myhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del myhand["eternal"][index3]
                    myhands[index2] = myhand
                index2 = -1
                for otherhand in otherhands:
                    index2 += 1
                    if "eternal" not in otherhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            otherhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            otherhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherhand["eternal"][index3]
                    otherhands[index2] = otherhand
                self.hands[i]["myhand"] = myhands
                self.hands[i]["otherhand"] = otherhands

            else:
                commonhands = self.hands[i]["commonhand"]
                for commonhand in commonhands:
                    index2 += 1
                    if "eternal" not in commonhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commonhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commonhand["eternal"][index3]
                    commonhands[index2] = commonhand
                self.hands[i]["commonhand"] = commonhands

    def expire_grave_turn(self, turn):

        graves = self.grave_structure
        i = 0
        for grave in graves:
            i += 1
            if grave.mine_or_other == 0:
                mygraves = self.graves[i]["mygrave"]
                othergraves = self.graves[i]["othergrave"]
                index2 = -1
                for mygrave in mygraves:
                    index2 += 1
                    if "eternal" not in mygrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mygrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            mygrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            mygrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del mygrave["eternal"][index3]
                    mygraves[index2] = mygrave
                index2 = -1
                for othergrave in othergraves:
                    index2 += 1
                    if "eternal" not in othergrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in othergrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            othergrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            othergrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del othergrave["eternal"][index3]
                    othergraves[index2] = othergrave
                self.graves[i]["mygrave"] = mygraves
                self.graves[i]["othergrave"] = othergraves

            else:
                commongraves = self.graves[i]["commongrave"]
                for commongrave in commongraves:
                    index2 += 1
                    if "eternal" not in commongrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commongrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commongrave["eternal"][index3]
                    commongraves[index2] = commongrave
                self.graves[i]["commongrave"] = commongraves

    
    def expire_hand_chain(self):

        hands = self.hand_structure
        i = 0
        for hand in hands:
            i += 1
            if hand.mine_or_other == 0:
                myhands = self.hands[i]["myhand"]
                otherhands = self.hands[i]["otherhand"]
                index2 = -1
                for myhand in myhands:
                    index2 += 1
                    if "eternal" not in myhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in myhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                        index_list.append(index)
                index2 = -1
                for otherhand in otherhands:
                    index2 += 1
                    if "eternal" not in otherhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                            continue
                        index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherhand["eternal"][index3]
                    otherhands[index2] = otherhand
                self.hands[i]["myhand"] = myhands
                self.hands[i]["otherhand"] = otherhands

            else:
                commonhands = self.hands[i]["commonhand"]
                index2 = -1
                for commonhand in commonhands:
                    index2 += 1
                    if "eternal" not in commonhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commonhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                            continue
                        index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commonhand["eternal"][index3]
                    commonhands[index2] = commonhand
                self.hands[i]["commonhand"] = commonhands

    def expire_grave_chain(self):

        graves = self.grave_structure
        i = 0
        for grave in graves:
            i += 1
            if grave.mine_or_other == 0:
                mygraves = self.graves[i]["mygrave"]
                othergraves = self.graves[i]["othergrave"]
                index2 = -1
                for mygrave in mygraves:
                    index2 += 1
                    if "eternal" not in mygrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mygrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                        index_list.append(index)
                index2 = -1
                for othergrave in othergraves:
                    index2 += 1
                    if "eternal" not in othergrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in othergrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                            continue
                        index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del othergrave["eternal"][index3]
                    othergraves[index2] = othergrave
                self.graves[i]["mygrave"] = mygraves
                self.graves[i]["othergrave"] = othergraves

            else:
                index2 = -1
                commongraves = self.graves[i]["commongrave"]
                for commongrave in commongraves:
                    index2 += 1
                    if "eternal" not in commongrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commongrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                            continue
                        index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commongrave["eternal"][index3]
                    commongraves[index2] = commongrave
                self.graves[i]["commongrave"] = commongraves

    def expire_deck_chain(self):

        decks = self.deck_structure
        i = 0
        for deck in decks:
            i += 1
            if deck.mine_or_other == 0:
                mydecks = self.decks[i]["mydeck"]
                otherdecks = self.decks[i]["otherdeck"]
                index2 = -1
                for mydeck in mydecks:
                    index2 += 1
                    if "eternal" not in mydeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mydeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                        index_list.append(index)
                index2 = -1
                for otherdeck in otherdecks:
                    index2 += 1
                    if "eternal" not in otherdeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherdeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                            continue
                        index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherdeck["eternal"][index3]
                    otherdecks[index2] = otherdeck
                self.decks[i]["mydeck"] = mydecks
                self.decks[i]["otherdeck"] = otherdecks

            else:
                index2 = -1
                commondecks = self.decks[i]["commondeck"]
                for commondeck in commondecks:
                    index2 += 1
                    if "eternal" not in commondeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commondeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "chain":
                            index += 1
                            continue
                        index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commondeck["eternal"][index3]
                    commondecks[index2] = commondeck
                self.decks[i]["commondeck"] = commondecks

    def expire_deck_turn(self, turn):

        decks = self.deck_structure
        i = 0
        for deck in decks:
            i += 1
            if deck.mine_or_other == 0:
                mydecks = self.decks[i]["mydeck"]
                otherdecks = self.decks[i]["otherdeck"]
                index2 = -1
                for mydeck in mydecks:
                    index2 += 1
                    if "eternal" not in mydeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mydeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            mydeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            mydeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del mydeck["eternal"][index3]
                    mydecks[index2] = mydeck
                index2 = -1
                for otherdeck in otherdecks:
                    index2 += 1
                    if "eternal" not in otherdeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherdeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            otherdeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            otherdeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherdeck["eternal"][index3]
                    otherdecks[index2] = otherdeck
                self.decks[i]["mydeck"] = mydecks
                self.decks[i]["otherdeck"] = otherdecks

            else:
                commondecks = self.decks[i]["commondeck"]
                index2 = -1
                for commondeck in commondecks:
                    index2 += 1
                    if "eternal" not in commondeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commondeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "turn":
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commondeck["eternal"][index3]
                    commondecks[index2] = commondeck
                self.decks[i]["commondeck"] = commondecks

    def expire_timing(self, timing,next_timing, turn):
        self.expire_deck_timing(timing,next_timing, turn)
        self.expire_grave_timing(timing,next_timing,  turn)
        self.expire_hand_timing(timing,next_timing,  turn)
        self.expire_field_timing(timing,next_timing,  turn)

    def expire_field_timing(self, timing,next_timing, turn):
        field = self.field
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is False:
            field_x = field_size.field_x
        else:
            field_x = 20
        for x in range(field_x):
            for y in range(field_size.field_y):
                if field[x][y]["det"] is None:
                    continue
                if "eternal" not in field[x][y]["det"]:
                    continue
                index = 0
                index_list = []
                for eternal in field[x][y]["det"]["eternal"]:
                    if eternal is None:
                        index += 1
                        continue
                    life = eternal["monster_variable_change_life"].split("_")
                    if life[0] != "timing":
                        index += 1
                        continue
                    if int(life[2]) != timing.id:
                        index += 1
                        continue
                    life = int(life[1])
                    if (
                        life == 3
                        or (((field[x][y]["mine_or_other"] == 1 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 2)) and life == 1)
                        or (((field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 1and self.duel.user_turn == 2)) and life == 2)
                    ):
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ] -= 1
                    if (
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ]
                        <= 0
                    ):
                        index_list.append(index)
                    index += 1
                for index3 in reversed(index_list):
                    del field[x][y]["det"]["eternal"][index3]
                index = 0
                index_list = []
                for eternal in field[x][y]["det"]["eternal"]:
                    if eternal is None:
                        index += 1
                        continue
                    life = eternal["monster_variable_change_life"].split("_")
                    if life[0] != "timingbegin":
                        index += 1
                        continue
                    if int(life[2]) != next_timing.id:
                        index += 1
                        continue
                    life = int(life[1])
                    if (
                        life == 3
                        or (((field[x][y]["mine_or_other"] == 1 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 2)) and life == 1)
                        or (((field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 1and self.duel.user_turn == 2)) and life == 2)
                    ):
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ] -= 1
                    if (
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ]
                        <= 0
                    ):
                        index_list.append(index)
                    index += 1
                for index3 in reversed(index_list):
                    del field[x][y]["det"]["eternal"][index3]

        self.field = field

    def expire_hand_timing(self, timing,next_timing, turn):

        hands = self.hand_structure
        i = 0
        for hand in hands:
            i += 1
            if hand.mine_or_other == 0:
                myhands = self.hands[i]["myhand"]
                otherhands = self.hands[i]["otherhand"]
                index2 = -1
                for myhand in myhands:
                    index2 += 1
                    if "eternal" not in myhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in myhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del myhand["eternal"][index3]
                    myhands[index2] = myhand
                index2 = -1
                for myhand in myhands:
                    index2 += 1
                    if "eternal" not in myhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in myhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timingbegin":
                            index += 1
                            continue
                        if int(life[2]) != next_timing.id:
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del myhand["eternal"][index3]
                    myhands[index2] = myhand
                index2 = -1
                for otherhand in otherhands:
                    index2 += 1
                    if "eternal" not in otherhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            otherhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            otherhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherhand["eternal"][index3]
                    otherhands[index2] = otherhand
                self.hands[i]["myhand"] = myhands
                self.hands[i]["otherhand"] = otherhands

            else:
                commonhands = self.hands[i]["commonhand"]
                index2 = -1
                for commonhand in commonhands:
                    index2 += 1
                    if "eternal" not in commonhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commonhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commonhand["eternal"][index3]
                    commonhands[index2] = commonhand
                index2 = -1
                for commonhand in commonhands:
                    index2 += 1
                    if "eternal" not in commonhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commonhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commonhand["eternal"][index3]
                    commonhands[index2] = commonhand
                self.hands[i]["commonhand"] = commonhands

    def expire_grave_timing(self, timing,next_timing, turn):

        graves = self.grave_structure
        i = 0
        for grave in graves:
            i += 1
            if grave.mine_or_other == 0:
                mygraves = self.graves[i]["mygrave"]
                othergraves = self.graves[i]["othergrave"]
                index2 = -1
                for mygrave in mygraves:
                    index2 += 1
                    if "eternal" not in mygrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mygrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            mygrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            mygrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del mygrave["eternal"][index3]
                    mygraves[index2] = mygrave
                index2 = -1
                for othergrave in othergraves:
                    index2 += 1
                    if "eternal" not in othergrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in othergrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            othergrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            othergrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del othergrave["eternal"][index3]
                    othergraves[index2] = othergrave
                self.graves[i]["mygrave"] = mygraves
                self.graves[i]["othergrave"] = othergraves

            else:
                commongraves = self.graves[i]["commongrave"]
                for commongrave in commongraves:
                    index2 += 1
                    if "eternal" not in commongrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commongrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commongrave["eternal"][index3]
                    commongraves[index2] = commongrave
                self.graves[i]["commongrave"] = commongraves

    def expire_deck_timing(self, timing,next_timing, turn):

        decks = self.deck_structure
        i = 0
        for deck in decks:
            i += 1
            if deck.mine_or_other == 0:
                mydecks = self.decks[i]["mydeck"]
                otherdecks = self.decks[i]["otherdeck"]
                index2 = -1
                for mydeck in mydecks:
                    index2 += 1
                    if "eternal" not in mydeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mydeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            mydeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            mydeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del mydeck["eternal"][index3]
                    mydecks[index2] = mydeck
                index2 = -1
                for otherdeck in otherdecks:
                    index2 += 1
                    if "eternal" not in otherdeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherdeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            otherdeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            otherdeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherdeck["eternal"][index3]
                    otherdecks[index2] = otherdeck
                self.decks[i]["mydeck"] = mydecks
                self.decks[i]["otherdeck"] = otherdecks

            else:
                index2 = -1
                commondecks = self.decks[i]["commondeck"]
                for commondeck in commondecks:
                    index2 += 1
                    if "eternal" not in commondeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commondeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timing":
                            index += 1
                            continue
                        if int(life[2]) != timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commondeck["eternal"][index3]
                    commondecks[index2] = commondeck
                for commondeck in commondecks:
                    index2 += 1
                    if "eternal" not in commondeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commondeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "timingbegin":
                            index += 1
                            continue
                        if int(life[2]) != next_timing.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commondeck["eternal"][index3]
                    commondecks[index2] = commondeck
                self.decks[i]["commondeck"] = commondecks

    def expire_phase(self, phase, org_phase,turn):
        self.expire_deck_phase(phase,org_phase, turn)
        self.expire_grave_phase(phase,org_phase, turn)
        self.expire_hand_phase(phase,org_phase, turn)
        self.expire_field_phase(phase,org_phase, turn)

    def expire_field_phase(self, phase,org, turn):
        field = self.field
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is False:
            field_x = field_size.field_x
        else:
            field_x = 20
        for x in range(field_x):
            for y in range(field_size.field_y):
                if field[x][y]["det"] is None:
                    continue
                if "eternal" not in field[x][y]["det"]:
                    continue
                index = 0
                index_list = []
                for eternal in field[x][y]["det"]["eternal"]:
                    if eternal is None:
                        index += 1
                        continue
                    life = eternal["monster_variable_change_life"].split("_")
                    if life[0] != "phase":
                        index += 1
                        continue
                    if int(life[2]) != phase.id:
                        index += 1
                        continue
                    life = int(life[1])
                    if (
                        life == 3
                        or (((field[x][y]["mine_or_other"] == 1 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2  and self.duel.user_turn == 2) ) and life == 1)
                        or (((field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2  and self.duel.user_turn == 1) ) and life == 2)
                    ):
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ] -= 1
                    if (
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ]
                        <= 0
                    ):
                        index_list.append(index)
                    index += 1
                for index3 in reversed(index_list):
                    del field[x][y]["det"]["eternal"][index3]
                index = 0
                index_list = []
                for eternal in field[x][y]["det"]["eternal"]:
                    if eternal is None:
                        index += 1
                        continue
                    life = eternal["monster_variable_change_life"].split("_")
                    if life[0] != "phaseend":
                        index += 1
                        continue
                    if int(life[2]) != org.id:
                        index += 1
                        continue
                    life = int(life[1])
                    if (
                        life == 3
                        or (((field[x][y]["mine_or_other"] == 1 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2  and self.duel.user_turn == 2) ) and life == 1)
                        or (((field[x][y]["mine_or_other"] == 2 and self.duel.user_turn == 1)
                        or (field[x][y]["mine_or_other"] == 2  and self.duel.user_turn == 1) ) and life == 2)
                    ):
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ] -= 1
                    if (
                        field[x][y]["det"]["eternal"][index][
                            "monster_variable_change_life_length"
                        ]
                        <= 0
                    ):
                        index_list.append(index)
                    index += 1
                for index3 in reversed(index_list):
                    del field[x][y]["det"]["eternal"][index3]

        self.field = field

    def expire_hand_phase(self, phase,org, turn):

        hands = self.hand_structure
        i = 0
        for hand in hands:
            i += 1
            if hand.mine_or_other == 0:
                myhands = self.hands[i]["myhand"]
                otherhands = self.hands[i]["otherhand"]
                index2 = -1
                for myhand in myhands:
                    index2 += 1
                    if "eternal" not in myhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in myhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            myhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del myhand["eternal"][index3]
                    myhands[index2] = myhand
                index2 = -1
                for otherhand in otherhands:
                    index2 += 1
                    if "eternal" not in otherhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phaseend":
                            index += 1
                            continue
                        if int(life[2]) != org.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            otherhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            otherhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherhand["eternal"][index3]
                    otherhands[index2] = otherhand
                self.hands[i]["myhand"] = myhands
                self.hands[i]["otherhand"] = otherhands

            else:
                commonhands = self.hands[i]["commonhand"]
                inde2 = -1
                for commonhand in commonhands:
                    index2 += 1
                    if "eternal" not in commonhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commonhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            else:
                                life = 1
                        if life == 3:
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commonhand["eternal"][index3]
                    commonhands[index2] = commonhand
                inde2 = -1
                for commonhand in commonhands:
                    index2 += 1
                    if "eternal" not in commonhand:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commonhand["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phaseend":
                            index += 1
                            continue
                        if int(life[2]) != org.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            else:
                                life = 1
                        if life == 3:
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commonhand["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commonhand["eternal"][index3]
                    commonhands[index2] = commonhand
                self.hands[i]["commonhand"] = commonhands

    def expire_grave_phase(self, phase, org,turn):

        graves = self.grave_structure
        i = 0
        for grave in graves:
            i += 1
            if grave.mine_or_other == 0:
                mygraves = self.graves[i]["mygrave"]
                othergraves = self.graves[i]["othergrave"]
                index2 = -1
                for mygrave in mygraves:
                    index2 += 1
                    if "eternal" not in mygrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mygrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            mygrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            mygrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del mygrave["eternal"][index3]
                    mygraves[index2] = mygrave
                index2 = -1
                for othergrave in othergraves:
                    index2 += 1
                    if "eternal" not in othergrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in othergrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.user == 2)
                            or (life == 2 and self.user == 1)
                        ):
                            othergrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            othergrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del othergrave["eternal"][index3]
                    othergraves[index2] = othergrave
                self.graves[i]["mygrave"] = mygraves
                self.graves[i]["othergrave"] = othergraves

            else:
                commongraves = self.graves[i]["commongrave"]
                index2 = -1
                for commongrave in commongraves:
                    index2 += 1
                    if "eternal" not in commongrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commongrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commongrave["eternal"][index3]
                    commongraves[index2] = commongrave
                index2 = -1
                for commongrave in commongraves:
                    index2 += 1
                    if "eternal" not in commongrave:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commongrave["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phaseend":
                            index += 1
                            continue
                        if int(life[2]) != org.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commongrave["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del commongrave["eternal"][index3]
                    commongraves[index2] = commongrave
                self.graves[i]["commongrave"] = commongraves

    def expire_deck_phase(self, phase,org, turn):

        decks = self.deck_structure
        i = 0
        for deck in decks:
            i += 1
            if deck.mine_or_other == 0:
                mydecks = self.decks[i]["mydeck"]
                otherdecks = self.decks[i]["otherdeck"]
                index2 = -1
                for mydeck in mydecks:
                    index2 += 1
                    if "eternal" not in mydeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in mydeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 1)
                            or (life == 2 and self.duel.user_turn == 2)
                        ):
                            mydeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            mydeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del mydeck["eternal"][index3]
                    mydecks[index2] = mydeck
                index2 = -1
                for otherdeck in otherdecks:
                    index_list = []
                    index2 += 1
                    if "eternal" not in otherdeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in otherdeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if self.user == 1 and self.duel.user_turn == 1 or self.user == 2 and self.duel.user_turn == 2:
                            pass
                        else:
                            if life == 1:
                                life = 2
                            elif life == 2:
                                life = 1
                        if (
                            life == 3
                            or (life == 1 and self.duel.user_turn == 2)
                            or (life == 2 and self.duel.user_turn == 1)
                        ):
                            otherdeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            otherdeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in reversed(index_list):
                        del otherdeck["eternal"][index3]
                    otherdecks[index2] = otherdeck
                index2 = -1
                self.decks[i]["mydeck"] = mydecks
                self.decks[i]["otherdeck"] = otherdecks

            else:
                index2  = -1
                commondecks = self.decks[i]["commondeck"]
                for commondeck in commondecks:
                    index2 += 1
                    if "eternal" not in commondeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commondeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phase":
                            index += 1
                            continue
                        if int(life[2]) != phase.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in index_list.reverse():
                        del commondeck["eternal"][index3]
                    commondecks[index2] = commondeck
                index2  = -1
                for commondeck in commondecks:
                    index2 += 1
                    if "eternal" not in commondeck:
                        continue
                    index = 0
                    index_list = []
                    for eternal in commondeck["eternal"]:
                        if eternal is None:
                            index += 1
                            continue
                        life = eternal["monster_variable_change_life"].split("_")
                        if life[0] != "phaseend":
                            index += 1
                            continue
                        if int(life[2]) != org.id:
                            index += 1
                            continue
                        life = int(life[1])
                        if life == 3:
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ] -= 1
                        if (
                            commondeck["eternal"][index][
                                "monster_variable_change_life_length"
                            ]
                            == 0
                        ):
                            index_list.append(index)
                        index += 1
                    for index3 in index_list.reverse():
                        del commondeck["eternal"][index3]
                    commondecks[index2] = commondeck
                self.decks[i]["commondeck"] = commondecks

    def move_phase(self):
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        monster_effect_wrapper = MonsterEffectWrapper.objects.get(
            id=int(chain_det[str(duel.chain - 1)])
        )
        monster_effect = monster_effect_wrapper.monster_effect
        monster_effect_text = json.loads(monster_effect.monster_effect)
        org_phase = duel.phase
        duel.phase = Phase.objects.get(id=int(monster_effect_text["move_to_phase"]))
        duel.current_priority = 10000
        self.expire_phase(duel.phase, org_phase,duel.user_turn)

    def move_effect_variable_to_timing(self, cost=0):
        duel = self.duel
        cost = self.cost
        cost = cost[str(int(duel.chain - 1))]
        tmp = self.mess
        tmp = tmp[str(int(duel.chain - 1))]
        chain_det = json.loads(self.duel.chain_det)
        tmp2 = self.timing_mess
        monster_effect_wrapper = MonsterEffectWrapper.objects.get(
            id=int(chain_det[str(duel.chain - 1)])
        )
        monster_effect = monster_effect_wrapper.monster_effect
        monster_effect_text = json.loads(monster_effect.monster_effect)
        from_val_name = monster_effect_text["org_val"]
        from_val_names = from_val_name.split(",")
        to_val_name = monster_effect_text["val"]
        to_val_names = to_val_name.split(",")
        i = 0
        for from_val_name in from_val_names:
            if from_val_name[0] != "~":
                if from_val_name not in tmp:
                    return
                org_val = tmp[from_val_name]
            else:
                if from_val_name not in cost:
                    return
                org_val = cost[from_val_name]
            tmp2[to_val_names[i]] = org_val
            i += 1
        self.timing_mess = tmp2
    def change_once_per_turn(self):
        if self.duel.once_per_turn1 != "":
            self.duel.once_per_turn1 += "_"+self.duel.tmponce_per_turn1 
        else:
            self.duel.once_per_turn1 = self.duel.tmponce_per_turn1
        if self.duel.once_per_turn_group1 != "":
            self.duel.once_per_turn_group1 += "_"+self.duel.tmponce_per_turn_group1 
        else:
            self.duel.once_per_turn_group1 = self.duel.tmponce_per_turn_group1
        if self.duel.once_per_turn_group2 != "":
            self.duel.once_per_turn_group2 += "_"+self.duel.tmponce_per_turn_group2 
        else:
            self.duel.once_per_turn_group2 = self.duel.tmponce_per_turn_group2
        if self.duel.once_per_turn2 != "":
            self.duel.once_per_turn2 += "_"+self.duel.tmponce_per_turn2
        else:
            self.duel.once_per_turn2 = self.duel.tmponce_per_turn2
        if self.duel.once_per_turn_monster_group1 != "":
            self.duel.once_per_turn_monster_group1 += "_"+self.duel.tmponce_per_turn_monster_group1 
        else:
            self.duel.once_per_turn_monster_group1 = self.duel.tmponce_per_turn_monster_group1
        if self.duel.once_per_turn_monster_group2 != "":
            self.duel.once_per_turn_monster_group2 += "_"+self.duel.tmponce_per_turn_monster_group2 
        else:
            self.duel.once_per_turn_monster_group2 = self.duel.tmponce_per_turn_monster_group2
        if self.duel.once_per_turn_monster1 != "":
            self.duel.once_per_turn_monster1 += "_"+self.duel.tmponce_per_turn_monster1
        else:
            self.duel.once_per_turn_monster1 = self.duel.tmponce_per_turn_monster1
        if self.duel.once_per_turn_monster2 != "":
            self.duel.once_per_turn_monster2 += "_"+self.duel.tmponce_per_turn_monster2
        else:
            self.duel.once_per_turn_monster2 = self.duel.tmponce_per_turn_monster2
        if self.duel.once_per_turn_exist1 != "":
            self.duel.once_per_turn_exist1 += "_"+self.duel.tmponce_per_turn_exist1
        else:
            self.duel.once_per_turn_exist1 = self.duel.tmponce_per_turn_exist1
        if self.duel.once_per_turn_exist2 != "":
            self.duel.once_per_turn_exist2 += "_"+self.duel.tmponce_per_turn_exist2
        else:
            self.duel.once_per_turn_exist2 =  self.duel.tmponce_per_turn_exist2
        if self.duel.once_per_turn_relate1 != "":
            self.duel.once_per_turn_relate1 += "_"+self.duel.tmponce_per_turn_relate1
        else:
            self.duel.once_per_turn_relate1 =  self.duel.tmponce_per_turn_relate1
        if self.duel.once_per_turn_relate2 != "":
            self.duel.once_per_turn_relate2 += "_"+self.duel.tmponce_per_turn_relate2
        else:
            self.duel.once_per_turn_relate2 =  self.duel.tmponce_per_turn_relate2
        self.duel.tmponce_per_turn1  = ""           
        self.duel.tmponce_per_turn_group1 = ""
        self.duel.tmponce_per_turn_group2 = ""
        self.duel.tmponce_per_turn_monster_group1 = ""
        self.duel.tmponce_per_turn_monster_group2 = ""
        self.duel.tmponce_per_turn2 = ""
        self.duel.tmponce_per_turn_monster1 = ""
        self.duel.tmponce_per_turn_monster2 = ""
        self.duel.tmponce_per_turn_exist1 = ""
        self.duel.tmponce_per_turn_exist2 = ""
        self.duel.tmponce_per_turn_relate1 = ""
        self.duel.tmponce_per_turn_relate2 = ""

    def change_turn(self, monster_effect):
        duel = self.duel
        self.turn_changed = True
        duel.once_per_turn1 = ""
        duel.once_per_turn2 = ""
        duel.once_per_turn_group1 = ""
        duel.once_per_turn_group2 = ""
        duel.once_per_turn_monster_group1 = ""
        duel.once_per_turn_monster_group2 = ""
        duel.once_per_turn_monster1 = ""
        duel.once_per_turn_monster2 = ""
        duel.once_per_turn_exist1 = ""
        duel.once_per_turn_exist2 = ""
        duel.once_per_turn_relate1 = ""
        duel.once_per_turn_relate2 = ""
        duel.effect_flag = 0
        if self.duel.guest_flag is False:
            user1_name = duel.user_1.first_name
        else:
            user1_name = duel.guest_name
        if self.duel.is_ai is False:
            if self.duel.guest_flag2 is False:
                user2_name = duel.user_2.first_name
            else:
                user2_name = duel.guest_name2
        else:
            user2_name = "NPC"
        if duel.user_turn == 1:
            #duel.change_turn_flag = True
            duel.user_turn = 2
            duel.log_turn = str(duel.turn_count) +"ターン:"+ user2_name + "のターン\n"
            duel.log += duel.log_turn
            self.current_log += duel.log_turn
        elif duel.user_turn == 2 :
            #duel.change_turn_flag = True
            duel.user_turn = 1
            if duel.is_ai is False:
                duel.log_turn = str(duel.turn_count) +"ターン:" + user1_name + "のターン\n"
                duel.log += duel.log_turn
            else:
                duel.log += str(duel.turn_count) +"ターン:" + user1_name + "のターン\n"
                duel.log_turn += str(duel.turn_count) +"ターン:" + user1_name + "のターン\n"
            self.current_log += duel.log_turn
        duel.appoint = duel.user_turn
        self.expire_turn(duel.user_turn)
        if monster_effect.monster_effect != "":
            monster_effect_text = json.loads(monster_effect.monster_effect)
            if monster_effect_text["turn_count_change"] is True:
                duel.turn_count += 1
        else:
            duel.turn_count += 1

    def change_appointment(self):
        duel = self.duel
        if duel.appoint == 1:
            duel.appoint = 2
        elif duel.appoint == 2:
            duel.appoint = 1
        duel.change_appoint_flag = True

    def change_timing(self, timing_id,fresh=True,t_num= 1):
        duel = self.duel
        if timing_id != 0:
            next_timing = Timing.objects.get(id=timing_id)
        else:
            next_timing = None
        if int(t_num) == 1 :
            if duel.timing is not None: 
                self.expire_timing(duel.timing,next_timing, duel.user_turn)
            if timing_id == 0:
                duel.timing = None
            else:
                duel.timing = next_timing
        elif int(t_num) == 2 :
            if duel.timing2 is not None: 
                self.expire_timing(duel.timing2,next_timing, duel.user_turn)
            if timing_id == 0:
                duel.timing2 = None
            else:
                duel.timing2 = next_timing
        elif int(t_num) == 3 :
            if duel.timing3 is not None: 
                self.expire_timing(duel.timing3,next_timing, duel.user_turn)
            if timing_id == 0:
                duel.timing3 = None
            else:
                duel.timing3 = next_timing
        duel.current_priority = 10000
        duel.timing_fresh = fresh

    def change_variable_multiple_cost(self, cost_det):
        self.change_variable_multiple(1, None, cost_det)

    def change_variable_cost(self):
        return self.change_variable(1)

    def change_variable_multiple(self, cost=0, user=None, monster_effect_wrapper=None):
        duel = self.duel
        chain_user = json.loads(self.duel.chain_user)
        if cost == 0:
            if user is None:
                user = chain_user[str(duel.chain - 1)]
            effect_kind = monster_effect_wrapper.monster_effect_kind
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_texts = json.loads(monster_effect.monster_effect)
        else:
            user = chain_user[str(self.tmp_chain)]
            cost_wrapper = monster_effect_wrapper
            cost = cost_wrapper.cost
            monster_effect_texts = json.loads(cost.cost)
        variable = json.loads(duel.global_variable)
        for monster_effect_text in monster_effect_texts:
            variable_id = monster_effect_text["variable_name"].split("_")
            mine_or_other = int(variable_id[2])
            variable_id = variable_id[1]
            change_val = self.calculate_boland(
                monster_effect_text["variable_change_val"]
            )
            if duel.alt_global != "":
                alt_val = self.change_alt_global2(
                    variable_id,
                    mine_or_other,
                    monster_effect_text["variable_change_how"],
                    effect_kind,
                    change_val,
                )
                change_val -= alt_val
                instead_val = self.check_variable_instead(
                    variable_id, mine_or_other, change_val, 1, user, effect_kind
                )
                change_val -= instead_val
            if mine_or_other == 0:
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["value"] = change_val
            elif (mine_or_other == 1 and user == 1) or (
                mine_or_other == 2 and user == 2
            ):
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["1_value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["1_value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["1_value"] = change_val
            elif (mine_or_other == 2 and user == 1) or (
                mine_or_other == 1 and user == 2
            ):
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["2_value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["2_value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["2_value"] = change_val
        duel.global_variable = json.dumps(variable)
        return change_val

    def change_variable_by_monster_cost(self):
        return self.change_variable_by_monster(1)

    def change_variable_by_monster(self, cost=0):
        exclude = ""
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(self.duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_condition = monster_effect.monster_condition
            monster_effect_text = json.loads(monster_effect.monster_effect)
            effect_kind = monster_effect_wrapper.monster_effect_kind
            effect_kind_rel = monster_effect_wrapper.monster_effect_kind_rel
            accumulate_flag = monster_effect.accumulate_flag
        else:
            chain_user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost = cost_wrapper.cost
            monster_condition = cost.cost_condition
            monster_effect_text = json.loads(cost.cost)
            effect_kind = cost_wrapper.cost_kind
            effect_kind_rel = cost_wrapper.cost_kind_rel
            accumulate_flag = False
        variable_id = monster_effect_text["variable_name"].split("_")
        mine_or_other = int(variable_id[2])
        mine_or_other_val = int(variable_id[2])
        variable_id = variable_id[1]
        variable = json.loads(duel.global_variable)
        monster_effect_monster = monster_effect_text["monster"]
        monsters = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        # まずは対象のモンスターを洗い出す
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                for place2 in place1:
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if "place_unique_id" in place2:
                            place_unique_id = place2["place_unique_id"]

                            if "det" not in field[x][y] or field[x][y]["det"] is None:
                                continue
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,place_unique_id)
                                if x == -1:
                                    continue
                            else:
                                if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                    continue
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if monster_condition != "":
                                if not self.validate_answer(
                                    tmp2, monster_condition, "", duel
                                ):
                                    continue
                            monsters.append(tmp2)
                            continue
                    mine_or_other = int(place2["mine_or_other"])
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (self.user == 1 and mine_or_other == 1) or (
                        2 == self.user and mine_or_other == 2
                    ):
                        mine_or_other = 1
                    elif (self.user != 1 and mine_or_other == 1) or (
                        1 == self.user and mine_or_other == 2
                    ):
                        mine_or_other = 2
                    else:
                        mine_or_other = 3
                    if place == "deck":
                        if mine_or_other == 1:
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other == 2:
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if not self.check_not_effected(
                                    user_decks[index],
                                    chain_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    place2["mine_or_other"],
                                    cost,
                                ):
                                    tmp2 = {}
                                    tmp2["det"] = user_decks[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "deck"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_decks[index][
                                        "place_unique_id"
                                    ]
                                    if monster_condition != "":
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    monsters.append(tmp2)

                    if place == "grave":
                        if mine_or_other == 1:
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == 2:
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if not self.check_not_effected(
                                    user_graves[index],
                                    chain_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                                    cost,
                                ):
                                    tmp2 = {}
                                    tmp2["det"] = user_graves[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "grave"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_graves[index][
                                        "place_unique_id"
                                    ]
                                    if monster_condition != "":
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    monsters.append(tmp2)
                    if place == "hand":
                        if mine_or_other == 1:
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == 2:
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if not self.check_not_effected(
                                    user_hands[index],
                                    chain_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                                    cost,
                                ):
                                    tmp2 = {}
                                    tmp2["det"] = user_hands[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "hand"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_hands[index][
                                        "place_unique_id"
                                    ]
                                    if monster_condition != "":
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    monsters.append(tmp2)

        field = self.field
        for monster_effect_det2 in monster_effect_monster:
            min_equation_number = self.calculate_boland(
                monster_effect_det2["min_equation_number"]
            )
            monster_effect_det = monster_effect_det2["monster"]
            field_tmp = []
            tmp_deck = None
            for place in monster_effect_det["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        user_decks = org_deck

                    if not tmp_deck:
                        return [monsters, 0]
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_decks)):
                            if not self.check_not_effected(
                                user_decks[index3],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                tmp2 = {}
                                tmp2["det"] = user_decks[index3]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_decks[index3][
                                    "place_unique_id"
                                ]
                                monsters.append(tmp2)
                        continue
                    elif monster_effect["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_decks[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_decks[range_i],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                tmp2 = {}
                                tmp2["det"] = user_decks[range_i]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_decks[range_i][
                                    "place_unique_id"
                                ]
                                monsters.append(tmp2)
                elif place_tmp[0] == "grave":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["commongrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["commongrave"]
                        user_graves = org_grave
                    if not tmp:
                        return [monsters, 0]
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_graves)):
                            if not self.check_not_effected(
                                user_graves[index3],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                tmp2 = {}
                                tmp2["det"] = user_graves[index3]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_graves[index3][
                                    "place_unique_id"
                                ]
                                monsters.append(tmp2)
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_graves[range_i],
                            chain_user,
                            effect_kind,
                            "grave",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            # log表示用
                            tmp2 = {}
                            tmp2["det"] = user_graves[range_i]
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = chain_user
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_graves[range_i][
                                "place_unique_id"
                            ]
                            monsters.append(tmp2)
                elif place_tmp[0] == "hand":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["commonhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["commonhand"]
                        user_hands = org_hand
                    if not user_hands:
                        return [monsters, 0]
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_hands)):
                            if not self.check_not_effected(
                                user_hands[index3],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                # log表示用
                                tmp2 = {}
                                tmp2["det"] = user_hands[index3]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_hands[index3][
                                    "place_unique_id"
                                ]
                                monsters.append(tmp2)
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_hands[range_i],
                            chain_user,
                            effect_kind,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            # log表示用
                            tmp2 = {}
                            tmp2["det"] = user_hands[range_i]
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = chain_user
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_hands[range_i][
                                "place_unique_id"
                            ]
                            monsters.append(tmp2)
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    effect_user = chain_user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.validate_answer(
                                tmp2, monster_effect_det, exclude, duel
                            ):
                                monsters.append(tmp2)

        change_val = 0
        mine_or_other_absolute = mine_or_other_val
        if chain_user == 1:
            pass
        elif mine_or_other_val == 1:
            mine_or_other_absolute = 2
        elif mine_or_other_val == 2:
            mine_or_other_absolute = 1
        for monster in monsters:
            change_val_det = self.calculate_boland(
                monster_effect_text["variable_change_val"],
                monster,
                False,
                0,
                None,
                effect_kind_rel,
            )
            change_val += change_val_det
            if accumulate_flag is False:
                self.raise_trigger_change_val(
                    monster, change_val_det, cost, effect_kind, chain_user, 1
                )
            if accumulate_flag is True:
                global_name = {}
                global_name["mine_or_other"] = mine_or_other_absolute
                global_name["variable_id"] = variable_id
                global_name["variable_how"] = monster_effect_text["variable_change_how"]
                self.accumulate_global(
                    monster, change_val_det, cost, effect_kind, chain_user, global_name
                )
            if duel.alt_global != "":
                alt_val = self.change_alt_global2(
                    variable_id,
                    mine_or_other_absolute,
                    monster_effect_text["variable_change_how"],
                    effect_kind,
                    change_val,
                )
                change_val -= alt_val
                instead_val = self.check_variable_instead(
                    variable_id,
                    mine_or_other_absolute,
                    change_val,
                    cost,
                    chain_user,
                    effect_kind,
                )
                change_val -= instead_val
                if accumulate_flag is False:
                    self.raise_trigger_change_val(
                        monster, change_val_det, cost, effect_kind, chain_user, 0
                    )
        if cost == 1:
            cost_result = self.cost_result
            if "global_change_val" not in cost_result:
                cost_result["global_change_val"] = []
            tmp = {}
            tmp["mine_or_other"] = mine_or_other_absolute
            tmp["variable"] = variable
            tmp["variable_id"] = variable_id
            tmp["change_val"] = change_val
            tmp["change_how"] = monster_effect_text["variable_change_how"]
            cost_result["global_change_val"].append(tmp)
            self.cost_result = cost_result
        elif accumulate_flag is False:
            if mine_or_other_absolute == 0:
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["value"] = change_val
            elif mine_or_other_absolute == 1:
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["1_value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["1_value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["1_value"] = change_val
            elif mine_or_other_absolute == 2:
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["2_value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["2_value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["2_value"] = change_val
            duel.global_variable = json.dumps(variable)
        return [monsters, change_val]

    def change_alt_global(self, cost=0):
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(self.duel.chain_user)
        if cost == 0:
            user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_text = json.loads(monster_effect.monster_effect)
            effect_kind = monster_effect_wrapper.monster_effect_kind
        else:
            user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            effect_kind = cost_wrapper.cost_kind
            cost_unwrap = cost_wrapper.cost
            monster_effect_text = json.loads(cost_unwrap.cost)
        variable_id = monster_effect_text["variable_name"].split("_")
        mine_or_other = int(variable_id[2])
        variable_id = variable_id[1]
        change_val = int(monster_effect_text["variable_change_val"])

        if duel.alt_global != "":
            variable = json.loads(duel.alt_global)
        else:
            variable = {}
        global_name = {}
        if (mine_or_other == 1 and user == 1) or (mine_or_other == 2 and user == 2):
            global_name["mine_or_other"] = 1
        elif (mine_or_other == 1 and user == 2) or (mine_or_other == 1 and user == 2):
            global_name["mine_or_other"] = 2
        else:
            global_name["mine_or_other"] = 3
        global_name["variable_id"] = variable_id
        if str(variable_id) not in variable:
            variable[str(variable_id)] = {}
        if mine_or_other == 0:
            if "value" not in variable[str(variable_id)]:
                variable[str(variable_id)]["value"] = 0
                variable[str(variable_id)]["effect_kind"] = effect_kind
            if monster_effect_text["variable_change_how"] == 0:
                variable[str(variable_id)]["value"] += change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
            elif monster_effect_text["variable_change_how"] == 1:
                variable[str(variable_id)]["value"] -= change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
            elif monster_effect_text["variable_change_how"] == 2:
                variable[str(variable_id)]["value"] = change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
        elif (mine_or_other == 1 and user == 1) or (mine_or_other == 2 and user == 2):
            if "1_value" not in variable[str(variable_id)]:
                variable[str(variable_id)]["1_value"] = 0
                variable[str(variable_id)]["effect_kind"] = effect_kind
            if monster_effect_text["variable_change_how"] == 0:
                variable[str(variable_id)]["1_value"] += change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
            elif monster_effect_text["variable_change_how"] == 1:
                variable[str(variable_id)]["1_value"] -= change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
            elif monster_effect_text["variable_change_how"] == 2:
                variable[str(variable_id)]["1_value"] = change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
        elif (mine_or_other == 2 and user == 1) or (mine_or_other == 1 and user == 2):
            if "2_value" not in variable[str(variable_id)]:
                variable[str(variable_id)]["2_value"] = 0
                variable[str(variable_id)]["effect_kind"] = effect_kind
            if monster_effect_text["variable_change_how"] == 0:
                variable[str(variable_id)]["2_value"] += change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
            elif monster_effect_text["variable_change_how"] == 1:
                variable[str(variable_id)]["2_value"] -= change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
            elif monster_effect_text["variable_change_how"] == 2:
                variable[str(variable_id)]["2_value"] = change_val
                variable[str(variable_id)]["effect_kind"] = effect_kind
        duel.alt_global = json.dumps(variable)
        return change_val

    def change_alt_global2(
        self,
        variable_id,
        mine_or_other,
        variable_change_how,
        effect_kind,
        change_val,
    ):
        duel = self.duel
        alt_val = 0
        alt_global = json.loads(self.duel.alt_global)
        if str(variable_id) in alt_global:
            if mine_or_other == 0 and variable_change_how == 1:
                if "value" in alt_global[str(variable_id)]:
                    if self.check_effect_kind(
                        alt_global[str(variable_id)]["effect_kind"], effect_kind
                    ):
                        alt_val = min(change_val, alt_global[str(variable_id)]["value"])
                        alt_global[str(variable_id)]["value"] -= alt_val
                        change_val -= alt_val
                        duel.alt_global = json.dumps(alt_global)
            if (
                (mine_or_other == 1 )
                and variable_change_how == 1
            ):
                if "1_value" in alt_global[str(variable_id)]:
                    if self.check_effect_kind(
                        alt_global[str(variable_id)]["effect_kind"], effect_kind
                    ):
                        alt_val = min(
                            change_val, alt_global[str(variable_id)]["1_value"]
                        )
                        alt_global[str(variable_id)]["1_value"] -= alt_val
                        change_val -= alt_val
                        duel.alt_global = json.dumps(alt_global)
            if (
                (mine_or_other == 2 )
                and variable_change_how == 1
            ):
                if "2_value" in alt_global[str(variable_id)]:
                    if self.check_effect_kind(
                        alt_global[str(variable_id)]["effect_kind"], effect_kind
                    ):
                        alt_val = min(
                            change_val, alt_global[str(variable_id)]["2_value"]
                        )
                        alt_global[str(variable_id)]["2_value"] -= alt_val
                        change_val -= alt_val
                        self.duel.alt_global = json.dumps(alt_global)
        return alt_val

    def change_show(self, cost=0,monster_effect= None):
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(self.duel.chain_user)
        user = chain_user[str(duel.chain - 1)]
        monster_effect_wrapper = MonsterEffectWrapper.objects.get(
            id=int(chain_det[str(duel.chain - 1)])
        )
        monster_effect = monster_effect_wrapper.monster_effect
        monster_effect_text = json.loads(monster_effect.monster_effect)
        variable = json.loads(duel.global_variable)
        variable_id = monster_effect_text["variable_name"].split("_")
        mine_or_other = int(variable_id[2])
        variable_id = variable_id[1]
        global_name = {}
        if (mine_or_other == 1 and user == 1) or (mine_or_other == 2 and user == 2):
            global_name["mine_or_other"] = 1
        elif (mine_or_other == 2 and user == 1) or (mine_or_other == 1 and user == 2):
            global_name["mine_or_other"] = 2
        else:
            global_name["mine_or_other"] = 0
        global_name["variable_id"] = variable_id
        global_name["variable_how"] = monster_effect_text["variable_change_how"]
        if mine_or_other == 0:
            if monster_effect_text["variable_change_how"] == 0:
                variable[str(variable_id)]["show"] = 0
            elif monster_effect_text["variable_change_how"] == 1:
                variable[str(variable_id)]["show"] = 1
        elif (mine_or_other == 1 and user == 1) or (
            mine_or_other == 2 and user == 2
        ):
            if monster_effect_text["variable_change_how"] == 0:
                variable[str(variable_id)]["1_show"] = 0 
            elif monster_effect_text["variable_change_how"] == 1:
                variable[str(variable_id)]["1_show"] = 1
        elif (mine_or_other == 2 and user == 1) or (
            mine_or_other == 1 and user == 2
        ):
            if monster_effect_text["variable_change_how"] == 0:
                variable[str(variable_id)]["2_show"] = 0
            elif monster_effect_text["variable_change_how"] == 1:
                variable[str(variable_id)]["2_show"] = 1
        duel.global_variable = json.dumps(variable)
        return  monster_effect_text["variable_change_how"] 
    def change_variable(self, cost=0,monster_effect= None):

        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(self.duel.chain_user)
        if cost == 0:
            user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_text = json.loads(monster_effect.monster_effect)
            effect_kind = monster_effect_wrapper.monster_effect_kind
            change_val_flag = monster_effect.change_val_monster_flag
            accumulate_flag = monster_effect.accumulate_flag
        elif cost ==1:
            user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            effect_kind = cost_wrapper.cost_kind
            cost_unwrap = cost_wrapper.cost
            monster_effect_text = json.loads(cost_unwrap.cost)
            change_val_flag = False
            accumulate_flag = False
        else:
            user  = self.user
            monster_effect_text = json.loads(monster_effect.monster_effect)
            effect_kind = ""
            change_val_flag = False
            accumulate_flag = False
        variable_id = monster_effect_text["variable_name"].split("_")
        mine_or_other = int(variable_id[2])
        variable_id = variable_id[1]
        variable = json.loads(duel.global_variable)
        global_name = {}
        if (mine_or_other == 1 and user == 1) or (mine_or_other == 2 and user == 2):
            global_name["mine_or_other"] = 1
        elif (mine_or_other == 2 and user == 1) or (mine_or_other == 1 and user == 2):
            global_name["mine_or_other"] = 2
        else:
            global_name["mine_or_other"] = 0
        global_name["variable_id"] = variable_id
        global_name["variable_how"] = monster_effect_text["variable_change_how"]
        if change_val_flag is True:
            change_val = self.calculate_boland(
                monster_effect_text["variable_change_val"],
                None,
                False,
                0,
                None,
                "",
                variable_id,
                effect_kind,
                accumulate_flag,
                global_name,
            )
        else:
            change_val = self.calculate_boland(
                monster_effect_text["variable_change_val"],
                None,
                False,
                0,
                None,
                "",
                False,
                effect_kind,
                accumulate_flag,
                global_name,
            )
        if accumulate_flag is True:
            change_val = 0
        if cost == 1:
            cost_result = self.cost_result
            if "global_change_val" not in cost_result:
                cost_result["global_change_val"] = []
            tmp = {}
            tmp["mine_or_other"] = mine_or_other
            tmp["variable"] = variable
            tmp["variable_id"] = variable_id
            tmp["change_val"] = change_val
            tmp["change_how"] = monster_effect_text["variable_change_how"]
            cost_result["global_change_val"].append(tmp)
            self.cost_result = cost_result
        else:
            if duel.alt_global != "":
                alt_val = self.change_alt_global2(
                    variable_id,
                    mine_or_other,
                    monster_effect_text["variable_change_how"],
                    effect_kind,
                    change_val,
                )
                change_val -= alt_val
                instead_val = self.check_variable_instead(
                    variable_id,
                    mine_or_other,
                    change_val,
                    cost,
                    chain_user,
                    effect_kind,
                )
                change_val -= instead_val

            if mine_or_other == 0:
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["value"] = change_val
            elif (mine_or_other == 1 and user == 1) or (
                mine_or_other == 2 and user == 2
            ):
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["1_value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["1_value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["1_value"] = change_val
            elif (mine_or_other == 2 and user == 1) or (
                mine_or_other == 1 and user == 2
            ):
                if monster_effect_text["variable_change_how"] == 0:
                    variable[str(variable_id)]["2_value"] += change_val
                elif monster_effect_text["variable_change_how"] == 1:
                    variable[str(variable_id)]["2_value"] -= change_val
                elif monster_effect_text["variable_change_how"] == 2:
                    variable[str(variable_id)]["2_value"] = change_val
            duel.global_variable = json.dumps(variable)
        return change_val

    def change_monster_relation_cost(
        self, monster_effect, effect_kind, monster_condition
    ):
        self.change_monster_relation(monster_effect, effect_kind, monster_condition, 1)

    def copy_monster_det_specify(self, monster, monster_effect, effect_kind):
        if "eternal" not in monster:
            monster["eternal"] = []
        tmp = {}
        copy_monster = Monster.objects.get(id=int(monster_effect["monster"][0]["monster"]["monster_effect"]))
        if monster_effect["copy_id"] is True:
            tmp["id"] = int(monster_effect["monster"][0]["monster"]["monster_effect"])
        if monster_effect["copy_monster_name"] is True:
            tmp["monster_name"] = copy_monster.monster_name
        tmp["monster_variable_change_life"] = monster_effect[
            "monster_variable_change_life"
        ][0]
        tmp["monster_variable_change_life_length"] = monster_effect[
            "monster_variable_change_life_length"
        ][0]
        tmp["variables"] = {}

        tmp["effect_kind"] = effect_kind
        monster["eternal"].append(tmp)
        return monster
    def copy_monster_det(self, monster, copy_monster, monster_effect, effect_kind):
        if "eternal" not in monster:
            monster["eternal"] = []
        tmp = {}
        if monster_effect["copy_id"] is True:
            id = self.get_monster_id(
                copy_monster[-1]["det"], copy_monster[-1]["place"], 0, 0, 0, 0, 0
            )
            tmp["id"] = id
        if monster_effect["copy_monster_name"] is True:
            tmp["monster_name"] = copy_monster[-1]["det"]["monster_name"]
        tmp["monster_variable_change_life"] = monster_effect[
            "monster_variable_change_life"
        ][0]
        tmp["monster_variable_change_life_length"] = monster_effect[
            "monster_variable_change_life_length"
        ][0]
        tmp["variables"] = {}

        j = 0
        for monster_variable in monster_effect["copy_monster_variables"]:
            ini_from = monster_effect["copy_monster_variables_from_initial"][j]
            tmp["variables"][monster_variable] = {}
            tmp_variable = copy_monster[-1]["det"]["variables"][monster_variable][
                "value"
            ]
            if "eternal" in copy_monster[-1]["det"]:
                for i in range(len(copy_monster[-1]["det"]["eternal"])):
                    if (
                        copy_monster[-1]["det"]["eternal"][i] is not None
                        and monster_variable in copy_monster[-1]["det"]["eternal"][i]["variables"]
                    ):
                        if (
                            copy_monster[-1]["det"]["eternal"][i]["variables"][
                                monster_variable
                            ]["ini"]
                            == 0
                            and ini_from is True
                        ):
                            continue
                        else:
                            tmp_variable += copy_monster[-1]["det"]["eternal"][i][
                                "variables"
                            ][monster_variable]["value"]
            tmp["variables"][monster_variable]["value"] = tmp_variable
            if monster_effect["copy_monster_variables_to_initial"][j] is True:
                tmp["variables"][monster_variable]["ini"] = True
            else:
                tmp["variables"][monster_variable]["ini"] = False
            j += 1
        tmp["effect_kind"] = effect_kind
        monster["eternal"].append(tmp)
        return monster

    def copy_monster_cost(self, monster_effect, monster_condition, effect_kind):
        return self.copy_monster(monster_effect, monster_condition, effect_kind, 1)

    def copy_monster_specify(self, monster_effect, monster_condition, effect_kind, cost=0):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        return_value = {}
        return_value["monsters"] = []
        return_value["monsters2"] = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        if len(monster_effect["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect:
                if monster_effect["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect["monster_variable_change_name"])):
                variable_name = monster_effect["monster_variable_change_name"][index]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect["monster_variable_change_val"][index],
                        None,
                        False,
                        1,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    place1 = tmp[as_monster]
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    place1 = tmp[as_monster]
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    place1 = tmp[as_monster]
                for place2 in reversed(place1):
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if cost == 0:
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.config.sort is True:
                                    x = self.search_place_unique_id(y,place_unique_id)
                                    if x == -1:
                                        continue
                                if (
                                        "det" not in field[x][y]
                                        or field[x][y]["det"] is None
                                        or field[x][y]["det"]["place_unique_id"]
                                        != place_unique_id
                                ):
                                    continue
                                if self.check_not_effected(
                                        field[x][y]["det"],
                                        chain_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if monster_condition != "":
                                    if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                field[x][y]["det"] = self.copy_monster_det_specify(
                                    field[x][y]["det"],
                                    monster_effect,
                                    effect_kind,
                                )
                                if change_val_eternal is not None:
                                    if "eternal" not in field[x][y]["det"]:
                                        field[x][y]["det"]["eternal"] = []
                                    field[x][y]["det"]["eternal"].append(
                                        change_val_eternal
                                    )
                                self.field = field
                                continue

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (chain_user == 1 and mine_or_other == "1") or (
                            chain_user != 1 and mine_or_other == "2"
                    ):
                        mine_or_other_for_cost_copy = 1
                    elif (1 != chain_user and mine_or_other == "1") or (
                            chain_user == 1 and mine_or_other == "2"
                    ):
                        mine_or_other_for_cost_copy = 2
                    else:
                        mine_or_other_for_cost_copy = 3
                    if (self.user == chain_user and mine_or_other == "1") or (
                            chain_user != self.user and mine_or_other == "2"
                    ):
                        mine_or_other = "1"
                    elif (self.user != chain_user and mine_or_other == "1") or (
                            chain_user == self.user and mine_or_other == "2"
                    ):
                        mine_or_other = "2"
                    else:
                        mine_or_other = "3"
                    if place == "deck":
                        if mine_or_other == "1":
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other == "2":
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_decks[index],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            place2["mine_or_other"],
                                            cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_decks[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_decks[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        return_value["monsters"].append(tmp2)
                                        user_decks[index] = self.copy_monster_det_specify(
                                            user_decks[index],
                                            monster_effect,
                                            effect_kind,
                                        )
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[index]:
                                                user_decks[index]["eternal"] = []
                                            user_decks[index]["eternal"].append(
                                                change_val_eternal
                                            )
                                    if mine_or_other == "1":
                                        self.decks[deck_id]["mydeck"] = user_decks
                                    elif mine_or_other == "2":
                                        self.decks[deck_id]["otherdeck"] = user_decks
                                    else:
                                        self.decks[deck_id]["commondeck"] = user_decks

                    if place == "grave":
                        if mine_or_other == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_graves[index],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            place2["mine_or_other"],
                                            cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        return_value["monsters"].append(tmp2)
                                        user_graves[index] = self.copy_monster_det_specify(
                                            user_graves[index],
                                            monster_effect,
                                            effect_kind,
                                        )
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[index]:
                                                user_graves[index]["eternal"] = []
                                            user_graves[index]["eternal"].append(
                                                change_val_eternal
                                            )
                                    if mine_or_other == "1":
                                        self.graves[deck_id]["mygrave"] = user_graves
                                    elif mine_or_other == "2":
                                        self.graves[deck_id]["othergrave"] = user_graves
                                    else:
                                        self.graves[deck_id][
                                            "commongrave"
                                        ] = user_graves

                    if place == "hand":
                        if mine_or_other == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_hands[index],
                                            chain_user,
                                            effect_kind,
                                            "hand",
                                            deck_id,
                                            0,
                                            0,
                                            place2["mine_or_other"],
                                            cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        return_value["monsters"].append(tmp2)
                                        user_hands[index] = self.copy_monster_det_specify(
                                            user_hands[index],
                                            monster_effect,
                                            effect_kind,
                                        )
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[index]:
                                                user_hands[index]["eternal"] = []
                                            user_hands[index]["eternal"].append(
                                                change_val_eternal
                                            )
                                    if mine_or_other == "1":
                                        self.hands[deck_id]["myhand"] = user_hands
                                    elif mine_or_other == "2":
                                        self.hands[deck_id]["otherhand"] = user_hands
                                    else:
                                        self.hands[deck_id]["commonhand"] = user_hands
        for monster_effect_det2 in monster_effect_monster:
            monster_effect_det = monster_effect_det2["monster"]
            field_tmp = []
            tmp_deck = None
            for place in monster_effect_det["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                                place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                                place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if self.user == duel.user_turn:
                            mine_or_other3 = mine_or_other2
                        else:
                            if mine_or_other2 == 1:
                                mine_or_other3 = 2
                            elif mine_or_other2 == 2:
                                mine_or_other3 = 1
                            else:
                                mine_or_other3 = mine_or_other2
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        user_decks = org_deck

                    if not tmp_deck:
                        return
                    min_equation_number = self.calculate_boland(
                        monster_effect_det["min_equation_number"], None, False
                    )
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_decks)):
                            if not self.check_not_effected(
                                    user_decks[index3],
                                    chain_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                                    cost,
                            ):
                                for index2 in range(
                                        len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[index3]:
                                                user_decks[index3]["eternal"] = []
                                            user_decks[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    if cost == 0:
                                        if not self.check_not_effected(
                                                user_decks[index3],
                                                chain_user,
                                                effect_kind,
                                                "deck",
                                                deck_id,
                                                0,
                                                0,
                                                mine_or_other,
                                                cost,
                                        ):
                                            tmp2 = {}
                                            tmp2["det"] = user_decks[index3]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_decks[
                                                index3
                                            ]["place_unique_id"]
                                            return_value["monsters"].append(tmp2)
                                            user_decks[index3] = self.copy_monster_det_specify(
                                                user_decks[index3],
                                                monster_effect,
                                                effect_kind,
                                            )
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                    place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                    place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif mine_or_other2 == 2:
                                self.decks[deck_id]["otherdeck"] = user_decks
                            else:
                                self.decks[deck_id]["commondeck"] = user_decks
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_decks[range_i]["variables"])):
                            if not self.check_not_effected(
                                    user_decks[range_i],
                                    chain_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                                    cost,
                            ):
                                for index2 in range(
                                        len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[range_i]:
                                                user_decks[range_i]["eternal"] = []
                                            user_decks[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_decks[
                                            range_i
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_decks[range_i],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_decks[range_i]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_decks[range_i][
                                            "place_unique_id"
                                        ]
                                        return_value["monsters"].append(tmp2)
                                        user_decks[range_i] = self.copy_monster_det_specify(
                                            user_decks[range_i],
                                            monster_effect,
                                            effect_kind,
                                        )

                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        else:
                            self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                                place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                                place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["commongrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["commongrave"]
                        user_graves = org_grave

                    if not tmp_grave:
                        return
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_graves)):
                            if not self.check_not_effected(
                                    user_graves[index3],
                                    chain_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                            ):
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_graves[index3],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[index3]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[index3][
                                            "place_unique_id"
                                        ]
                                        return_value["monsters"].append(tmp2)
                                        user_graves[index3] = self.copy_monster_det_specify(
                                            user_graves[index3],
                                            monster_effect,
                                            effect_kind,
                                        )
                                for index2 in range(
                                        len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[index3]:
                                                user_graves[index3]["eternal"] = []
                                            user_graves[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                    place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                    place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_graves[range_i]["variables"])):
                            if not self.check_not_effected(
                                    user_graves[range_i],
                                    chain_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                            ):
                                for index2 in range(
                                        len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[range_i]:
                                                user_graves[range_i]["eternal"] = []
                                            user_graves[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_graves[range_i],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[range_i]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[range_i][
                                            "place_unique_id"
                                        ]
                                        return_value["monsters"].append(
                                            user_graves[range_i]
                                        )
                                        user_graves[range_i] = self.copy_monster_det_specify(
                                            user_graves[range_i],
                                            monster_effect,
                                            effect_kind,
                                        )
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.graves[deck_id]["mygrave"] = user_graves
                        elif mine_or_other2 == 2:
                            self.graves[deck_id]["othergrave"] = user_graves
                        else:
                            self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                                place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                                place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_hand = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_hand = self.get_hand_with_effect(
                                self.hands[deck_id]["commonhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["commonhand"]
                        user_hands = org_hand

                    if not tmp_hand:
                        return
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_hands)):
                            if not self.check_not_effected(
                                    user_hands[index3],
                                    chain_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                            ):
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_hands[index3],
                                            chain_user,
                                            effect_kind,
                                            "hand",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[index3]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[index3][
                                            "place_unique_id"
                                        ]
                                        return_value["monsters"].append(tmp2)
                                        user_hands[index3] = self.copy_monster_det_spcify(
                                            user_hands[index3],
                                            monster_effect,
                                            effect_kind,
                                        )
                                for index2 in range(
                                        len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[index3]:
                                                user_hands[index3]["eternal"] = []
                                            user_hands[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                    place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                    place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_hands[range_i]["variables"])):
                            if not self.check_not_effected(
                                    user_hands[range_i],
                                    chain_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other,
                            ):
                                for index2 in range(
                                        len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[range_i]:
                                                user_hands[range_i]["eternal"] = []
                                            user_hands[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_hands[range_i],
                                            chain_user,
                                            effect_kind,
                                            "hand",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[range_i]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[range_i][
                                            "place_unique_id"
                                        ]
                                        return_value["monsters"].append(tmp2)
                                        user_hands[range_i] = self.copy_monster_det_specify(
                                            user_hands[range_i],
                                            monster_effect,
                                            effect_kind,
                                        )
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        else:
                            self.hands[deck_id]["commonhand"] = user_hands
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                            place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.check_not_effected(
                                    field[x][y]["det"],
                                    chain_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                            ):
                                continue
                            if self.validate_answer(
                                    tmp2, monster_effect_det, exclude, duel
                            ):
                                if cost == 0:
                                    return_value["monsters"].append(tmp2)
                                    field[x][y]["det"] = self.copy_monster_det_specify(
                                        field[x][y]["det"],
                                        monster_effect,
                                        effect_kind,
                                    )

        self.field = field
        return return_value
    def copy_monster(self, monster_effect, monster_condition, effect_kind, cost=0):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        return_value = {}
        return_value["monsters"] = []
        return_value["monsters2"] = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        if len(monster_effect["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect:
                if monster_effect["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect["monster_variable_change_name"])):
                variable_name = monster_effect["monster_variable_change_name"][index]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect["monster_variable_change_val"][index],
                        None,
                        False,
                        1,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    place1 = tmp[as_monster]
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    place1 = tmp[as_monster]
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    place1 = tmp[as_monster]
                for place2 in reversed(place1):
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if cost == 0:
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.config.sort is True:
                                    x = self.search_place_unique_id(y,place_unique_id)
                                    if x == -1:
                                        continue
                                if (
                                    "det" not in field[x][y]
                                    or field[x][y]["det"] is None
                                    or field[x][y]["det"]["place_unique_id"]
                                    != place_unique_id
                                ):
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    chain_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if monster_condition != "":
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                relation_monster = self.get_as_monster(
                                    monster_effect["copy_monster"]
                                )
                                if not relation_monster:
                                    return return_value
                                return_value["monsters"].append(tmp2)
                                return_value["monsters2"].append(relation_monster[-1])
                                field[x][y]["det"] = self.copy_monster_det(
                                    field[x][y]["det"],
                                    relation_monster,
                                    monster_effect,
                                    effect_kind,
                                )
                                self.field = field
                                continue
                        else:
                            place_unique_id = place2["place_unique_id"]
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,place_unique_id)
                                if x == -1:
                                    continue
                            else:
                                if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                    continue
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            if monster_condition != "":
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_condition, "", duel
                                ):
                                    continue
                            cost_result = self.cost_result

                            if "copy" not in cost_result:
                                cost_result["copy"] = {}
                            if "field" not in cost_result["copy"]:
                                cost_result["copy"]["field"] = []
                            cost_result_tmp = {}
                            relation_monster = self.get_as_monster(
                                monster_effect["copy_monster"]
                            )
                            if not relation_monster:
                                return return_value
                            cost_result_tmp["copy_monster"] = relation_monster
                            cost_result_tmp["cost_det"] = monster_effect
                            cost_result_tmp["effect_kind"] = effect_kind
                            cost_result_tmp["x"] = x
                            cost_result_tmp["y"] = y
                            cost_result_tmp["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            cost_result["copy"]["field"].append(cost_result_tmp)
                            cost_result_tmp["det"] = field[x][y]["det"]
                            return_value["monsters"].append(cost_result_tmp)
                            return_value["monsters2"].append(relation_monster[-1])
                            self.cost_result = cost_result
                            continue

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (chain_user == 1 and mine_or_other == "1") or (
                        chain_user != 1 and mine_or_other == "2"
                    ):
                        mine_or_other_for_cost_copy = 1
                    elif (1 != chain_user and mine_or_other == "1") or (
                        chain_user == 1 and mine_or_other == "2"
                    ):
                        mine_or_other_for_cost_copy = 2
                    else:
                        mine_or_other_for_cost_copy = 3
                    if (self.user == chain_user and mine_or_other == "1") or (
                        chain_user != self.user and mine_or_other == "2"
                    ):
                        mine_or_other = "1"
                    elif (self.user != chain_user and mine_or_other == "1") or (
                        chain_user == self.user and mine_or_other == "2"
                    ):
                        mine_or_other = "2"
                    else:
                        mine_or_other = "3"
                    if place == "deck":
                        if mine_or_other == "1":
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other == "2":
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_decks[index],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        place2["mine_or_other"],
                                        cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_decks[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_decks[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_decks[index] = self.copy_monster_det(
                                            user_decks[index],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                    if mine_or_other == "1":
                                        self.decks[deck_id]["mydeck"] = user_decks
                                    elif mine_or_other == "2":
                                        self.decks[deck_id]["otherdeck"] = user_decks
                                    else:
                                        self.decks[deck_id]["commondeck"] = user_decks
                                else:
                                    cost_result = self.cost_result

                                    if "copy" not in cost_result:
                                        cost_result["copy"] = {}
                                    if "deck" not in cost_result["copy"]:
                                        cost_result["copy"]["deck"] = []
                                    cost_result_tmp = {}
                                    relation_monster = self.get_as_monster(
                                        monster_effect["copy_monster"]
                                    )
                                    cost_result_tmp["copy_monster"] = relation_monster
                                    cost_result_tmp["cost_det"] = monster_effect
                                    cost_result_tmp["effect_kind"] = effect_kind
                                    cost_result_tmp["place_unique_id"] = user_decks[
                                        index
                                    ]["place_unique_id"]
                                    cost_result_tmp[
                                        "mine_or_other"
                                    ] = mine_or_other_for_cost_copy
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result["copy"]["deck"].append(cost_result_tmp)
                                    cost_result["det"] = user_decks[index]
                                    return_value["monsters"].append(cost_result_tmp)
                                    return_value["monsters2"].append(
                                        relation_monster[-1]
                                    )
                                self.cost_result = cost_result

                    if place == "grave":
                        if mine_or_other == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_graves[index],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        place2["mine_or_other"],
                                        cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_graves[index] = self.copy_monster_det(
                                            user_graves[index],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                    if mine_or_other == "1":
                                        self.graves[deck_id]["mygrave"] = user_graves
                                    elif mine_or_other == "2":
                                        self.graves[deck_id]["othergrave"] = user_graves
                                    else:
                                        self.graves[deck_id][
                                            "commongrave"
                                        ] = user_graves
                                else:
                                    cost_result = self.cost_result
                                    if "copy" not in cost_result:
                                        cost_result["copy"] = {}
                                    if "grave" not in cost_result["copy"]:
                                        cost_result["copy"]["grave"] = []
                                    cost_result_tmp = {}
                                    relation_monster = self.get_as_monster(
                                        monster_effect["copy_monster"]
                                    )
                                    cost_result_tmp["copy_monster"] = relation_monster
                                    cost_result_tmp["cost_det"] = monster_effect
                                    cost_result_tmp["effect_kind"] = effect_kind
                                    cost_result_tmp["place_unique_id"] = user_graves[
                                        index
                                    ]["place_unique_id"]
                                    cost_result_tmp[
                                        "mine_or_other"
                                    ] = mine_or_other_for_cost_copy
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result["copy"]["grave"].append(cost_result_tmp)
                                    cost_result_tmp["det"] = user_graves[index]
                                    return_value["monsters"].append(cost_result_tmp)
                                    return_value["monsters2"].append(
                                        relation_monster[-1]
                                    )
                                    self.cost_result = cost_result

                    if place == "hand":
                        if mine_or_other == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_hands[index],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        place2["mine_or_other"],
                                        cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_hands[index] = self.copy_monster_det(
                                            user_hands[index],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                    if mine_or_other == "1":
                                        self.hands[deck_id]["myhand"] = user_hands
                                    elif mine_or_other == "2":
                                        self.hands[deck_id]["otherhand"] = user_hands
                                    else:
                                        self.hands[deck_id]["commonhand"] = user_hands
                                else:
                                    cost_result = self.cost_result
                                    if "copy" not in cost_result:
                                        cost_result["copy"] = {}
                                    if "hand" not in cost_result["copy"]:
                                        cost_result["copy"]["hand"] = []
                                    cost_result_tmp = {}
                                    relation_monster = self.get_as_monster(
                                        monster_effect["copy_monster"]
                                    )
                                    cost_result_tmp["copy_monster"] = relation_monster
                                    cost_result_tmp["cost_det"] = monster_effect
                                    cost_result_tmp["effect_kind"] = effect_kind
                                    cost_result_tmp["place_unique_id"] = user_hands[
                                        index
                                    ]["place_unique_id"]
                                    cost_result_tmp[
                                        "mine_or_other"
                                    ] = mine_or_other_for_cost_copy
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result["copy"]["hand"].append(cost_result_tmp)
                                    cost_result_tmp["det"] = user_hands[index]
                                    relation_monster = self.get_as_monster(
                                        monster_effect["copy_monster"]
                                    )
                                    return_value["monsters"].append(cost_result_tmp)
                                    return_value["monsters2"].append(
                                        relation_monster[-1]
                                    )
                                    self.cost_result = cost_result
        for monster_effect_det2 in monster_effect_monster:
            monster_effect_det = monster_effect_det2["monster"]
            field_tmp = []
            tmp_deck = None
            for place in monster_effect_det["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if self.user == duel.user_turn:
                            mine_or_other3 = mine_or_other2
                        else:
                            if mine_or_other2 == 1:
                                mine_or_other3 = 2
                            elif mine_or_other2 == 2:
                                mine_or_other3 = 1
                            else:
                                mine_or_other3 = mine_or_other2
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        user_decks = org_deck

                    if not tmp_deck:
                        return
                    min_equation_number = self.calculate_boland(
                        monster_effect_det["min_equation_number"], None, False
                    )
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_decks)):
                            if not self.check_not_effected(
                                user_decks[index3],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[index3]:
                                                user_decks[index3]["eternal"] = []
                                            user_decks[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = monster_effect[
                                            "monster_variable_change_name"
                                        ][
                                            index2
                                        ]
                                        cost_result_tmp[
                                            "change_variable_val"
                                        ] = monster_effect[
                                            "monster_variable_change_val"
                                        ][
                                            index2
                                        ]
                                        cost_result_tmp[
                                            "change_variable_how"
                                        ] = monster_effect[
                                            "monster_variable_change_how"
                                        ][
                                            index2
                                        ]
                                        cost_result_tmp["place_unique_id"] = user_decks[
                                            index3
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        return_value["monsters"].append(cost_result_tmp)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        self.cost_result = cost_result
                                    if cost == 0:
                                        if not self.check_not_effected(
                                            user_decks[index3],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            tmp2 = {}
                                            tmp2["det"] = user_decks[index3]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_decks[
                                                index3
                                            ]["place_unique_id"]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["copy_monster"]
                                            )
                                            return_value["monsters"].append(tmp2)
                                            return_value["monsters2"].append(
                                                relation_monster[-1]
                                            )
                                            user_decks[index3] = self.copy_monster_det(
                                                user_decks[index3],
                                                relation_monster,
                                                monster_effect,
                                                effect_kind,
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_decks[index3],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            cost_result = self.cost_result
                                            if "copy" not in cost_result:
                                                cost_result["copy"] = {}
                                            if "deck" not in cost_result["copy"]:
                                                cost_result["copy"]["deck"] = []
                                            cost_result_tmp = {}
                                            relation_monster = self.get_as_monster(
                                                monster_effect["copy_monster"]
                                            )
                                            cost_result_tmp[
                                                "copy_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_decks[index3]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["copy"]["deck"].append(
                                                cost_result_tmp
                                            )
                                            cost_result_tmp["det"] = user_decks[index3]
                                            return_value["monsters"].append(
                                                cost_result_tmp
                                            )
                                            return_value["monsters2"].append(
                                                relation_monster[-1]
                                            )
                                            self.cost_result = cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif mine_or_other2 == 2:
                                self.decks[deck_id]["otherdeck"] = user_decks
                            else:
                                self.decks[deck_id]["commondeck"] = user_decks
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_decks[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_decks[range_i],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[range_i]:
                                                user_decks[range_i]["eternal"] = []
                                            user_decks[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_decks[
                                            range_i
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_decks[range_i],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_decks[range_i]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_decks[range_i][
                                            "place_unique_id"
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_decks[range_i] = self.copy_monster_det(
                                            user_decks[range_i],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                else:
                                    cost_result = self.cost_result
                                    if not self.check_not_effected(
                                        user_decks[range_i],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        cost_result = self.cost_result
                                        if "copy" not in cost_result:
                                            cost_result["copy"] = {}
                                        if "deck" not in cost_result["copy"]:
                                            cost_result["copy"]["deck"] = []
                                        cost_result_tmp = {}
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        cost_result_tmp[
                                            "copy_monster"
                                        ] = relation_monster
                                        cost_result_tmp["place_unique_id"] = user_decks[
                                            range_i
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["copy"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        cost_result_tmp["det"] = user_decks[range_i]
                                        return_value["monsters"].append(cost_result_tmp)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        self.cost_result = cost_result
                                    cost_result = self.cost_result

                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        else:
                            self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["commongrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["commongrave"]
                        user_graves = org_grave

                    if not tmp_grave:
                        return
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_graves)):
                            if not self.check_not_effected(
                                user_graves[index3],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                            ):
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_graves[index3],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[index3]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[index3][
                                            "place_unique_id"
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_graves[index3] = self.copy_monster_det(
                                            user_graves[index3],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_graves[index3],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                        ):
                                            cost_result = self.cost_result
                                            if "copy" not in cost_result:
                                                cost_result["copy"] = {}
                                            if "grave" not in cost_result["copy"]:
                                                cost_result["copy"]["grave"] = []
                                            cost_result_tmp = {}
                                            relation_monster = self.get_as_monster(
                                                monster_effect["copy_monster"]
                                            )
                                            cost_result_tmp[
                                                "copy_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_graves[index3]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["copy"]["grave"].append(
                                                cost_result_tmp
                                            )
                                            cost_result_tmp["det"] = user_graves[index3]
                                            return_value["monsters"].append(
                                                cost_result_tmp
                                            )
                                            return_value["monsters2"].append(
                                                relation_monster[-1]
                                            )
                                            self.cost_result = cost_result
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[index3]:
                                                user_graves[index3]["eternal"] = []
                                            user_graves[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[index3]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                self.cost_result = cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_graves[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_graves[range_i],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[range_i]:
                                                user_graves[range_i]["eternal"] = []
                                            user_graves[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[range_i]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_graves[range_i],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[range_i]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[range_i][
                                            "place_unique_id"
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(
                                            user_graves[range_i]
                                        )
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_graves[range_i] = self.copy_monster_det(
                                            user_graves[range_i],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                else:
                                    cost_result = self.cost_result
                                    if not self.check_not_effected(
                                        user_graves[range_i],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        cost_result = self.cost_result
                                        if "copy" not in cost_result:
                                            cost_result["copy"] = {}
                                        if "grave" not in cost_result["copy"]:
                                            cost_result["copy"]["grave"] = []
                                        cost_result_tmp = {}
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        cost_result_tmp[
                                            "copy_monster"
                                        ] = relation_monster
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[range_i]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["copy"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        cost_result_tmp["det"] = user_graves[range_i]
                                        return_value["monsters"].append(cost_result_tmp)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        self.cost_result = cost_result
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.graves[deck_id]["mygrave"] = user_graves
                        elif mine_or_other2 == 2:
                            self.graves[deck_id]["othergrave"] = user_graves
                        else:
                            self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_hand = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_hand = self.get_hand_with_effect(
                                self.hands[deck_id]["commonhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["commonhand"]
                        user_hands = org_hand

                    if not tmp_hand:
                        return
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_hands)):
                            if not self.check_not_effected(
                                user_hands[index3],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                            ):
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_hands[index3],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[index3]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[index3][
                                            "place_unique_id"
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_hands[index3] = self.copy_monster_det(
                                            user_hands[index3],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_hands[index3],
                                            chain_user,
                                            effect_kind,
                                            "hand",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                        ):
                                            cost_result = self.cost_result
                                            if "copy" not in cost_result:
                                                cost_result["copy"] = {}
                                            if "hand" not in cost_result["copy"]:
                                                cost_result["copy"]["hand"] = []
                                            cost_result_tmp = {}
                                            relation_monster = self.get_as_monster(
                                                monster_effect["copy_monster"]
                                            )
                                            cost_result_tmp[
                                                "copy_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_hands[index3]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["copy"]["hand"].append(
                                                cost_result_tmp
                                            )
                                            cost_result_tmp["det"] = user_hands[index3]
                                            return_value["monsters"].append(
                                                cost_result_tmp
                                            )
                                            return_value["monsters2"].append(
                                                relation_monster[-1]
                                            )
                                            self.cost_result = cost_result
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[index3]:
                                                user_hands[index3]["eternal"] = []
                                            user_hands[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_hands[
                                            index3
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                self.cost_result = cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_hands[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_hands[range_i],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[range_i]:
                                                user_hands[range_i]["eternal"] = []
                                            user_hands[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_hands[
                                            range_i
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["hand"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_hands[range_i],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[range_i]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[range_i][
                                            "place_unique_id"
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        return_value["monsters"].append(tmp2)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        user_hands[range_i] = self.copy_monster_det(
                                            user_hands[range_i],
                                            relation_monster,
                                            monster_effect,
                                            effect_kind,
                                        )
                                else:
                                    cost_result = self.cost_result
                                    if not self.check_not_effected(
                                        user_hands[range_i],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                    ):
                                        cost_result = self.cost_result
                                        if "copy" not in cost_result:
                                            cost_result["copy"] = {}
                                        if "hand" not in cost_result["copy"]:
                                            cost_result["copy"]["hand"] = []
                                        cost_result_tmp = {}
                                        relation_monster = self.get_as_monster(
                                            monster_effect["copy_monster"]
                                        )
                                        cost_result_tmp[
                                            "copy_monster"
                                        ] = relation_monster
                                        cost_result_tmp["place_unique_id"] = user_hands[
                                            range_i
                                        ]["place_unique_id"]
                                        cost_result_tmp[
                                            "mine_or_other"
                                        ] = mine_or_other_for_cost_copy
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["copy"]["hand"].append(
                                            cost_result_tmp
                                        )
                                        cost_result_tmp["det"] = user_hands[range_i]
                                        return_value["monsters"].append(cost_result_tmp)
                                        return_value["monsters2"].append(
                                            relation_monster[-1]
                                        )
                                        self.cost_result = cost_result
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        else:
                            self.hands[deck_id]["commonhand"] = user_hands
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            if self.validate_answer(
                                tmp2, monster_effect_det, exclude, duel
                            ):
                                if cost == 0:
                                    relation_monster = self.get_as_monster(
                                        monster_effect["copy_monster"]
                                    )
                                    return_value["monsters"].append(tmp2)
                                    return_value["monsters2"].append(
                                        relation_monster[-1]
                                    )
                                    field[x][y]["det"] = self.copy_monster_det(
                                        field[x][y]["det"],
                                        relation_monster,
                                        monster_effect,
                                        effect_kind,
                                    )
                                else:
                                    cost_result = self.cost_result

                                    if "copy" not in cost_result:
                                        cost_result["copy"] = {}
                                    if "field" not in cost_result["copy"]:
                                        cost_result["copy"]["field"] = []
                                    cost_result_tmp = {}
                                    relation_monster = self.get_as_monster(
                                        monster_effect["copy_monster"]
                                    )
                                    cost_result_tmp["copy_monster"] = relation_monster
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["mine_or_other"] = field[x][y][
                                        "mine_or_other"
                                    ]
                                    cost_result_tmp["place_unique_id"] = field[x][y][
                                        "det"
                                    ]["place_unique_id"]
                                    cost_result["copy"]["field"].append(cost_result_tmp)
                                    cost_result_tmp["det"] = field[x][y]["det"]
                                    return_value["monsters"].append(cost_result_tmp)
                                    return_value["monsters2"].append(
                                        relation_monster[-1]
                                    )
                                    self.cost_result = cost_result

        self.field = field
        return return_value

    def invalid_effect(self, effect_kind, monster_effect):
        duel = self.duel
        tmp = self.mess
        if duel.chain-2 < 0:
            relate_monsters = []
            return_value = {}
            return_value["monsters"] = relate_monsters
            return return_value
        tmp = tmp[str(int(duel.chain - 2))]
        tmp["invalid"] = True
        self.mess[str(int(duel.chain - 2))] = tmp
        relate_monsters = []
        return_value = {}
        return_value["monsters"] = relate_monsters
        return return_value

    def change_monster_relation_clear(
        self, monster_effect, effect_kind, monster_condition, cost=0
    ):
        return_relation = {}
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        if len(monster_effect["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect:
                if monster_effect["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect["monster_variable_change_name"])):
                variable_name = monster_effect["monster_variable_change_name"][index]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect["monster_variable_change_val"][index],
                        None,
                        False,
                        1,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    place1 = tmp[as_monster]
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                mess_index = -1
                for place2 in place1:
                    mess_index += 1
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if cost == 0:
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.config.sort is True:
                                    x = self.search_place_unique_id(y,place_unique_id)
                                    if x == -1:
                                        continue
                                if field[x][y]["det"] is None:
                                    continue
                                if "rel" not in field[x][y]["det"]:
                                    continue
                                if (
                                    field[x][y]["det"]["place_unique_id"]
                                    != place_unique_id
                                ):
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    chain_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                for index in range(
                                    len(monster_effect["relation_name"])
                                ):
                                    relation_name = monster_effect["relation_name"][
                                        index
                                    ]
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index
                                    ]
                                    relation_to = int(
                                        monster_effect["put_relation_to"][index]
                                    )
                                    relation_to = int(
                                        monster_effect["put_relation_to"][index]
                                    )
                                    if relation_kind not in field[x][y]["det"]["rel"]:
                                        continue
                                    for index2 in range(
                                        len(field[x][y]["det"]["rel"][relation_kind])
                                        - 1,
                                        -1,
                                        -1,
                                    ):
                                        if relation_name != "" and relation_name != '-1':
                                            if (
                                                field[x][y]["det"]["rel"][
                                                    relation_kind
                                                ][index2]["name"]
                                                != relation_name
                                            ):
                                                continue
                                        if (
                                            field[x][y]["det"]["rel"][relation_kind][
                                                index2
                                            ]["to"]
                                            != relation_to
                                        ):
                                            continue
                                        return_relation["name"] = field[x][y]["det"]["rel"][relation_kind][
                                                                      index2
                                                                  ]["name"]
                                        return_relation["to"] = relation_to
                                        self.del_relation(
                                            field[x][y]["det"]["rel"][relation_kind][
                                                index2
                                            ],
                                            relation_name,
                                            relation_kind,
                                            relation_to,
                                            field[x][y]["det"]["place_unique_id"],
                                            1,
                                            chain_user,
                                        )
                                        del field[x][y]["det"]["rel"][relation_kind][
                                            index2
                                        ]
                                place1[mess_index]["det"] = field[x][y]["det"]
                                self.field = field
                                continue
                        else:
                            pass
                        if as_monster[0] == "~":
                            if duel.in_cost is True:
                                self.cost[str(self.tmp_chain)] = place1
                            else:
                                self.cost[str(int(duel.chain - 1))] = place1
                        elif as_monster[0] == "%":
                            self.timing_mess[as_monster] = place1
                        elif as_monster[0] == "-":
                            self.mess[str(int(duel.chain - 2))][as_monster] = place1
                        else:
                            self.mess[str(int(duel.chain - 1))][as_monster] = place1

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (self.user == chain_user and mine_or_other == "1") or (
                        chain_user != self.user and mine_or_other == "2"
                    ):
                        mine_or_other2 = 1
                    elif (self.user != chain_user and mine_or_other == "1") or (
                        chain_user == self.user and mine_or_other == "2"
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if self.user == duel.user_turn:
                        mine_or_other3 = mine_or_other2
                    elif self.user != duel.user_turn:
                        if mine_or_other2 == 1:
                            mine_or_other3 = 2
                        elif mine_or_other2 == 2:
                            mine_or_other3 = 1
                        else:
                            mine_or_other3 = mine_or_other2
                    if place == "deck":
                        if mine_or_other2 == 1:
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_decks[index],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_decks[index]
                                            tmp2["mine_or_other"] = int(mine_or_other)
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_decks[index][
                                                "place_unique_id"
                                            ]
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        for index2 in range(
                                            len(monster_effect["relation_name"])
                                        ):
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index2]
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if (
                                                relation_kind
                                                not in user_decks[index]["rel"]
                                            ):
                                                continue
                                            for index3 in range(
                                                len(
                                                    user_decks[index]["rel"][
                                                        relation_kind
                                                    ]
                                                )
                                                - 1,
                                                -1,
                                                -1,
                                            ):
                                                if relation_name != "" and relation_name != '-1':
                                                    if (
                                                        user_decks[index]["rel"][
                                                            relation_kind
                                                        ][index3]["name"]
                                                        != relation_name
                                                    ):
                                                        continue
                                                if (
                                                    user_decks[index]["rel"][
                                                        relation_kind
                                                    ][index3]["to"]
                                                    != relation_to
                                                ):
                                                    continue
                                                return_relation["name"] = user_decks[index]["rel"][relation_kind][index3]["name"]
                                                return_relation["to"] = relation_to
                                                self.del_relation(
                                                    user_decks[index]["rel"][
                                                        relation_kind
                                                    ][index3],
                                                    relation_name,
                                                    relation_kind,
                                                    relation_to,
                                                    user_decks[index][
                                                        "place_unique_id"
                                                    ],
                                                    1,
                                                    chain_user,
                                                )
                                                del user_decks[index]["rel"][
                                                    relation_kind
                                                ][index3]
                                    if mine_or_other == "1":
                                        self.decks[deck_id]["mydeck"] = user_decks
                                    elif mine_or_other == "2":
                                        self.decks[deck_id]["otherdeck"] = user_decks
                                    else:
                                        self.decks[deck_id]["commondeck"] = user_decks
                                else:
                                    pass

                    if place == "grave":
                        if mine_or_other == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_graves[index],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_graves[index]
                                            tmp2["mine_or_other"] = int(mine_or_other)
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "grave"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_graves[
                                                index
                                            ]["place_unique_id"]
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        for index2 in range(
                                            len(monster_effect["relation_name"])
                                        ):
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index2]
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if (
                                                relation_kind
                                                not in user_graves[index]["rel"]
                                            ):
                                                continue
                                            for index3 in range(
                                                len(
                                                    user_graves[index]["rel"][
                                                        relation_kind
                                                    ]
                                                )
                                                - 1,
                                                -1,
                                                -1,
                                            ):
                                                if relation_name != "":
                                                    if (
                                                        user_graves[index]["rel"][
                                                            relation_kind
                                                        ][index3]["name"]
                                                        != relation_name
                                                    ):
                                                        continue
                                                if (
                                                    user_graves[index]["rel"][
                                                        relation_kind
                                                    ][index3]["to"]
                                                    != relation_to
                                                ):
                                                    continue
                                                return_relation["name"] = user_graves[index]["rel"][relation_kind][index3]["name"]
                                                return_relation["to"] = relation_to
                                                self.del_relation(
                                                    user_graves[index]["rel"][
                                                        relation_kind
                                                    ][index3],
                                                    relation_name,
                                                    relation_kind,
                                                    relation_to,
                                                    user_graves[index][
                                                        "place_unique_id"
                                                    ],
                                                    1,
                                                    chain_user,
                                                )
                                                del user_graves[index]["rel"][
                                                    relation_kind
                                                ][index3]
                                    if mine_or_other == "1":
                                        self.graves[deck_id]["mygrave"] = user_graves
                                    elif mine_or_other == "2":
                                        self.graves[deck_id]["othergrave"] = user_graves
                                    else:
                                        self.graves[deck_id][
                                            "commongrave"
                                        ] = user_graves
                                else:
                                    pass
                    if place == "hand":
                        if mine_or_other == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_hands[index],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_hands[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "hand"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_hands[index][
                                                "place_unique_id"
                                            ]
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        for index2 in range(
                                            len(monster_effect["relation_name"])
                                        ):
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index2]
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if (
                                                relation_kind
                                                not in user_hands[index]["rel"]
                                            ):
                                                continue
                                            for index3 in range(
                                                len(
                                                    user_hands[index]["rel"][
                                                        relation_kind
                                                    ]
                                                )
                                                - 1,
                                                -1,
                                                -1,
                                            ):
                                                if relation_name != "":
                                                    if (
                                                        user_hands[index]["rel"][
                                                            relation_kind
                                                        ][index3]["name"]
                                                        != relation_name
                                                    ):
                                                        continue
                                                if (
                                                    user_hands[index]["rel"][
                                                        relation_kind
                                                    ][index3]["to"]
                                                    != relation_to
                                                ):
                                                    continue
                                                return_relation["name"] = user_hands[index]["rel"][relation_kind][index3]["name"]
                                                return_relation["to"] = relation_to
                                                self.del_relation(
                                                    user_hands[index]["rel"][
                                                        relation_kind
                                                    ][index3],
                                                    relation_name,
                                                    relation_kind,
                                                    relation_to,
                                                    user_hands[index][
                                                        "place_unique_id"
                                                    ],
                                                    1,
                                                    chain_user,
                                                )
                                                del user_hands[index]["rel"][
                                                    relation_kind
                                                ][index3]
                                    if mine_or_other == "1":
                                        self.hands[deck_id]["myhand"] = user_hands
                                    elif mine_or_other == "2":
                                        self.hands[deck_id]["otherhand"] = user_hands
                                    else:
                                        self.hands[deck_id]["commonhand"] = user_hands
                                else:
                                    pass
        field = self.field
        for monster_effect_det2 in monster_effect_monster:
            monster_effect_det = monster_effect_det2["monster"]
            field_tmp = []
            tmp_deck = None
            for place in monster_effect_det["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        user_decks = org_deck

                    if not tmp_deck:
                        return
                    min_equation_number = self.calculate_boland(
                        monster_effect_det["min_equation_number"], None, False
                    )
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_decks)):
                            if not self.check_not_effected(
                                user_decks[index3],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[index3]:
                                                user_decks[index3]["eternal"] = []
                                            user_decks[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_decks[
                                            index3
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                if cost == 0:
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if (
                                            relation_kind
                                            not in user_decks[index]["rel"]
                                        ):
                                            continue
                                        for index4 in range(
                                            len(
                                                user_decks[index3]["det"]["rel"][
                                                    relation_kind
                                                ]
                                            )
                                            - 1,
                                            -1,
                                            -1,
                                        ):
                                            if relation_name != "":
                                                if (
                                                    user_decks[index3][relation_kind][
                                                        index4
                                                    ]["name"]
                                                    != relation_name
                                                ):
                                                    continue
                                            if (
                                                user_decks[index3]["rel"][
                                                    relation_kind
                                                ][index4]["to"]
                                                != relation_to
                                            ):
                                                continue
                                        return_relation["name"] = user_decks[index3]["rel"][relation_kind][ index4 ]["name"]
                                        return_relation["to"] = relation_to
                                        self.del_relation(
                                            user_decks[index3]["rel"][relation_kind][
                                                index4
                                            ],
                                            relation_name,
                                            relation_kind,
                                            relation_to,
                                            user_decks[index3]["place_unique_id"],
                                            1,
                                            chain_user,
                                        )
                                        del user_decks[index3]["rel"][relation_kind][
                                            index4
                                        ]
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif mine_or_other2 == 2:
                                self.decks[deck_id]["otherdeck"] = user_decks
                            else:
                                self.decks[deck_id]["commondeck"] = user_decks
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_decks[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_decks[range_i],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[range_i]:
                                                user_decks[range_i]["eternal"] = []
                                            user_decks[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[range_i]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                for index2 in monster_effect["relation_name"]:
                                    if cost == 0:
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if (
                                            relation_kind
                                            not in user_decks[index]["rel"]
                                        ):
                                            continue
                                        for index4 in range(
                                            len(
                                                user_decks[range_i]["det"]["rel"][
                                                    relation_kind
                                                ]
                                            )
                                            - 1,
                                            -1,
                                            -1,
                                        ):
                                            if relation_name != "":
                                                if (
                                                    user_decks[range_i][relation_kind][
                                                        index4
                                                    ]["name"]
                                                    != relation_name
                                                ):
                                                    continue
                                            if (
                                                user_decks[range_i]["rel"][
                                                    relation_kind
                                                ][index4]["to"]
                                                != relation_to
                                            ):
                                                continue
                                        return_relation["name"] = user_decks[range_i]["rel"][relation_kind][ index4 ]["name"]
                                        return_relation["to"] = relation_to
                                        self.del_relation(
                                            user_decks[range_i]["rel"][relation_kind][
                                                index4
                                            ],
                                            relation_name,
                                            relation_kind,
                                            relation_to,
                                            user_decks[range_i]["place_unique_id"],
                                            1,
                                            chain_user,
                                        )
                                        del user_decks[range_i]["rel"][relation_kind][
                                            index4
                                        ]

                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        else:
                            self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["commongrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["commongrave"]
                        user_graves = org_grave

                    if not tmp_grave:
                        return
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_graves)):
                            if not self.check_not_effected(
                                user_graves[index3],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                if cost == 0:
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if (
                                            relation_kind
                                            not in user_graves[index]["rel"]
                                        ):
                                            continue
                                        for index4 in range(
                                            len(
                                                user_graves[index3]["det"]["rel"][
                                                    relation_kind
                                                ]
                                            )
                                            - 1,
                                            -1,
                                            -1,
                                        ):
                                            if relation_name != "":
                                                if (
                                                    user_graves[index3][relation_kind][
                                                        index4
                                                    ]["name"]
                                                    != relation_name
                                                ):
                                                    continue
                                            if (
                                                user_graves[index3]["rel"][
                                                    relation_kind
                                                ][index4]["to"]
                                                != relation_to
                                            ):
                                                continue
                                        return_relation["name"] = user_graves[index3]["rel"][relation_kind][ index4 ]["name"]
                                        return_relation["to"] = relation_to
                                        self.del_relation(
                                            user_graves[index3]["rel"][relation_kind][
                                                index4
                                            ],
                                            relation_name,
                                            relation_kind,
                                            relation_to,
                                            user_graves[index3]["place_unique_id"],
                                            1,
                                            chain_user,
                                        )
                                        del user_graves[index3]["rel"][relation_kind][
                                            index4
                                        ]
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[index3]:
                                                user_graves[index3]["eternal"] = []
                                            user_graves[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[index3]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                self.cost_result = cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_graves[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_graves[range_i],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[range_i]:
                                                user_graves[range_i]["eternal"] = []
                                            user_graves[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[range_i]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                for index2 in monster_effect["relation_name"]:
                                    if cost == 0:
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if (
                                            relation_kind
                                            not in user_graves[index]["rel"]
                                        ):
                                            continue
                                        for index4 in range(
                                            len(
                                                user_graves[range_i]["det"]["rel"][
                                                    relation_kind
                                                ]
                                            )
                                            - 1,
                                            -1,
                                            -1,
                                        ):
                                            if relation_name != "":
                                                if (
                                                    user_graves[range_i][relation_kind][
                                                        index4
                                                    ]["name"]
                                                    != relation_name
                                                ):
                                                    continue
                                            if (
                                                user_graves[range_i]["rel"][
                                                    relation_kind
                                                ][index4]["to"]
                                                != relation_to
                                            ):
                                                continue
                                        return_relation["name"] = user_graves[range_i]["rel"][relation_kind][ index4 ]["name"]
                                        return_relation["to"] = relation_to
                                        self.del_relation(
                                            user_graves[range_i]["rel"][relation_kind][
                                                index4
                                            ],
                                            relation_name,
                                            relation_kind,
                                            relation_to,
                                            user_graves[range_i]["place_unique_id"],
                                            1,
                                            chain_user,
                                        )
                                        del user_graves[range_i]["rel"][relation_kind][
                                            index4
                                        ]
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.graves[deck_id]["mygrave"] = user_graves
                        elif mine_or_other2 == 2:
                            self.graves[deck_id]["othergrave"] = user_graves
                        else:
                            self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["commonhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["commonhand"]
                        user_hands = org_hand
                    if not tmp:
                        return None
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_hands)):
                            if not self.check_not_effected(
                                user_hands[index3],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[index3]:
                                                user_hands[index3]["eternal"] = []
                                            user_hands[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_hands[
                                            index3
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                for index2 in range(
                                    len(monster_effect["relation_name"])
                                ):
                                    relation_name = monster_effect["relation_name"][
                                        index2
                                    ]
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index2
                                    ]
                                    relation_to = int(
                                        monster_effect["put_relation_to"][index2]
                                    )
                                    if relation_kind not in user_hands[index]["rel"]:
                                        continue
                                    for index4 in range(
                                        len(
                                            user_hands[index3]["det"]["rel"][
                                                relation_kind
                                            ]
                                        )
                                        - 1,
                                        -1,
                                        -1,
                                    ):
                                        if relation_name != "":
                                            if (
                                                user_hands[index3][relation_kind][
                                                    index4
                                                ]["name"]
                                                != relation_name
                                            ):
                                                continue
                                        if (
                                            user_hands[index3]["rel"][relation_kind][
                                                index4
                                            ]["to"]
                                            != relation_to
                                        ):
                                            continue
                                    return_relation["name"] = user_hands[index3]["rel"][relation_kind][ index4 ]["name"]
                                    return_relation["to"] = relation_to
                                    self.del_relation(
                                        user_hands[index3]["rel"][relation_kind][
                                            index4
                                        ],
                                        relation_name,
                                        relation_kind,
                                        relation_to,
                                        user_hands[index3]["place_unique_id"],
                                        1,
                                        chain_user,
                                    )
                                    del user_hands[index3]["rel"][relation_kind][index4]
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        else:
                            self.hands[deck_id]["commonhand"] = user_hands
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_hands[range_i],
                            chain_user,
                            effect_kind,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            for index2 in range(
                                len(monster_effect["monster_variable_change_how"])
                            ):
                                variable_name = monster_effect[
                                    "monster_variable_change_name"
                                ][index2]
                                if cost == 0:
                                    if change_val_eternal is not None:
                                        if "eternal" not in user_hands[range_i]:
                                            user_hands[range_i]["eternal"] = []
                                        user_hands[range_i]["eternal"].append(
                                            change_val_eternal
                                        )
                                else:
                                    cost_result = self.cost_result
                                    cost_result_tmp = {}
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = user_hands[
                                        range_i
                                    ]["place_unique_id"]
                                    cost_result_tmp["user"] = int(place_tmp[2])
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result["variable"]["hand"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                            for index2 in monster_effect["relation_name"]:
                                if cost == 0:
                                    relation_name = monster_effect["relation_name"][
                                        index2
                                    ]
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index2
                                    ]
                                    relation_to = int(
                                        monster_effect["put_relation_to"][index2]
                                    )
                                    if relation_kind not in user_hands[index]["rel"]:
                                        continue
                                    for index4 in range(
                                        len(
                                            user_hands[range_i]["det"]["rel"][
                                                relation_kind
                                            ]
                                        )
                                        - 1,
                                        -1,
                                        -1,
                                    ):
                                        if relation_name != "":
                                            if (
                                                user_hands[range_i][relation_kind][
                                                    index4
                                                ]["name"]
                                                != relation_name
                                            ):
                                                continue
                                        if (
                                            user_hands[range_i]["rel"][relation_kind][
                                                index4
                                            ]["to"]
                                            != relation_to
                                        ):
                                            continue
                                    return_relation["name"] = user_hands[range_i]["rel"][relation_kind][ index4 ]["name"]
                                    return_relation["to"] = relation_to
                                    self.del_relation(
                                        user_hands[range_i]["rel"][relation_kind][
                                            index4
                                        ],
                                        relation_name,
                                        relation_kind,
                                        relation_to,
                                        user_hands[range_i]["place_unique_id"],
                                        1,
                                        chain_user,
                                    )
                                    del user_hands[range_i]["rel"][relation_kind][
                                        index4
                                    ]
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "2" and effect_user == self.user) or (
                                place_tmp[2] == "1" and effect_user != self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        continue
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            if self.validate_answer(
                                tmp2, monster_effect_det, exclude, duel
                            ):
                                if cost == 0:
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if (
                                            relation_kind
                                            not in field[x][y]["det"]["rel"]
                                        ):
                                            continue
                                        for index3 in range(
                                            len(field[x][y]["det"]["rel"][relation_kind])
                                            -1 ,
                                            -1,
                                            -1,
                                        ):
                                            if relation_name != "":
                                                if (
                                                    field[x][y]["det"]["rel"][
                                                        relation_kind
                                                    ][index3]["name"]
                                                    != relation_name
                                                ):
                                                    continue
                                            if (
                                                int(field[x][y]["det"]["rel"][
                                                    relation_kind
                                                ][index3]["to"])
                                                != relation_to
                                            ):
                                                continue
                                            return_relation["name"] = field[x][y]["det"]["rel"][relation_kind][index3]["name"]
                                            return_relation["to"] = relation_to
                                            self.del_relation(
                                                field[x][y]["det"]["rel"][
                                                    relation_kind
                                                ][index3],
                                                relation_name,
                                                relation_kind,
                                                relation_to,
                                                field[x][y]["det"]["place_unique_id"],
                                                1,
                                                chain_user,
                                            )
                                            del field[x][y]["det"]["rel"][
                                                relation_kind
                                            ][index3]

        self.field = field
        return return_relation

    def change_monster_relation_specify(
            self, monster_effect, effect_kind, monster_condition, specify,cost=0
    ):
        relation_name = specify["name"]
        relation_to = int(specify["to"])
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        relate_monster = []
        related_monster = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        if len(monster_effect["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect:
                if monster_effect["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect["monster_variable_change_name"])):
                variable_name = monster_effect["monster_variable_change_name"][index]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect["monster_variable_change_val"][index],
                        None,
                        False,
                        1,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        return_data = {}
                        return_data["relate_monster"] = []
                        return_data["related_monster"] = []
                        return return_data
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        return_data = {}
                        return_data["relate_monster"] = []
                        return_data["related_monster"] = []
                        return return_data
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        return_data = {}
                        return_data["relate_monster"] = []
                        return_data["related_monster"] = []
                        return return_data
                mess_index = -1
                for place2 in place1:
                    mess_index += 1
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if cost == 0:
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.config.sort is True:
                                    x = self.search_place_unique_id(y,place_unique_id)
                                    if x == -1:
                                        continue
                                if field[x][y]["det"] is None:
                                    continue
                                if (
                                        field[x][y]["det"]["place_unique_id"]
                                        != place_unique_id
                                ):
                                    continue
                                if self.check_not_effected(
                                        field[x][y]["det"],
                                        chain_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                ):
                                    continue
                                relate_monster.append(field[x][y]["det"])
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                for index in range(
                                        len(monster_effect["relation_name"])
                                ):
                                    relation_monster = self.get_as_monster(
                                        monster_effect["relation_monster"][index]
                                    )
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index
                                    ]
                                    if "put_relation_hide" in monster_effect:
                                        relation_hide = int(
                                            monster_effect["put_relation_hide"][index]
                                        )
                                    else:
                                        relation_hide = False
                                    if "rel" not in field[x][y]["det"]:
                                        field[x][y]["det"]["rel"] = {}
                                    if relation_kind not in field[x][y]["det"]["rel"]:
                                        field[x][y]["det"]["rel"][relation_kind] = []
                                    for monster in relation_monster:
                                        tmp2 = {}
                                        tmp2["monster"] = monster
                                        tmp2["name"] = relation_name
                                        tmp2["to"] = relation_to
                                        tmp2["hide"] = relation_hide
                                        field[x][y]["det"]["rel"][relation_kind].append(
                                            tmp2
                                        )
                                    if relation_to == 0:
                                        relation_from = 1
                                    elif relation_to == 1:
                                        relation_from = 0
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = field[x][y]["mine_or_other"]
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    for relation_monster_det in relation_monster:
                                        related_monster.append(
                                            relation_monster_det["det"]
                                        )
                                        self.set_relation(
                                            relation_name,
                                            relation_monster_det,
                                            relation_kind,
                                            relation_from,
                                            tmp2,
                                            "field",
                                            x,
                                            y,
                                            0,
                                            1,
                                            chain_user,
                                            relation_hide
                                        )
                                    place1[mess_index]["det"] = field[x][y]["det"]
                                self.field = field
                                continue
                        else:
                            place_unique_id = place2["place_unique_id"]
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,place_unique_id)
                                if x == -1:
                                    continue
                            else:
                                if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                    continue
                            if self.check_not_effected(
                                    field[x][y]["det"],
                                    chain_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                            ):
                                continue
                            if monster_condition != "":
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                ):
                                    continue
                            cost_result = self.cost_result
                            if "rel" not in cost_result:
                                cost_result["relation"] = {}

                            if "field" not in cost_result["relation"]:
                                cost_result["relation"]["field"] = []
                            for index in range(
                                    len(monster_effect["monster_variable_change_how"])
                            ):
                                relation_monster = self.get_as_monster(
                                    monster_effect["relation_monster"][index]
                                )
                                relation_kind = monster_effect["put_relation_kind"][
                                    index
                                ]
                                cost_result_tmp = {}
                                cost_result_tmp["relation_name"] = relation_name
                                cost_result_tmp["relation_monster"] = relation_monster
                                cost_result_tmp["relation_kind"] = relation_kind
                                cost_result_tmp["relation_to"] = relation_to
                                cost_result_tmp["place_unique_id"] = field[x][y][
                                    "place_unique_id"
                                ]
                                cost_result["relation"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            continue
                        if as_monster[0] == "~":
                            if duel.in_cost  is True:
                                self.cost[str(self.tmp_chain)] = place1
                            else:
                                self.cost[str(int(duel.chain - 1))] = place1
                        elif as_monster[0] == "%":
                            self.timing_mess[as_monster] = place1
                        elif as_monster[0] == "-":
                            self.mess[str(int(duel.chain - 2))][as_monster] = place1
                        else:
                            self.mess[str(int(duel.chain - 1))][as_monster] = place1

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (self.user == chain_user and mine_or_other == "1") or (
                            chain_user != self.user and mine_or_other == "2"
                    ):
                        mine_or_other2 = 1
                    elif (self.user != chain_user and mine_or_other == "1") or (
                            chain_user == self.user and mine_or_other == "2"
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if self.user == duel.user_turn:
                        mine_or_other3 = mine_or_other2
                    else:
                        if mine_or_other2 == 1:
                            mine_or_other3 = 2
                        elif mine_or_other2 == 2:
                            mine_or_other3 = 1
                        else:
                            mine_or_other3 = mine_or_other2
                    if place == "deck":
                        if mine_or_other2 == 1:
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_decks[index],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_decks[index]
                                            tmp2["mine_or_other"] = int(mine_or_other)
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_decks[index][
                                                "place_unique_id"
                                            ]
                                            if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relate_monster.append(user_decks[index])
                                        for index2 in range(
                                                len(monster_effect["relation_name"])
                                        ):
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index2
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            if "put_relation_hide" in monster_effect:
                                                relation_hide = int(
                                                    monster_effect["put_relation_hide"][index]
                                                )
                                            else:
                                                relation_hide = False
                                            if "rel" not in user_decks[index]:
                                                user_decks[index]["rel"] = {}
                                            if (
                                                    relation_kind
                                                    not in user_decks[index]["rel"]
                                            ):
                                                user_decks[index][relation_kind] = []
                                            tmp3 = {}
                                            tmp3["det"] = user_decks[index]
                                            tmp3["mine_or_other"] = mine_or_other
                                            tmp3["user"] = mine_or_other
                                            tmp3["place"] = "deck"
                                            tmp3["deck_id"] = deck_id
                                            tmp3["x"] = 0
                                            tmp3["y"] = 0
                                            tmp3["place_unique_id"] = user_decks[index][
                                                "place_unique_id"
                                            ]
                                            for monster in relation_monster:
                                                tmp2 = {}
                                                tmp2["monster"] = monster
                                                tmp2["kind"] = relation_kind
                                                tmp2["to"] = relation_to
                                                tmp2["hide"] = relation_hide
                                                user_decks[index][relation_kind].append(
                                                    tmp2
                                                )

                                                if relation_to == 0:
                                                    relation_from = 1
                                                elif relation_to == 1:
                                                    relation_from = 0
                                                for (
                                                        relation_monster_det
                                                ) in relation_monster:
                                                    self.set_relation(
                                                        relation_name,
                                                        relation_monster_det,
                                                        relation_kind,
                                                        relation_from,
                                                        tmp3,
                                                        "deck",
                                                        0,
                                                        0,
                                                        deck_id,
                                                        1,
                                                        chain_user,
                                                        relaton_hide
                                                    )
                                                    related_monster.append(
                                                        relation_monster_det["det"]
                                                    )
                                    if mine_or_other == "1":
                                        self.decks[deck_id]["mydeck"] = user_decks
                                    elif mine_or_other == "2":
                                        self.decks[deck_id]["otherdeck"] = user_decks
                                    else:
                                        self.decks[deck_id]["commondeck"] = user_decks
                                else:
                                    cost_result = self.cost_result
                                    for index2 in range(
                                            len(monster_effect["relation_name"])
                                    ):
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        if "rel" not in user_decks[index]:
                                            user_decks[index]["rel"] = {}
                                        if (
                                                relation_kind
                                                not in user_decks[index]["rel"]
                                        ):
                                            user_decks[index][relation_kind] = []
                                        if not self.check_not_effected(
                                                user_decks[index],
                                                chain_user,
                                                effect_kind,
                                                "deck",
                                                deck_id,
                                                0,
                                                0,
                                                mine_or_other,
                                        ):
                                            if monster_condition != "":
                                                tmp2 = {}
                                                tmp2["det"] = monster
                                                tmp2["mine_or_other"] = mine_or_other
                                                tmp2["user"] = chain_user
                                                tmp2["place"] = "deck"
                                                tmp2["deck_id"] = deck_id
                                                tmp2["x"] = 0
                                                tmp2["y"] = 0
                                                tmp2["place_unique_id"] = monster[
                                                    "place_unique_id"
                                                ]
                                                if not self.validate_answer(
                                                        tmp2, monster_condition, "", duel
                                                ):
                                                    continue
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "deck" not in cost_result["relation"]:
                                                cost_result["relation"]["deck"] = []
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_decks[index]["place_unique_id"]
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["deck"].append(
                                                cost_result_tmp
                                            )
                                self.cost_result = cost_result

                    if place == "grave":
                        if mine_or_other == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_graves[index],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_graves[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_graves[
                                                index
                                            ]["place_unique_id"]
                                            if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relate_monster.append(user_graves[index])
                                        for index2 in range(
                                                len(monster_effect["relation_name"])
                                        ):
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index2
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            if "put_relation_hide" in monster_effect:
                                                relation_hide = int(
                                                    monster_effect["put_relation_hide"][index]
                                                )
                                            else:
                                                relation_hide = False
                                            if "rel" not in user_graves[index]:
                                                user_graves[index]["rel"] = {}
                                            if (
                                                    relation_kind
                                                    not in user_graves[index]["rel"]
                                            ):
                                                user_graves[index][relation_kind] = []
                                            tmp3 = {}
                                            tmp3["det"] = user_graves[index]
                                            tmp3["mine_or_other"] = mine_or_other
                                            tmp3["user"] = mine_or_other
                                            tmp3["place"] = "grave"
                                            tmp3["deck_id"] = deck_id
                                            tmp3["x"] = 0
                                            tmp3["y"] = 0
                                            tmp3["place_unique_id"] = user_graves[
                                                index
                                            ]["place_unique_id"]
                                            for monster in relation_monster:
                                                tmp2 = {}
                                                tmp2["monster"] = monster
                                                tmp2["name"] = relation_name
                                                tmp2["to"] = relation_to
                                                tmp2["hide"] = relation_hide
                                                user_graves[index][
                                                    relation_kind
                                                ].append(tmp2)
                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                    relation_monster_det
                                            ) in relation_monster:
                                                related_monster.append(
                                                    relation_monster_det["det"]
                                                )
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "grave",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide,
                                                )
                                    if mine_or_other == "1":
                                        self.graves[deck_id]["mygrave"] = user_graves
                                    elif mine_or_other == "2":
                                        self.graves[deck_id]["othergrave"] = user_graves
                                    else:
                                        self.graves[deck_id][
                                            "commongrave"
                                        ] = user_graves
                                else:
                                    cost_result = self.cost_result
                                    for index2 in range(
                                            len(monster_effect["relation_name"])
                                    ):
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        if "rel" not in user_graves[index]:
                                            user_graves[index]["rel"] = {}
                                        if (
                                                relation_kind
                                                not in user_graves[index]["rel"]
                                        ):
                                            user_graves[index][relation_kind] = []
                                        if not self.check_not_effected(
                                                user_graves[index],
                                                chain_user,
                                                effect_kind,
                                                "grave",
                                                deck_id,
                                                0,
                                                0,
                                                mine_or_other,
                                                cost,
                                        ):
                                            if monster_condition != "":
                                                tmp2 = {}
                                                tmp2["det"] = monster
                                                tmp2["mine_or_other"] = mine_or_other
                                                tmp2["user"] = chain_user
                                                tmp2["place"] = "grave"
                                                tmp2["deck_id"] = deck_id
                                                tmp2["x"] = 0
                                                tmp2["y"] = 0
                                                tmp2["place_unique_id"] = monster[
                                                    "place_unique_id"
                                                ]
                                                if not self.validate_answer(
                                                        tmp2, monster_condition, "", duel
                                                ):
                                                    continue
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "grave" not in cost_result["relation"]:
                                                cost_result["relation"]["grave"] = []
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_graves[index]["place_unique_id"]
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["grave"].append(
                                                cost_result_tmp
                                            )
                                        self.cost_result = cost_result

                    if place == "hand":
                        if mine_or_other == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                            user_hands[index],
                                            chain_user,
                                            effect_kind,
                                            "hand",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_hands[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "hand"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_hands[index][
                                                "place_unique_id"
                                            ]
                                            if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relate_monster.append(user_hands[index])
                                        for index2 in range(
                                                len(monster_effect["relation_name"])
                                        ):
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index2
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            if "put_relation_hide" in monster_effect:
                                                relation_hide = int(
                                                    monster_effect["put_relation_hide"][index]
                                                )
                                            else:
                                                relation_hide = False
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if "rel" not in user_hands[index]:
                                                user_hands[index]["rel"] = {}
                                            if (
                                                    relation_kind
                                                    not in user_hands[index]["rel"]
                                            ):
                                                user_hands[index][relation_kind] = []
                                            tmp3 = {}
                                            tmp3["det"] = user_hands[index]
                                            tmp3["mine_or_other"] = mine_or_other
                                            tmp3["user"] = mine_or_other
                                            tmp3["place"] = "hand"
                                            tmp3["deck_id"] = deck_id
                                            tmp3["x"] = 0
                                            tmp3["y"] = 0
                                            tmp3["place_unique_id"] = user_hands[index][
                                                "place_unique_id"
                                            ]
                                            for monster in relation_monster:
                                                tmp2 = {}
                                                tmp2["monster"] = monster
                                                tmp2["name"] = relation_name
                                                tmp2["to"] = relation_to
                                                tmp2["hide"] = relation_hide
                                                user_hands[index][relation_name].append(
                                                    tmp2
                                                )
                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                    relation_monster_det
                                            ) in relation_monster:
                                                related_monster.append(
                                                    relation_monster_det
                                                )
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "hand",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide
                                                )
                                    if mine_or_other == "1":
                                        self.hands[deck_id]["myhand"] = user_hands
                                    elif mine_or_other == "2":
                                        self.hands[deck_id]["otherhand"] = user_hands
                                    else:
                                        self.hands[deck_id]["commonhand"] = user_hands
                                else:
                                    cost_result = self.cost_result
                                    for index2 in range(
                                            len(monster_effect["relation_name"])
                                    ):
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_hands[index]:
                                            user_hands[index]["rel"] = {}
                                        if (
                                                relation_kind
                                                not in user_hands[index]["rel"]
                                        ):
                                            user_hands[index][relation_kind] = []
                                        if not self.check_not_effected(
                                                user_hands[index],
                                                chain_user,
                                                effect_kind,
                                                "hand",
                                                deck_id,
                                                0,
                                                0,
                                                mine_or_other,
                                                cost,
                                        ):
                                            if monster_condition != "":
                                                tmp2 = {}
                                                tmp2["det"] = monster
                                                tmp2["mine_or_other"] = mine_or_other
                                                tmp2["user"] = chain_user
                                                tmp2["place"] = "hand"
                                                tmp2["deck_id"] = deck_id
                                                tmp2["x"] = 0
                                                tmp2["y"] = 0
                                                tmp2["place_unique_id"] = monster[
                                                    "place_unique_id"
                                                ]
                                                if not self.validate_answer(
                                                        tmp2, monster_condition, "", duel
                                                ):
                                                    continue
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "hand" not in cost_result["relation"]:
                                                cost_result["relation"]["hand"] = []
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_hands[index]["place_unique_id"]
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["hand"].append(
                                                cost_result_tmp
                                            )
                                        self.cost_result = cost_result

        field = self.field
        data = {}
        data["relate_monster"] = relate_monster
        data["related_monster"] = related_monster
        return data
    def change_monster_relation(
        self, monster_effect, effect_kind, monster_condition, cost=0
    ):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        relate_monster = []
        related_monster = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        if len(monster_effect["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect:
                if monster_effect["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect["monster_variable_change_name"])):
                variable_name = monster_effect["monster_variable_change_name"][index]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect["monster_variable_change_val"][index],
                        None,
                        False,
                        1,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        return_data = {}
                        return_data["relate_monster"] = []
                        return_data["related_monster"] = []
                        return return_data
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        return_data = {}
                        return_data["relate_monster"] = []
                        return_data["related_monster"] = []
                        return return_data
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        return_data = {}
                        return_data["relate_monster"] = []
                        return_data["related_monster"] = []
                        return return_data
                mess_index = -1
                for place2 in place1:
                    mess_index += 1
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if cost == 0:
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.config.sort is True:
                                    x = self.search_place_unique_id(y,place_unique_id)
                                    if x == -1:
                                        continue
                                if field[x][y]["det"] is None:
                                    continue
                                if (
                                    field[x][y]["det"]["place_unique_id"]
                                    != place_unique_id
                                ):
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    chain_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                relate_monster.append(field[x][y]["det"])
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                for index in range(
                                    len(monster_effect["relation_name"])
                                ):
                                    relation_name = monster_effect["relation_name"][
                                        index
                                    ]
                                    relation_monster = self.get_as_monster(
                                        monster_effect["relation_monster"][index]
                                    )
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index
                                    ]
                                    relation_to = int(
                                        monster_effect["put_relation_to"][index]
                                    )
                                    if "put_relation_hide" in monster_effect:
                                        relation_hide = int(
                                            monster_effect["put_relation_hide"][index]
                                        )
                                    else:
                                        relation_hide = False
                                    if "rel" not in field[x][y]["det"]:
                                        field[x][y]["det"]["rel"] = {}
                                    if relation_kind not in field[x][y]["det"]["rel"]:
                                        field[x][y]["det"]["rel"][relation_kind] = []
                                    for monster in relation_monster:
                                        tmp2 = {}
                                        tmp2["monster"] = monster
                                        tmp2["name"] = relation_name
                                        tmp2["to"] = relation_to
                                        tmp2["hide"] = relation_hide
                                        field[x][y]["det"]["rel"][relation_kind].append(
                                            tmp2
                                        )
                                    if relation_to == 0:
                                        relation_from = 1
                                    elif relation_to == 1:
                                        relation_from = 0
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = field[x][y]["mine_or_other"]
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["hide"] = relation_hide
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    for relation_monster_det in relation_monster:
                                        related_monster.append(
                                            relation_monster_det["det"]
                                        )
                                        self.set_relation(
                                            relation_name,
                                            relation_monster_det,
                                            relation_kind,
                                            relation_from,
                                            tmp2,
                                            "field",
                                            x,
                                            y,
                                            0,
                                            1,
                                            chain_user,
                                            relation_hide
                                        )
                                    place1[mess_index]["det"] = field[x][y]["det"]
                                self.field = field
                                continue
                        else:
                            place_unique_id = place2["place_unique_id"]
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,place_unique_id)
                                if x == -1:
                                    continue
                            else:
                                if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                    continue
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            if monster_condition != "":
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_condition, "", duel
                                ):
                                    continue
                            cost_result = self.cost_result
                            if "rel" not in cost_result:
                                cost_result["relation"] = {}

                            if "field" not in cost_result["relation"]:
                                cost_result["relation"]["field"] = []
                            for index in range(
                                len(monster_effect["monster_variable_change_how"])
                            ):
                                relation_name = monster_effect["relation_name"][index]
                                relation_monster = self.get_as_monster(
                                    monster_effect["relation_monster"][index]
                                )
                                relation_kind = monster_effect["put_relation_kind"][
                                    index
                                ]
                                relation_to = int(
                                    monster_effect["put_relation_to"][index]
                                )
                                cost_result_tmp = {}
                                cost_result_tmp["relation_name"] = relation_name
                                cost_result_tmp["relation_monster"] = relation_monster
                                cost_result_tmp["relation_kind"] = relation_kind
                                cost_result_tmp["relation_to"] = relation_to
                                cost_result_tmp["place_unique_id"] = field[x][y][
                                    "place_unique_id"
                                ]
                                cost_result["relation"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            continue
                        if as_monster[0] == "~":
                            if duel.in_cost  is True:
                                self.cost[str(self.tmp_chain)] = place1
                            else:
                                self.cost[str(int(duel.chain - 1))] = place1
                        elif as_monster[0] == "%":
                            self.timing_mess[as_monster] = place1
                        elif as_monster[0] == "-":
                            self.mess[str(int(duel.chain - 2))][as_monster] = place1
                        else:
                            self.mess[str(int(duel.chain - 1))][as_monster] = place1

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (self.user == chain_user and int(mine_or_other) == 1) or (
                        chain_user != self.user and int(mine_or_other) == 2
                    ):
                        mine_or_other2 = 1
                    elif (self.user != chain_user and int(mine_or_other) == "1") or (
                        chain_user == self.user and int(mine_or_other) == "2"
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if self.user == duel.user_turn:
                        mine_or_other3 = mine_or_other2
                    else:
                        if mine_or_other2 == 1:
                            mine_or_other3 = 2
                        elif mine_or_other2 == 2:
                            mine_or_other3 = 1
                        else:
                            mine_or_other3 = mine_orother2
                    if place == "deck":
                        if mine_or_other2 == 1:
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_decks[index],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_decks[index]
                                            tmp2["mine_or_other"] = int(mine_or_other)
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_decks[index][
                                                "place_unique_id"
                                            ]
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relate_monster.append(user_decks[index])
                                        for index2 in range(
                                            len(monster_effect["relation_name"])
                                        ):
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index2]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index2
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            if "put_relation_hide" in monster_effect:
                                                relation_hide = monster_effect["put_relation_hide"][index2]
                                            else:
                                                relation_hide = False
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if "rel" not in user_decks[index]:
                                                user_decks[index]["rel"] = {}
                                            if (
                                                relation_kind
                                                not in user_decks[index]["rel"]
                                            ):
                                                user_decks[index][relation_kind] = []
                                            tmp3 = {}
                                            tmp3["det"] = user_decks[index]
                                            tmp3["mine_or_other"] = mine_or_other
                                            tmp3["user"] = mine_or_other
                                            tmp3["place"] = "deck"
                                            tmp3["deck_id"] = deck_id
                                            tmp3["x"] = 0
                                            tmp3["y"] = 0
                                            tmp3["place_unique_id"] = user_decks[index][
                                                "place_unique_id"
                                            ]
                                            for monster in relation_monster:
                                                tmp2 = {}
                                                tmp2["monster"] = monster
                                                tmp2["kind"] = relation_kind
                                                tmp2["to"] = relation_to
                                                tmp2["hide"] = relation_hide
                                                user_decks[index][relation_kind].append(
                                                    tmp2
                                                )

                                                if relation_to == 0:
                                                    relation_from = 1
                                                elif relation_to == 1:
                                                    relation_from = 0
                                                for (
                                                    relation_monster_det
                                                ) in relation_monster:
                                                    self.set_relation(
                                                        relation_name,
                                                        relation_monster_det,
                                                        relation_kind,
                                                        relation_from,
                                                        tmp3,
                                                        "deck",
                                                        0,
                                                        0,
                                                        deck_id,
                                                        1,
                                                        chain_user,
                                                        relation_hide
                                                    )
                                                    related_monster.append(
                                                        relation_monster_det["det"]
                                                    )
                                    if mine_or_other == "1":
                                        self.decks[deck_id]["mydeck"] = user_decks
                                    elif mine_or_other == "2":
                                        self.decks[deck_id]["otherdeck"] = user_decks
                                    else:
                                        self.decks[deck_id]["commondeck"] = user_decks
                                else:
                                    cost_result = self.cost_result
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_decks[index]:
                                            user_decks[index]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_decks[index]["rel"]
                                        ):
                                            user_decks[index][relation_kind] = []
                                        if not self.check_not_effected(
                                            user_decks[index],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                        ):
                                            if monster_condition != "":
                                                tmp2 = {}
                                                tmp2["det"] = monster
                                                tmp2["mine_or_other"] = mine_or_other
                                                tmp2["user"] = chain_user
                                                tmp2["place"] = "deck"
                                                tmp2["deck_id"] = deck_id
                                                tmp2["x"] = 0
                                                tmp2["y"] = 0
                                                tmp2["place_unique_id"] = monster[
                                                    "place_unique_id"
                                                ]
                                                if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                                ):
                                                    continue
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "deck" not in cost_result["relation"]:
                                                cost_result["relation"]["deck"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_decks[index]["place_unique_id"]
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["deck"].append(
                                                cost_result_tmp
                                            )
                                self.cost_result = cost_result

                    if place == "grave":
                        if mine_or_other == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_graves[index],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_graves[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_graves[
                                                index
                                            ]["place_unique_id"]
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relate_monster.append(user_graves[index])
                                        for index2 in range(
                                            len(monster_effect["relation_name"])
                                        ):
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index2]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index2
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            if "put_relation_hide" in monster_effect:
                                                relation_hide = int(
                                                    monster_effect["put_relation_hide"][index]
                                                )
                                            else:
                                                relation_hide = False
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if "rel" not in user_graves[index]:
                                                user_graves[index]["rel"] = {}
                                            if (
                                                relation_kind
                                                not in user_graves[index]["rel"]
                                            ):
                                                user_graves[index][relation_kind] = []
                                            tmp3 = {}
                                            tmp3["det"] = user_graves[index]
                                            tmp3["mine_or_other"] = mine_or_other
                                            tmp3["user"] = mine_or_other
                                            tmp3["place"] = "grave"
                                            tmp3["deck_id"] = deck_id
                                            tmp3["x"] = 0
                                            tmp3["y"] = 0
                                            tmp3["place_unique_id"] = user_graves[
                                                index
                                            ]["place_unique_id"]
                                            for monster in relation_monster:
                                                tmp2 = {}
                                                tmp2["monster"] = monster
                                                tmp2["name"] = relation_name
                                                tmp2["to"] = relation_to
                                                tmp2["hide"] = relation_hide
                                                user_graves[index][
                                                    relation_kind
                                                ].append(tmp2)
                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                relation_monster_det
                                            ) in relation_monster:
                                                related_monster.append(
                                                    relation_monster_det["det"]
                                                )
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "grave",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide,
                                                )
                                    if mine_or_other == "1":
                                        self.graves[deck_id]["mygrave"] = user_graves
                                    elif mine_or_other == "2":
                                        self.graves[deck_id]["othergrave"] = user_graves
                                    else:
                                        self.graves[deck_id][
                                            "commongrave"
                                        ] = user_graves
                                else:
                                    cost_result = self.cost_result
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_graves[index]:
                                            user_graves[index]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_graves[index]["rel"]
                                        ):
                                            user_graves[index][relation_kind] = []
                                        if not self.check_not_effected(
                                            user_graves[index],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            if monster_condition != "":
                                                tmp2 = {}
                                                tmp2["det"] = monster
                                                tmp2["mine_or_other"] = mine_or_other
                                                tmp2["user"] = chain_user
                                                tmp2["place"] = "grave"
                                                tmp2["deck_id"] = deck_id
                                                tmp2["x"] = 0
                                                tmp2["y"] = 0
                                                tmp2["place_unique_id"] = monster[
                                                    "place_unique_id"
                                                ]
                                                if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                                ):
                                                    continue
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "grave" not in cost_result["relation"]:
                                                cost_result["relation"]["grave"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_graves[index]["place_unique_id"]
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["grave"].append(
                                                cost_result_tmp
                                            )
                                        self.cost_result = cost_result

                    if place == "hand":
                        if mine_or_other == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_hands[index],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if monster_condition != "":
                                            tmp2 = {}
                                            tmp2["det"] = user_hands[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "hand"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_hands[index][
                                                "place_unique_id"
                                            ]
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        relate_monster.append(user_hands[index])
                                        for index2 in range(
                                            len(monster_effect["relation_name"])
                                        ):
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index2]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index2
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index2]
                                            if "put_relation_hide" in monster_effect:
                                                relation_hide = int(
                                                    monster_effect["put_relation_hide"][index]
                                                )
                                            else:
                                                relation_hide = False
                                            relation_to = int(
                                                monster_effect["put_relation_to"][
                                                    index2
                                                ]
                                            )
                                            if "rel" not in user_hands[index]:
                                                user_hands[index]["rel"] = {}
                                            if (
                                                relation_kind
                                                not in user_hands[index]["rel"]
                                            ):
                                                user_hands[index][relation_kind] = []
                                            tmp3 = {}
                                            tmp3["det"] = user_hands[index]
                                            tmp3["mine_or_other"] = mine_or_other
                                            tmp3["user"] = mine_or_other
                                            tmp3["place"] = "hand"
                                            tmp3["deck_id"] = deck_id
                                            tmp3["x"] = 0
                                            tmp3["y"] = 0
                                            tmp3["place_unique_id"] = user_hands[index][
                                                "place_unique_id"
                                            ]
                                            for monster in relation_monster:
                                                tmp2 = {}
                                                tmp2["monster"] = monster
                                                tmp2["name"] = relation_name
                                                tmp2["to"] = relation_to
                                                tmp2["hide"] = relation_hide
                                                user_hands[index][relation_name].append(
                                                    tmp2
                                                )
                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                relation_monster_det
                                            ) in relation_monster:
                                                related_monster.append(
                                                    relation_monster_det
                                                )
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "hand",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide
                                                )
                                    if mine_or_other == "1":
                                        self.hands[deck_id]["myhand"] = user_hands
                                    elif mine_or_other == "2":
                                        self.hands[deck_id]["otherhand"] = user_hands
                                    else:
                                        self.hands[deck_id]["commonhand"] = user_hands
                                else:
                                    cost_result = self.cost_result
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_hands[index]:
                                            user_hands[index]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_hands[index]["rel"]
                                        ):
                                            user_hands[index][relation_kind] = []
                                        if not self.check_not_effected(
                                            user_hands[index],
                                            chain_user,
                                            effect_kind,
                                            "hand",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            if monster_condition != "":
                                                tmp2 = {}
                                                tmp2["det"] = monster
                                                tmp2["mine_or_other"] = mine_or_other
                                                tmp2["user"] = chain_user
                                                tmp2["place"] = "hand"
                                                tmp2["deck_id"] = deck_id
                                                tmp2["x"] = 0
                                                tmp2["y"] = 0
                                                tmp2["place_unique_id"] = monster[
                                                    "place_unique_id"
                                                ]
                                                if not self.validate_answer(
                                                    tmp2, monster_condition, "", duel
                                                ):
                                                    continue
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "hand" not in cost_result["relation"]:
                                                cost_result["relation"]["hand"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_hands[index]["place_unique_id"]
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["hand"].append(
                                                cost_result_tmp
                                            )
                                        self.cost_result = cost_result

        field = self.field
        for monster_effect_det2 in monster_effect_monster:
            monster_effect_det = monster_effect_det2["monster"]
            field_tmp = []
            tmp_deck = None
            for place in monster_effect_det["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        user_decks = org_deck

                    if not tmp_deck:
                        return
                    min_equation_number = self.calculate_boland(
                        monster_effect_det["min_equation_number"], None, False
                    )
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_decks)):
                            if not self.check_not_effected(
                                user_decks[index3],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[index3]:
                                                user_decks[index3]["eternal"] = []
                                            user_decks[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_decks[
                                            index3
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                if cost == 0:
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        if "put_relation_hide" in monster_effect:
                                            relation_hide = int(
                                                monster_effect["put_relation_hide"][index]
                                            )
                                        else:
                                            relation_hide = False
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_decks[index]:
                                            user_decks[index3]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_decks[index]["rel"]
                                        ):
                                            user_decks[index3][relation_kind] = []
                                        tmp3 = {}
                                        tmp3["det"] = user_decks[index3]
                                        tmp3["mine_or_other"] = mine_or_other
                                        tmp3["user"] = mine_or_other
                                        tmp3["place"] = "deck"
                                        tmp3["deck_id"] = deck_id
                                        tmp3["x"] = 0
                                        tmp3["y"] = 0
                                        tmp3["place_unique_id"] = user_decks[index3][
                                            "place_unique_id"
                                        ]
                                        for monster in relation_monster:
                                            tmp2 = {}
                                            tmp2["monster"] = monster
                                            tmp2["name"] = relation_name
                                            tmp2["to"] = relation_to
                                            tmp2["hide"] = relation_hide
                                            user_decks[index3][relation_kind].append(
                                                tmp2
                                            )

                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                relation_monster_det
                                            ) in relation_monster:
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "deck",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide
                                                )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_decks[index3],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "deck" not in cost_result["relation"]:
                                                cost_result["relation"]["deck"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_decks[index3]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["deck"].append(
                                                cost_result_tmp
                                            )
                                self.cost_result = cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif mine_or_other2 == 2:
                                self.decks[deck_id]["otherdeck"] = user_decks
                            else:
                                self.decks[deck_id]["commondeck"] = user_decks
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_decks[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_decks[range_i],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_decks[range_i]:
                                                user_decks[range_i]["eternal"] = []
                                            user_decks[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[range_i]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                for index2 in monster_effect["relation_name"]:
                                    if cost == 0:
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        if "put_relation_hide" in monster_effect:
                                            relation_hide = int(
                                                monster_effect["put_relation_hide"][index]
                                            )
                                        else:
                                            relation_hide = False
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_decks[range_i]:
                                            user_decks[range_i]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_decks[index]["rel"]
                                        ):
                                            user_decks[range_i][relation_kind] = []
                                        tmp3 = {}
                                        tmp3["det"] = user_decks[range_i]
                                        tmp3["mine_or_other"] = mine_or_other
                                        tmp3["user"] = mine_or_other
                                        tmp3["place"] = "deck"
                                        tmp3["deck_id"] = deck_id
                                        tmp3["x"] = 0
                                        tmp3["y"] = 0
                                        tmp3["place_unique_id"] = user_decks[range_i][
                                            "place_unique_id"
                                        ]
                                        for monster in relation_monster:
                                            tmp2 = {}
                                            tmp2["monster"] = monster
                                            tmp2["name"] = relation_name
                                            tmp2["to"] = relation_to
                                            tmp2["hide"] = relation_hide
                                            user_decks[index3][relation_kind].append(
                                                tmp2
                                            )
                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                relation_monster_det
                                            ) in relation_monster:
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "deck",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide
                                                )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_decks[range_i],
                                            chain_user,
                                            effect_kind,
                                            "deck",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "deck" not in cost_result["relation"]:
                                                cost_result["relation"]["deck"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_decks[range_i]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["deck"].append(
                                                cost_result_tmp
                                            )
                                            cost_result = self.cost_result

                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        else:
                            self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_grave = self.get_grave_with_effect(
                                self.graves[deck_id]["commongrave"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["commongrave"]
                        user_graves = org_grave

                    if not tmp_grave:
                        return
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_graves)):
                            if not self.check_not_effected(
                                user_graves[index3],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                if cost == 0:
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        if "put_relation_hide" in monster_effect:
                                            relation_hide = int(
                                                monster_effect["put_relation_hide"][index]
                                            )
                                        else:
                                            relation_hide = False
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_graves[index]:
                                            user_graves[index3]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_graves[index]["rel"]
                                        ):
                                            user_graves[index3][relation_kind] = []
                                        tmp3 = {}
                                        tmp3["det"] = user_graves[index3]
                                        tmp3["mine_or_other"] = mine_or_other
                                        tmp3["user"] = mine_or_other
                                        tmp3["place"] = "grave"
                                        tmp3["deck_id"] = deck_id
                                        tmp3["x"] = 0
                                        tmp3["y"] = 0
                                        tmp3["place_unique_id"] = user_graves[index3][
                                            "place_unique_id"
                                        ]
                                        for monster in relation_monster:
                                            tmp2 = {}
                                            tmp2["monster"] = monster
                                            tmp2["name"] = relation_name
                                            tmp2["to"] = relation_to
                                            tmp2["hide"] = relation_hide
                                            user_graves[index3][relation_kind].append(
                                                tmp2
                                            )

                                            if relation_to == 0:
                                                relation_from = 1
                                            elif relation_to == 1:
                                                relation_from = 0
                                            for (
                                                relation_monster_det
                                            ) in relation_monster:
                                                self.set_relation(
                                                    relation_name,
                                                    relation_monster_det,
                                                    relation_kind,
                                                    relation_from,
                                                    tmp3,
                                                    "grave",
                                                    0,
                                                    0,
                                                    deck_id,
                                                    1,
                                                    chain_user,
                                                    relation_hide
                                                )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_graves[index3],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "grave" not in cost_result["relation"]:
                                                cost_result["relation"]["grave"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_graves[index3]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["grave"].append(
                                                cost_result_tmp
                                            )
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[index3]:
                                                user_graves[index3]["eternal"] = []
                                            user_graves[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[index3]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                self.cost_result = cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        for index2 in range(len(user_graves[range_i]["variables"])):
                            if not self.check_not_effected(
                                user_graves[range_i],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_graves[range_i]:
                                                user_graves[range_i]["eternal"] = []
                                            user_graves[range_i]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = user_graves[range_i]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                for index2 in monster_effect["relation_name"]:
                                    if cost == 0:
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        if "put_relation_hide" in monster_effect:
                                            relation_hide = int(
                                                monster_effect["put_relation_hide"][index]
                                            )
                                        else:
                                            relation_hide = False
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in user_graves[index]:
                                            user_graves[range_i]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in user_graves[index]["rel"]
                                        ):
                                            user_graves[range_i][relation_kind] = []
                                        tmp3 = {}
                                        tmp3["det"] = user_graves[range_i]
                                        tmp3["mine_or_other"] = mine_or_other
                                        tmp3["user"] = mine_or_other
                                        tmp3["place"] = "grave"
                                        tmp3["deck_id"] = deck_id
                                        tmp3["x"] = 0
                                        tmp3["y"] = 0
                                        tmp3["place_unique_id"] = user_graves[range_i][
                                            "place_unique_id"
                                        ]
                                        for monster in relation_monster:
                                            tmp2 = {}
                                            tmp2["monster"] = monster
                                            tmp2["name"] = relation_name
                                            tmp2["to"] = relation_to
                                            tmp2["hide"] = relation_hide
                                            user_graves[range_i][relation_kind].append(
                                                tmp2
                                            )
                                        if relation_to == 0:
                                            relation_from = 1
                                        elif relation_to == 1:
                                            relation_from = 0
                                        for relation_monster_det in relation_monster:
                                            self.set_relation(
                                                relation_name,
                                                relation_monster_det,
                                                relation_kind,
                                                relation_from,
                                                tmp3,
                                                "grave",
                                                0,
                                                0,
                                                deck_id,
                                                1,
                                                chain_user,
                                                relation_hide
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        if not self.check_not_effected(
                                            user_graves[range_i],
                                            chain_user,
                                            effect_kind,
                                            "grave",
                                            deck_id,
                                            0,
                                            0,
                                            mine_or_other,
                                            cost,
                                        ):
                                            if "rel" not in cost_result:
                                                cost_result["relation"] = {}
                                            if "grave" not in cost_result["relation"]:
                                                cost_result["relation"]["grave"] = []
                                            relation_name = monster_effect[
                                                "relation_name"
                                            ][index]
                                            relation_monster = self.get_as_monster(
                                                monster_effect["relation_monster"][
                                                    index
                                                ]
                                            )
                                            relation_kind = monster_effect[
                                                "put_relation_kind"
                                            ][index]
                                            relation_to = int(
                                                monster_effect["put_relation_to"][index]
                                            )
                                            cost_result_tmp[
                                                "relation_name"
                                            ] = relation_name
                                            cost_result_tmp[
                                                "relation_monster"
                                            ] = relation_monster
                                            cost_result_tmp[
                                                "relation_kind"
                                            ] = relation_kind
                                            cost_result_tmp["relation_to"] = relation_to
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = user_graves[range_i]["place_unique_id"]
                                            cost_result_tmp["user"] = int(place_tmp[2])
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["relation"]["grave"].append(
                                                cost_result_tmp
                                            )
                                            cost_result = self.cost_result

                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.graves[deck_id]["mygrave"] = user_graves
                        elif mine_or_other2 == 2:
                            self.graves[deck_id]["othergrave"] = user_graves
                        else:
                            self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["commonhand"],
                                monster_effect_det,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            )
                            org_hand = self.hands[deck_id]["commonhand"]
                        user_hands = org_hand
                    if not tmp:
                        return None
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_hands)):
                            if not self.check_not_effected(
                                user_hands[index3],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                for index2 in range(
                                    len(monster_effect["monster_variable_change_how"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if cost == 0:
                                        if change_val_eternal is not None:
                                            if "eternal" not in user_hands[index3]:
                                                user_hands[index3]["eternal"] = []
                                            user_hands[index3]["eternal"].append(
                                                change_val_eternal
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = user_hands[
                                            index3
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                for index2 in range(
                                    len(monster_effect["relation_name"])
                                ):
                                    relation_name = monster_effect["relation_name"][
                                        index2
                                    ]
                                    relation_monster = self.get_as_monster(
                                        monster_effect["relation_monster"][index2]
                                    )
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index2
                                    ]
                                    if "put_relation_hide" in monster_effect:
                                        relation_hide = int(
                                            monster_effect["put_relation_hide"][index]
                                        )
                                    else:
                                        relation_hide = False
                                    relation_to = int(
                                        monster_effect["put_relation_to"][index2]
                                    )
                                    if "rel" not in user_hands[index]:
                                        user_hands[index3]["rel"] = {}
                                    if relation_kind not in user_hands[index]["rel"]:
                                        user_hands[index3][relation_kind] = []
                                    tmp3 = {}
                                    tmp3["det"] = user_hands[index3]
                                    tmp3["mine_or_other"] = mine_or_other
                                    tmp3["user"] = mine_or_other
                                    tmp3["place"] = "hand"
                                    tmp3["deck_id"] = deck_id
                                    tmp3["x"] = 0
                                    tmp3["y"] = 0
                                    tmp3["place_unique_id"] = user_hands[index3][
                                        "place_unique_id"
                                    ]
                                    for monster in relation_monster:
                                        tmp2 = {}
                                        tmp2["monster"] = monster
                                        tmp2["name"] = relation_name
                                        tmp2["to"] = relation_to
                                        tmp2["hide"] = relation_hide
                                        user_hands[index3][relation_kind].append(tmp2)
                                    if relation_to == 0:
                                        relation_from = 1
                                    elif relation_to == 1:
                                        relation_from = 0
                                    for relation_monster_det in relation_monster:
                                        self.set_relation(
                                            relation_name,
                                            relation_monster_det,
                                            relation_kind,
                                            relation_from,
                                            tmp3,
                                            "hand",
                                            0,
                                            0,
                                            deck_id,
                                            1,
                                            chain_user,
                                            relation_hide
                                        )
                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        else:
                            self.hands[deck_id]["commonhand"] = user_hands
                        continue
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_hands[range_i],
                            chain_user,
                            effect_kind,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            for index2 in range(
                                len(monster_effect["monster_variable_change_how"])
                            ):
                                variable_name = monster_effect[
                                    "monster_variable_change_name"
                                ][index2]
                                if cost == 0:
                                    if change_val_eternal is not None:
                                        if "eternal" not in user_hands[range_i]:
                                            user_hands[range_i]["eternal"] = []
                                        user_hands[range_i]["eternal"].append(
                                            change_val_eternal
                                        )
                                else:
                                    cost_result = self.cost_result
                                    cost_result_tmp = {}
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = user_hands[
                                        range_i
                                    ]["place_unique_id"]
                                    cost_result_tmp["user"] = int(place_tmp[2])
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result["variable"]["hand"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                            for index2 in monster_effect["relation_name"]:
                                if cost == 0:
                                    relation_name = monster_effect["relation_name"][
                                        index2
                                    ]
                                    relation_monster = self.get_as_monster(
                                        monster_effect["relation_monster"][index2]
                                    )
                                    relation_kind = monster_effect["put_relation_kind"][
                                        index2
                                    ]
                                    if "put_relation_hide" in monster_effect:
                                        relation_hide = int(
                                            monster_effect["put_relation_hide"][index]
                                        )
                                    else:
                                        relation_hide = False

                                    relation_to = int(
                                        monster_effect["put_relation_to"][index2]
                                    )
                                    if "rel" not in user_hands[index]:
                                        user_hands[range_i]["rel"] = {}
                                    if relation_kind not in user_hands[index]["rel"]:
                                        user_hands[range_i][relation_kind] = []
                                    tmp3 = {}
                                    tmp3["det"] = user_hands[range_i]
                                    tmp3["mine_or_other"] = mine_or_other
                                    tmp3["user"] = mine_or_other
                                    tmp3["place"] = "hand"
                                    tmp3["deck_id"] = deck_id
                                    tmp3["x"] = 0
                                    tmp3["y"] = 0
                                    tmp3["place_unique_id"] = user_hands[range_i][
                                        "place_unique_id"
                                    ]
                                    for monster in relation_monster:
                                        tmp2 = {}
                                        tmp2["monster"] = monster
                                        tmp2["kind"] = relation_kind
                                        tmp2["to"] = relation_to
                                        tmp2["hide"] = relation_hide
                                    if relation_to == 0:
                                        relation_from = 1
                                    elif relation_to == 1:
                                        relation_from = 0
                                    for relation_monster_det in relation_monster:
                                        self.set_relation(
                                            relation_name,
                                            relation_monster_det,
                                            relation_kind,
                                            relation_from,
                                            tmp3,
                                            "hand",
                                            0,
                                            0,
                                            deck_id,
                                            1,
                                            chain_user,
                                            relation_hide
                                        )
                                else:
                                    cost_result = self.cost_result
                                    if not self.check_not_effected(
                                        user_hands[range_i],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        if "rel" not in cost_result:
                                            cost_result["relation"] = {}
                                        if "hand" not in cost_result["relation"]:
                                            cost_result["relation"]["hand"] = []
                                        relation_name = monster_effect["relation_name"][
                                            index
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index]
                                        )
                                        cost_result_tmp["relation_name"] = relation_name
                                        cost_result_tmp[
                                            "relation_monster"
                                        ] = relation_monster
                                        cost_result_tmp["relation_kind"] = relation_kind
                                        cost_result_tmp["relation_to"] = relation_to
                                        cost_result_tmp["place_unique_id"] = user_hands[
                                            range_i
                                        ]["place_unique_id"]
                                        cost_result_tmp["user"] = int(place_tmp[2])
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["relation"]["hand"].append(
                                            cost_result_tmp
                                        )
                                        cost_result = self.cost_result
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "2" and effect_user == self.user) or (
                                place_tmp[2] == "1" and effect_user != self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        continue
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                            ):
                                continue
                            if self.validate_answer(
                                tmp2, monster_effect_det, exclude, duel
                            ):
                                if cost == 0:
                                    for index2 in range(
                                        len(monster_effect["relation_name"])
                                    ):
                                        relation_name = monster_effect["relation_name"][
                                            index2
                                        ]
                                        if "put_relation_hide" in monster_effect:
                                            relation_hide = int(
                                                monster_effect["put_relation_hide"][index]
                                            )
                                        else:
                                            relation_hide = False
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index2]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index2]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index2]
                                        )
                                        if "rel" not in field[x][y]["det"]:
                                            field[x][y]["det"]["rel"] = {}
                                        if (
                                            relation_kind
                                            not in field[x][y]["det"]["rel"]
                                        ):
                                            field[x][y]["det"]["rel"][
                                                relation_kind
                                            ] = []
                                        tmp3 = {}
                                        tmp3["det"] = field[x][y]["det"]
                                        tmp3["mine_or_other"] = field[x][y][
                                            "mine_or_other"
                                        ]
                                        tmp3["user"] = field[x][y]["mine_or_other"]
                                        tmp3["place"] = "field"
                                        tmp3["deck_id"] = 0
                                        tmp3["x"] = x
                                        tmp3["y"] = y
                                        tmp3["place_unique_id"] = field[x][y]["det"][
                                            "place_unique_id"
                                        ]
                                        for monster in relation_monster:
                                            tmp2 = {}
                                            tmp2["monster"] = monster
                                            tmp2["name"] = relation_name
                                            tmp2["to"] = relation_to
                                            tmp2["hide"] = relation_hide
                                            field[x][y]["det"]["rel"][
                                                relation_kind
                                            ].append(tmp)

                                        if relation_to == 0:
                                            relation_from = 1
                                        elif relation_to == 1:
                                            relation_from = 0
                                        for relation_monster_det in relation_monster:
                                            self.set_relation(
                                                relation_name,
                                                relation_monster_det,
                                                relation_kind,
                                                relation_from,
                                                tmp3,
                                                "field",
                                                x,
                                                y,
                                                0,
                                                1,
                                                chain_user,
                                                relation_hide
                                            )
                                    else:
                                        cost_result = self.cost_result
                                        if "rel" not in cost_result:
                                            cost_result["relation"] = {}
                                        if "field" not in cost_result["relation"]:
                                            cost_result["relation"]["field"] = []
                                        relation_name = monster_effect["relation_name"][
                                            index
                                        ]
                                        relation_monster = self.get_as_monster(
                                            monster_effect["relation_monster"][index]
                                        )
                                        relation_kind = monster_effect[
                                            "put_relation_kind"
                                        ][index]
                                        relation_to = int(
                                            monster_effect["put_relation_to"][index]
                                        )
                                        cost_result_tmp["relation_name"] = relation_name
                                        cost_result_tmp[
                                            "relation_monster"
                                        ] = relation_monster
                                        cost_result_tmp["relation_kind"] = relation_kind
                                        cost_result_tmp["relation_to"] = relation_to
                                        cost_result_tmp["place_unique_id"] = field[x][
                                            y
                                        ]["det"]["place_unique_id"]
                                        cost_result_tmp["x"] = x
                                        cost_result_tmp["y"] = y
                                        cost_result["relation"]["field"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result

        self.field = field
        data = {}
        data["relate_monster"] = relate_monster
        data["related_monster"] = related_monster
        return data

    def change_monster_variable_relation(
        self, monster_effect, effect_kind, monster_condition, effect_kind_rel, cost=0
    ):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        relate_monsters = []
        related_monsters = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        for monster_effect_det in monster_effect_monster:

            relation_name = monster_effect_det["monster"]["relation"][0]
            relation_to = monster_effect_det["monster"]["relation_to"][0]
            relation_kind = monster_effect_det["monster"]["relation_kind"][0]
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                for place2 in place1:
                    place = place2["place"]
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if "place_unique_id" in place2:
                            place_unique_id = place2["place_unique_id"]
                            if "det" not in field[x][y] or field[x][y]["det"] is None:
                                continue
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,place_unique_id)
                                if x == -1:
                                    continue
                            else:
                                if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                    continue
                            if monster_condition != "":
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_condition, "", duel
                                ):
                                    continue
                            if (
                                "rel" in field[x][y]["det"]
                                and relation_kind in field[x][y]["det"]["rel"]
                            ):
                                for relate in field[x][y]["det"]["rel"][relation_kind]:
                                    if (
                                        relate["name"] != relation_name
                                        and relation_name != "-1"
                                    ):
                                        continue
                                    if int(relate["to"]) != int(relation_to):
                                        continue
                                    #relate_monster = relate["monster"]
                                    tmp_rel = relate["monster"]
                                    relate_monster = field[tmp_rel["x"]][tmp_rel["y"]]
                                    relate_monster["place"] = "field"
                                    relate_monster["x"] = tmp_rel["x"]
                                    relate_monster["y"] = tmp_rel["y"]
                                    relate_monster["deck_id"] = 0
                                    relate_monster["user"] = chain_user
                                    relate_monster["place_unique_id"] =  relate_monster["det"]["place_unique_id"]
                                    relate_monsters.append(relate_monster)
                                    # get_val_triggerのため
                                    related_monster = {}
                                    related_monster["place"] = "field"
                                    related_monster["x"] = x
                                    related_monster["y"] = y
                                    related_monster["mine_or_other"] = field[x][y][
                                        "mine_or_other"
                                    ]
                                    related_monster["deck_id"] = 0
                                    related_monster["user"] = chain_user
                                    related_monster["place_unique_id"] = field[x][y][
                                        "det"
                                    ]["place_unique_id"]
                                    related_monster["det"] = field[x][y]["det"]
                                    related_monsters.append(related_monster)

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (self.user == chain_user and mine_or_other == "1") or (
                        chain_user != self.user and mine_or_other == "2"
                    ):
                        mine_or_other = "1"
                    elif (self.user != chain_user and mine_or_other == "1") or (
                        chain_user == self.user and mine_or_other == "2"
                    ):
                        mine_or_other = "2"
                    else:
                        mine_or_other = "3"
                    if place == "deck":
                        if mine_or_other == "1":
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other == "2":
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = user_decks[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "deck"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_decks[index][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                if (
                                    "rel" in user_decks[index]
                                    and relation_kind in user_decks[index]["rel"]
                                ):
                                    for relate in user_decks[index][relation_kind]:
                                        if (
                                            relate["name"] != relation_name
                                            and relation_name != "-1"
                                        ):
                                            continue
                                        if int(relate["to"]) != int(relation_to):
                                            continue
                                        relate_monster = relate["monster"]
                                        # get_val_triggerのため
                                        related_monster = {}
                                        related_monster["place"] = "deck"
                                        related_monster["x"] = 0
                                        related_monster["y"] = 0
                                        related_monster["mine_or_other"] = mine_or_other
                                        related_monster["deck_id"] = deck_id
                                        related_monster["user"] = chain_user
                                        related_monster["place_unique_id"] = user_decks[
                                            index
                                        ]["det"]["place_unique_id"]
                                        related_monster["det"] = user_decks[index]
                                        relate_monsters.append(relate_monster)
                                        related_monsters.append(related_monster)
                    if place == "grave":
                        if mine_or_other == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = user_graves[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "grave"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_graves[index][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                if (
                                    "rel" in user_graves[index]
                                    and relation_kind in user_graves[index]["rel"]
                                ):
                                    for relate in user_graves[index][relation_kind]:
                                        if (
                                            relate["name"] != relation_name
                                            and relation_name != "-1"
                                        ):
                                            continue
                                        if int(relate["to"]) != int(relation_to):
                                            continue
                                        relate_monster = relate["monster"]
                                        # get_val_triggerのため
                                        related_monster = {}
                                        related_monster["place"] = "grave"
                                        related_monster["x"] = 0
                                        related_monster["y"] = 0
                                        related_monster["mine_or_other"] = mine_or_other
                                        related_monster["deck_id"] = deck_id
                                        related_monster["user"] = chain_user
                                        related_monster[
                                            "place_unique_id"
                                        ] = user_graves[index]["det"]["place_unique_id"]
                                        related_monster["det"] = user_graves[index]
                                        relate_monsters.append(relate_monster)
                                        related_monsters.append(related_monster)
                    if place == "hand":
                        if mine_or_other == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = user_hands[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "hand"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_hands[index][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                if (
                                    "rel" in user_hands[index]
                                    and relation_kind in user_hands[index]["rel"]
                                ):
                                    for relate in user_hands[index][relation_kind]:
                                        if (
                                            relate["name"] != relation_name
                                            and relation_name != "-1"
                                        ):
                                            continue
                                        if int(relate["to"]) != int(relation_to):
                                            continue
                                        relate_monster = relate["monster"]
                                        # get_val_triggerのため
                                        related_monster = {}
                                        related_monster["place"] = "hand"
                                        related_monster["x"] = 0
                                        related_monster["y"] = 0
                                        related_monster["mine_or_other"] = mine_or_other
                                        related_monster["deck_id"] = deck_id
                                        related_monster["user"] = chain_user
                                        related_monster["place_unique_id"] = user_hands[
                                            index
                                        ]["det"]["place_unique_id"]
                                        related_monster["det"] = user_hands[index]
                                        relate_monsters.append(relate_monster)
                                        related_monsters.append(related_monster)

        field = self.field
        for monster_effect_det2 in monster_effect_monster:
            min_equation_number = self.calculate_boland(
                monster_effect_det2["min_equation_number"], None, False
            )
            relation_name = monster_effect_det2["monster"]["relation"][0]
            relation_to = monster_effect_det2["monster"]["relation_to"][0]
            relation_kind = monster_effect_det2["monster"]["relation_kind"][0]
            field_tmp = []
            tmp_deck = None
            for place in monster_effect_det2["monster"]["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        user_decks = org_deck

                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_decks)):
                            if relation_kind in user_decks[index3]["rel"]:
                                for relate in user_decks[index3][relation_kind]:
                                    if (
                                        relate["name"] != relation_name
                                        and relation_name != "-1"
                                    ):
                                        continue
                                    if int(relate["to"]) != int(relation_to):
                                        continue
                                    relate_monster = relate["monster"]
                                    # get_val_triggerのため
                                    related_monster = {}
                                    related_monster["place"] = "deck"
                                    related_monster["x"] = 0
                                    related_monster["y"] = 0
                                    related_monster["mine_or_other"] = mine_or_other
                                    related_monster["deck_id"] = deck_id
                                    related_monster["user"] = chain_user
                                    related_monster["place_unique_id"] = user_decks[
                                        index3
                                    ]["det"]["place_unique_id"]
                                    related_monster["det"] = user_decks[index3]
                                    if not self.validate_answer(
                                        related_monster,
                                        monster_effect_det["monster"],
                                        exclude,
                                        duel,
                                    ):
                                        continue
                                    relate_monsters.append(relate_monster)
                                    related_monsters.append(related_monster)
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if (
                            "rel" in user_decks[range_i]
                            and relation_kind in user_decks[range_i]["rel"]
                        ):
                            for relate in user_decks[range_i][relation_kind]:
                                if (
                                    relate["name"] != relation_name
                                    and relation_name != "-1"
                                ):
                                    continue
                                if int(relate["to"]) != int(relation_to):
                                    continue
                                relate_monster = relate["monster"]
                                # get_val_triggerのため
                                related_monster = {}
                                related_monster["place"] = "deck"
                                related_monster["x"] = 0
                                related_monster["y"] = 0
                                related_monster["mine_or_other"] = mine_or_other
                                related_monster["deck_id"] = deck_id
                                related_monster["user"] = chain_user
                                related_monster["place_unique_id"] = user_decks[
                                    range_i
                                ]["det"]["place_unique_id"]
                                related_monster["det"] = user_decks[range_i]
                                if not self.validate_answer(
                                    related_monster,
                                    monster_effect_det["monster"],
                                    exclude,
                                    duel,
                                ):
                                    continue
                                relate_monsters.append(relate_monster)
                                related_monsters.append(related_monster)
                elif place_tmp[0] == "grave":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["commongrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                            org_grave = self.graves[deck_id]["commongrave"]
                        user_graves = org_grave
                    if not tmp_deck:
                        return None
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_graves)):
                            if relation_kind in user_graves[index3]["rel"]:
                                for relate in user_graves[index3][relation_kind]:
                                    if (
                                        relate["name"] != relation_name
                                        and relation_name != "-1"
                                    ):
                                        continue
                                    if int(relate["to"]) != int(relation_to):
                                        continue
                                    relate_monster = relate["monster"]
                                    # get_val_triggerのため
                                    related_monster = {}
                                    related_monster["place"] = "grave"
                                    related_monster["x"] = 0
                                    related_monster["y"] = 0
                                    related_monster["mine_or_other"] = mine_or_other
                                    related_monster["deck_id"] = deck_id
                                    related_monster["user"] = chain_user
                                    related_monster["place_unique_id"] = user_graves[
                                        index3
                                    ]["det"]["place_unique_id"]
                                    related_monster["det"] = user_graves[index3]
                                    if not self.validate_answer(
                                        related_monster,
                                        monster_effect_det["monster"],
                                        exclude,
                                        duel,
                                    ):
                                        continue
                                    relate_monsters.append(relate_monster)
                                    related_monsters.append(related_monster)
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if (
                            relation_kind in user_graves[range_i]["rel"]
                            and user_graves[range_i]["rel"][relation_kind]["to"]
                            == relation_to
                            and user_graves[range_i]["rel"][relation_kind]["name"]
                            == relation_name
                        ):
                            for relate in user_graves[range_i][relation_kind]:
                                if (
                                    relate["name"] != relation_name
                                    and relation_name != "-1"
                                ):
                                    continue
                                if int(relate["to"]) != int(relation_to):
                                    continue
                                relate_monster = relate["monster"]
                                # get_val_triggerのため
                                related_monster = {}
                                related_monster["place"] = "grave"
                                related_monster["x"] = 0
                                related_monster["y"] = 0
                                related_monster["mine_or_other"] = mine_or_other
                                related_monster["deck_id"] = deck_id
                                related_monster["user"] = chain_user
                                related_monster["place_unique_id"] = user_graves[
                                    range_i
                                ]["det"]["place_unique_id"]
                                related_monster["det"] = user_graves[range_i]
                                if not self.validate_answer(
                                    related_monster,
                                    monster_effect_det["monster"],
                                    exclude,
                                    duel,
                                ):
                                    continue
                                relate_monsters.append(relate_monster)
                                related_monsters.append(related_monster)
                elif place_tmp[0] == "hand":
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["commonhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            )
                        user_hands = tmp
                    if not user_hands:
                        return None
                    if "move_how" not in monster_effect_det:
                        for index3 in range(len(user_hands)):
                            if (
                                "rel" in user_graves[range_i]
                                and relation_kind in user_hands[index3]["rel"]
                            ):
                                for relate in user_hands[index3][relation_kind]:
                                    if (
                                        relate["name"] != relation_name
                                        and relation_name != "-1"
                                    ):
                                        continue
                                    if int(relate["to"]) != int(relation_to):
                                        continue
                                    relate_monster = relate["monster"]
                                    # get_val_triggerのため
                                    related_monster = {}
                                    related_monster["place"] = "hand"
                                    related_monster["x"] = 0
                                    related_monster["y"] = 0
                                    related_monster["mine_or_other"] = mine_or_other
                                    related_monster["deck_id"] = deck_id
                                    related_monster["user"] = chain_user
                                    related_monster["place_unique_id"] = user_hands[
                                        index3
                                    ]["det"]["place_unique_id"]
                                    related_monster["det"] = user_hands[index3]
                                    if not self.validate_answer(
                                        related_monster,
                                        monster_effect_det["monster"],
                                        exclude,
                                        duel,
                                    ):
                                        continue
                                    relate_monsters.append(relate_monster)
                                    related_monsters.append(related_monster)
                    elif monster_effect_det["move_how"] == 0:
                        range_det = range(0, min_equation_number)
                    elif monster_effect_det["move_how"] == 1:
                        range_det = range(
                            len(tmp_deck) - min_equation_number, len(tmp_deck)
                        )
                    else:
                        range_det = []
                        for range_tmp in range(min_equation_number):
                            range_flag = True
                            while range_flag is True:
                                rand_i = random.randrange(len(tmp))
                                range_i = tmp[rand_i]
                                if range_i not in range_det:
                                    range_det.append(range_i)
                                    range_flag = False
                    for range_i in range_det:
                        if (
                            "rel" in user_hands[range_i]
                            and relation_kind in user_hands[range_i]["rel"]
                            and user_hands[range_i]["rel"][relation_kind]["to"]
                            == relation_to
                            and user_hands[range_i]["rel"][relation_kind]["name"]
                            == relation_name
                        ):
                            for relate in user_hands[range_i][relation_kind]:
                                if (
                                    relate["name"] != relation_name
                                    and relation_name != "-1"
                                ):
                                    continue
                                if int(relate["to"]) != int(relation_to):
                                    continue
                                relate_monster = relate["monster"]
                                # get_val_triggerのため
                                related_monster = {}
                                related_monster["place"] = "hand"
                                related_monster["x"] = 0
                                related_monster["y"] = 0
                                related_monster["mine_or_other"] = mine_or_other
                                related_monster["deck_id"] = deck_id
                                related_monster["user"] = chain_user
                                related_monster["place_unique_id"] = user_hands[
                                    range_i
                                ]["det"]["place_unique_id"]
                                related_monster["det"] = user_hands[range_i]
                                if not self.validate_answer(
                                    related_monster,
                                    monster_effect_det["monster"],
                                    exclude,
                                    duel,
                                ):
                                    continue
                                relate_monsters.append(relate_monster)
                                related_monsters.append(related_monster)
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    chain_user = json.loads(duel.chain_user)
                    effect_user = chain_user[str(duel.chain - 1)]
                    chain_user = effect_user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if int(field[x][y]["mine_or_other"]) != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            if (
                                "rel" in field[x][y]["det"]
                                and field[x][y]["det"]["rel"] is not None
                                and relation_kind in field[x][y]["det"]["rel"]
                            ):
                                for relate in field[x][y]["det"]["rel"][relation_kind]:
                                    if (
                                        relate["name"] != relation_name
                                        and relation_name != "-1"
                                    ):
                                        continue
                                    if int(relate["to"]) != int(relation_to):
                                        continue
                                    tmp_rel = relate["monster"]
                                    relate_monster = field[tmp_rel["x"]][tmp_rel["y"]]
                                    relate_monster["place"] = "field"
                                    relate_monster["x"] = tmp_rel["x"]
                                    relate_monster["y"] = tmp_rel["y"]
                                    relate_monster["deck_id"] = 0
                                    relate_monster["user"] = chain_user
                                    relate_monster["place_unique_id"] =  relate_monster["det"]["place_unique_id"]
                                    related_monster = {}
                                    related_monster["place"] = "field"
                                    related_monster["x"] = x
                                    related_monster["y"] = y
                                    related_monster["mine_or_other"] = field[x][y][
                                        "mine_or_other"
                                    ]
                                    related_monster["deck_id"] = 0
                                    related_monster["user"] = chain_user
                                    related_monster["place_unique_id"] = field[x][y][
                                        "det"
                                    ]["place_unique_id"]
                                    related_monster["det"] = field[x][y]["det"]
                                    if not self.validate_answer(
                                        related_monster,
                                        monster_effect_det["monster"],
                                        exclude,
                                        duel,
                                    ):
                                        continue
                                    relate_monsters.append(relate_monster)
                                    related_monsters.append(related_monster)

        change_val = self.change_monster_variable_relation_det(
            relate_monsters,
            related_monsters,
            monster_effect,
            cost,
            chain_user,
            effect_kind,
            effect_kind_rel,
        )
        return_value = {}
        return_value["monsters"] = relate_monsters
        return_value["monsters2"] = related_monsters
        return_value["val"] = change_val
        return return_value

    def change_monster_variable_relation_det(
        self,
        relate_monsters,
        related_monsters,
        monster_effect,
        cost,
        chain_user,
        effect_kind,
        effect_kind_rel,
    ):
        duel = self.duel
        field = self.field
        flag_change_how = monster_effect["flag_change_how"]
        flag_change_val = monster_effect["flag_change_val"]
        i = 0
        # for relate_monsters in relate_monsterses:
        change_val = []
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        for relate_monster in relate_monsters:
            related_monster = related_monsters[i]
            i += 1
            place = relate_monster["place"]
            if place == "field":
                x = int(relate_monster["x"])
                y = int(relate_monster["y"])
                field = self.field
                if cost == 0:
                    if "place_unique_id" in relate_monster:
                        place_unique_id = relate_monster["place_unique_id"]
                        if self.config.sort is True:
                            x = self.search_place_unique_id(y,place_unique_id)
                            if x == -1:
                                change_val.append(0)
                                continue
                        else:
                            if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                change_val.append(0)
                                continue
                        if self.check_not_effected(
                            field[x][y]["det"],
                            chain_user,
                            effect_kind_rel,
                            "field",
                            0,
                            x,
                            y,
                            field[x][y]["mine_or_other"],
                            cost,
                        ):
                            change_val.append(0)
                            continue
                        if self.check_not_effected(
                            related_monster["det"],
                            chain_user,
                            effect_kind,
                            related_monster["place"],
                            related_monster["deck_id"],
                            related_monster["x"],
                            related_monster["y"],
                            related_monster["mine_or_other"],
                            cost,
                        ):
                            change_val.append(0)
                            continue
                        if len(monster_effect["monster_variable_change_name"]) != 0:
                            change_val_eternal = {}
                            if "persist" in monster_effect:
                                if monster_effect["persist"][0] is True:
                                    change_val_eternal["persist"] = True
                            change_val_eternal["variables"] = {}
                            change_val_eternal[
                                "monster_variable_change_life"
                            ] = monster_effect["monster_variable_change_life"][0]
                            change_val_eternal[
                                "monster_variable_change_life_length"
                            ] = monster_effect["monster_variable_change_life_length"][0]
                            change_val_eternal["effect_kind"] = monster_effect[
                                "monster_variable_change_effect_kind"
                            ][0]
                            for index in range(
                                len(monster_effect["monster_variable_change_name"])
                            ):
                                variable_name = monster_effect[
                                    "monster_variable_change_name"
                                ][index]
                                if "monster_variable_change_initial" in monster_effect:
                                    ini = monster_effect[
                                        "monster_variable_change_initial"
                                    ][index]
                                else:
                                    ini = False
                                if "monster_variable_change_add" in monster_effect:
                                    add = monster_effect["monster_variable_change_add"][index]
                                else:
                                    add = 0
                                change_val_eternal["variables"][variable_name] = {}
                                change_value = str(
                                    self.calculate_boland(
                                        monster_effect["monster_variable_change_val"][
                                            index
                                        ],
                                        related_monster,
                                        False,
                                        1,
                                    )
                                )
                                change_val_eternal["variables"][variable_name][
                                    "value"
                                ] = change_value
                                change_val.append(change_value)
                                change_val_eternal["variables"][variable_name][
                                    "ini"
                                ] = ini
                                change_val_eternal["variables"][variable_name]["add"] = add
                        else:
                            change_val_eternal = None
                        if change_val_eternal is not None:
                            if "eternal" not in field[x][y]["det"]:
                                field[x][y]["det"]["eternal"] = []
                            field[x][y]["det"]["eternal"].append(change_val_eternal)
                        self.raise_trigger_monster_change_val( relate_monster, change_value, "effect", effect_kind_rel, chain_user, 1,variable_name )
                        self.field = field
                        continue
                else:
                    place_unique_id = relate_monster["place_unique_id"]
                    if self.config.sort is True:
                        x = self.search_place_unique_id(y,place_unique_id)
                        if x == -1:
                            change_val.append(0)
                            continue
                    else:
                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                            change_val.append(0)
                            continue
                    if len(monster_effect["monster_variable_change_name"]) != 0:
                        change_val_eternal = {}
                        if "persist" in monster_effect:
                            if monster_effect["persist"][0] is True:
                                change_val_eternal["persist"] = True
                        change_val_eternal["variables"] = {}
                        change_val_eternal[
                            "monster_variable_change_life"
                        ] = monster_effect["monster_variable_change_life"][0]
                        change_val_eternal[
                            "monster_variable_change_life_length"
                        ] = monster_effect["monster_variable_change_life_length"][0]
                        change_val_eternal["effect_kind"] = monster_effect[
                            "monster_variable_change_effect_kind"
                        ][0]
                        for index in range(
                            len(monster_effect["monster_variable_change_name"])
                        ):
                            variable_name = monster_effect[
                                "monster_variable_change_name"
                            ][index]
                            if "monster_variable_change_initial" in monster_effect:
                                ini = monster_effect["monster_variable_change_initial"][
                                    index
                                ]
                            else:
                                ini = False
                            if "monster_variable_change_add" in monster_effect:
                                add = monster_effect["monster_variable_change_add"][index]
                            else:
                                add = 0
                            change_val_eternal["variables"][variable_name] = {}
                            change_value = str(
                                self.calculate_boland(
                                    monster_effect["monster_variable_change_val"][
                                        index
                                    ],
                                    related_monster,
                                    False,
                                    1,
                                )
                            )
                            change_val_eternal["variables"][variable_name][
                                "value"
                            ] = change_value
                            change_val.append(change_value)
                            change_val_eternal["variables"][variable_name]["ini"] = ini
                            change_val_eternal["variables"][variable_name]["add"] = add
                    else:
                        change_val_eternal = None
                    cost_result = self.cost_result
                    if "variable" not in cost_result:
                        cost_result["variable"] = {}

                    if "field" not in cost_result["variable"]:
                        cost_result["variable"]["field"] = []
                    for index in range(
                        len(monster_effect["monster_variable_change_how"])
                    ):
                        cost_result_tmp = {}
                        cost_result_tmp["x"] = x
                        cost_result_tmp["y"] = y
                        cost_result_tmp["place_unique_id"] = place_unique_id
                        cost_result_tmp["change_variable"] = change_val_eternal
                        cost_result["variable"]["field"].append(cost_result_tmp)
                    self.cost_result = cost_result
                    continue

            mine_or_other = relate_monster["mine_or_other"]
            deck_id = relate_monster["deck_id"]
            place_unique_id = relate_monster["det"]["place_unique_id"]
            if (self.user == chain_user and mine_or_other == "1") or (
                chain_user != self.user and mine_or_other == "2"
            ):
                mine_or_other = "1"
            elif (self.user != chain_user and mine_or_other == "1") or (
                chain_user == self.user and mine_or_other == "2"
            ):
                mine_or_other = "2"
            else:
                mine_or_other = "3"
            if place == "deck":
                if mine_or_other == "1":
                    tmp = self.decks[deck_id]["mydeck"]
                elif mine_or_other == "2":
                    tmp = self.decks[deck_id]["otherdeck"]
                else:
                    tmp = self.decks[deck_id]["commondeck"]
                user_decks = tmp
                for index in range(len(user_decks)):
                    if place_unique_id == user_decks[index]["place_unique_id"]:
                        if cost == 0:
                            if self.check_not_effected(
                                user_decks[index],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                change_val.append(0)
                                continue
                            else:
                                if self.check_not_effected(
                                    related_monster["det"],
                                    chain_user,
                                    effect_kind,
                                    related_monster["place"],
                                    related_monster["deck_id"],
                                    related_monster["x"],
                                    related_monster["y"],
                                    related_monster["mine_or_other"],
                                    cost,
                                ):
                                    change_val.append(0)
                                    continue
                                if flag_change_how != "0":
                                    if "flag" not in user_decks[index]:
                                        user_decks[index]["flag"] = 0
                                    if flag_change_how == "1":
                                        user_decks[index]["flag"] += int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "2":
                                        user_decks[index]["flag"] -= int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "3":
                                        user_decks[index]["flag"] = int(flag_change_val)
                                    elif flag_change_how == "4":
                                        user_decks[index]["flag"] = (
                                            int(flag_change_val)
                                            | user_decks[index]["flag"]
                                        )
                                    elif flag_change_how == "5":
                                        user_decks[index]["flag"] -= (
                                            (int(flag_change_val))
                                            & user_decks[index]["flag"]
                                        )
                                if (
                                    len(monster_effect["monster_variable_change_name"])
                                    != 0
                                ):
                                    change_val_eternal = {}
                                    if "persist" in monster_effect:
                                        if monster_effect["persist"][0] is True:
                                            change_val_eternal["persist"] = True
                                    change_val_eternal["variables"] = {}
                                    change_val_eternal[
                                        "monster_variable_change_life"
                                    ] = monster_effect["monster_variable_change_life"][
                                        0
                                    ]
                                    change_val_eternal[
                                        "monster_variable_change_life_length"
                                    ] = monster_effect[
                                        "monster_variable_change_life_length"
                                    ][
                                        0
                                    ]
                                    change_val_eternal["effect_kind"] = monster_effect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    for index in range(
                                        len(
                                            monster_effect[
                                                "monster_variable_change_name"
                                            ]
                                        )
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index]
                                        if (
                                            "monster_variable_change_initial"
                                            in monster_effect
                                        ):
                                            ini = monster_effect[
                                                "monster_variable_change_initial"
                                            ][index]
                                        else:
                                            ini = False
                                        if "monster_variable_change_add" in monster_effect:
                                            add = monster_effect["monster_variable_change_add"][index]
                                        else:
                                            add = 0
                                        change_val_eternal["variables"][
                                            variable_name
                                        ] = {}
                                        change_value = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index],
                                                related_monster,
                                                False,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][variable_name][
                                            "value"
                                        ] = change_value
                                        change_val.append(change_value)
                                        change_val_eternal["variables"][variable_name][
                                            "ini"
                                        ] = ini
                                        change_val_eternal["variables"][variable_name]["add"] = add
                                else:
                                    change_val_eternal = None
                                if change_val_eternal is not None:
                                    if "eternal" not in user_decks[index]:
                                        user_decks[index]["eternal"] = []
                                    user_decks[index]["eternal"].append(
                                        change_val_eternal
                                    )
                                tmp2 = {}
                                tmp2["det"] = user_decks[index]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_decks[index][
                                    "place_unique_id"
                                ]
                                self.raise_trigger_monster_change_val(user_decks[index], change_value, "effect",
                                                                  effect_kind_rel, chain_user, 1, variable_name)
                            if mine_or_other == "1":
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif mine_or_other == "2":
                                self.decks[deck_id]["otherdeck"] = user_decks
                            else:
                                self.decks[deck_id]["commondeck"] = user_decks
                        else:
                            cost_result = self.cost_result
                            if "variable" not in cost_result:
                                cost_result["variable"] = {}
                            if "deck" not in cost_result["variable"]:
                                cost_result["variable"]["deck"] = []
                            if len(monster_effect["monster_variable_change_name"]) != 0:
                                change_val_eternal = {}
                                if "persist" in monster_effect:
                                    if monster_effect["persist"][0] is True:
                                        change_val_eternal["persist"] = True
                                change_val_eternal["variables"] = {}
                                change_val_eternal[
                                    "monster_variable_change_life"
                                ] = monster_effect["monster_variable_change_life"][0]
                                change_val_eternal[
                                    "monster_variable_change_life_length"
                                ] = monster_effect[
                                    "monster_variable_change_life_length"
                                ][
                                    0
                                ]
                                change_val_eternal["effect_kind"] = monster_effect[
                                    "monster_variable_change_effect_kind"
                                ][0]
                                for index in range(
                                    len(monster_effect["monster_variable_change_name"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index]
                                    if (
                                        "monster_variable_change_initial"
                                        in monster_effect
                                    ):
                                        ini = monster_effect[
                                            "monster_variable_change_initial"
                                        ][index]
                                    else:
                                        ini = False
                                    if "monster_variable_change_add" in monster_effect:
                                        add = monster_effect["monster_variable_change_add"][index]
                                    else:
                                        add = 0
                                    change_val_eternal["variables"][variable_name] = {}
                                    change_value = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index],
                                            related_monster,
                                            False,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][variable_name][
                                        "value"
                                    ] = change_value
                                    change_val.append(change_value)
                                    change_val_eternal["variables"][variable_name][
                                        "ini"
                                    ] = ini
                                    change_val_eternal["variables"][variable_name]["add"] = add
                            else:
                                change_val_eternal = None
                            cost_result_tmp = {}
                            cost_result_tmp["change_variable"] = change_val_eternal
                            cost_result_tmp["place_unique_id"] = place_unique_id
                            cost_result_tmp["deck_id"] = deck_id
                            cost_result_tmp["user"] = int(mine_or_other)
                            cost_result["variable"]["deck"].append(cost_result_tmp)
                            self.cost_result = cost_result

            if place == "grave":
                if mine_or_other == "1":
                    tmp = self.graves[deck_id]["mygrave"]
                elif mine_or_other == "2":
                    tmp = self.graves[deck_id]["othergrave"]
                else:
                    tmp = self.graves[deck_id]["commongrave"]
                user_graves = tmp
                for index in range(len(user_graves)):
                    if place_unique_id == user_graves[index]["place_unique_id"]:
                        if cost == 0:
                            if self.check_not_effected(
                                user_graves[index],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                change_val.append(0)
                                continue
                            else:
                                if self.check_not_effected(
                                    related_monster["det"],
                                    chain_user,
                                    effect_kind,
                                    related_monster["place"],
                                    related_monster["deck_id"],
                                    related_monster["x"],
                                    related_monster["y"],
                                    related_monster["mine_or_other"],
                                    cost,
                                ):
                                    change_val.append(0)
                                    continue
                                if flag_change_how != "0":
                                    if "flag" not in user_graves[index]:
                                        user_graves[index]["flag"] = 0
                                    if flag_change_how == "1":
                                        user_graves[index]["flag"] += int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "2":
                                        user_graves[index]["flag"] -= int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "3":
                                        user_graves[index]["flag"] = int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "4":
                                        user_graves[index]["flag"] = (
                                            int(flag_change_val)
                                            | user_graves[index]["flag"]
                                        )
                                    elif flag_change_how == "5":
                                        user_graves[index]["flag"] -= (
                                            (int(flag_change_val))
                                            & user_graves[index]["flag"]
                                        )
                                if (
                                    len(monster_effect["monster_variable_change_name"])
                                    != 0
                                ):
                                    change_val_eternal = {}
                                    if "persist" in monster_effect:
                                        if monster_effect["persist"][0] is True:
                                            change_val_eternal["persist"] = True
                                    change_val_eternal["variables"] = {}
                                    change_val_eternal[
                                        "monster_variable_change_life"
                                    ] = monster_effect["monster_variable_change_life"][
                                        0
                                    ]
                                    change_val_eternal[
                                        "monster_variable_change_life_length"
                                    ] = monster_effect[
                                        "monster_variable_change_life_length"
                                    ][
                                        0
                                    ]
                                    change_val_eternal["effect_kind"] = monster_variable_change_life_lengtheffect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    for index in range(
                                        len(
                                            monster_effect[
                                                "monster_variable_change_name"
                                            ]
                                        )
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index]
                                        if (
                                            "monster_variable_change_initial"
                                            in monster_effect
                                        ):
                                            ini = monster_effect[
                                                "monster_variable_change_initial"
                                            ][index]
                                        else:
                                            ini = False
                                        if "monster_variable_change_add" in monster_effect:
                                            add = monster_effect["monster_variable_change_add"][index]
                                        else:
                                            add = 0
                                        change_val_eternal["variables"][
                                            variable_name
                                        ] = {}
                                        change_value = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index],
                                                related_monster,
                                                False,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][variable_name][
                                            "value"
                                        ] = change_value
                                        change_val.append(change_value)
                                        change_val_eternal["variables"][variable_name][
                                            "ini"
                                        ] = ini
                                        change_val_eternal["variables"][variable_name]["add"] = add
                                else:
                                    change_val_eternal = None
                                if change_val_eternal is not None:
                                    if "eternal" not in user_graves[index]:
                                        user_graves[index]["eternal"] = []
                                    user_graves[index]["eternal"].append(
                                        change_val_eternal
                                    )
                                tmp2 = {}
                                tmp2["det"] = user_graves[index]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_graves[index][
                                    "place_unique_id"
                                ]
                                self.raise_trigger_monster_change_val(tmp2, change_value, "effect",
                                                                  effect_kind_rel, chain_user, 1, variable_name)
                            if mine_or_other == "1":
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other == "2":
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                        else:
                            cost_result = self.cost_result
                            if "variable" not in cost_result:
                                cost_result["variable"] = {}
                            if "grave" not in cost_result["variable"]:
                                cost_result["variable"]["grave"] = []
                            if len(monster_effect["monster_variable_change_name"]) != 0:
                                change_val_eternal = {}
                                if "persist" in monster_effect:
                                    if monster_effect["persist"][0] is True:
                                        change_val_eternal["persist"] = True
                                change_val_eternal["variables"] = {}
                                change_val_eternal[
                                    "monster_variable_change_life"
                                ] = monster_effect["monster_variable_change_life"][0]
                                change_val_eternal[
                                    "monster_variable_change_life_length"
                                ] = monster_effect[
                                    "monster_variable_change_life_length"
                                ][
                                    0
                                ]
                                change_val_eternal["effect_kind"] = monster_effect[
                                    "monster_variable_change_effect_kind"
                                ][0]
                                for index in range(
                                    len(monster_effect["monster_variable_change_name"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index]
                                    if (
                                        "monster_variable_change_initial"
                                        in monster_effect
                                    ):
                                        ini = monster_effect[
                                            "monster_variable_change_initial"
                                        ][index]
                                    else:
                                        ini = False
                                    if "monster_variable_change_add" in monster_effect:
                                        add = monster_effect["monster_variable_change_add"][index]
                                    else:
                                        add = 0
                                    change_val_eternal["variables"][variable_name] = {}
                                    change_value = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index],
                                            related_monster,
                                            False,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][variable_name][
                                        "value"
                                    ] = change_value
                                    change_val.append(change_value)
                                    change_val_eternal["variables"][variable_name][
                                        "ini"
                                    ] = ini
                                    change_val_eternal["variables"][variable_name]["add"] = add
                            else:
                                change_val_eternal = None
                            cost_result_tmp = {}
                            cost_result_tmp["change_variable"] = change_val_eternal
                            cost_result_tmp["place_unique_id"] = place_unique_id
                            cost_result_tmp["deck_id"] = deck_id
                            cost_result_tmp["user"] = int(mine_or_other)
                            cost_result["variable"]["grave"].append(cost_result_tmp)
                            self.cost_result = cost_result
            if place == "hand":
                if mine_or_other == "1":
                    tmp = self.hands[deck_id]["myhand"]
                elif mine_or_other == "2":
                    tmp = self.hands[deck_id]["otherhand"]
                else:
                    tmp = self.hands[deck_id]["commonhand"]
                user_hands = tmp
                for index in range(len(user_hands)):
                    if place_unique_id == user_hands[index]["place_unique_id"]:
                        if cost == 0:
                            if self.check_not_effected(
                                user_hands[index],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                change_val.append(0)
                                continue
                            else:
                                if self.check_not_effected(
                                    related_monster["det"],
                                    chain_user,
                                    effect_kind,
                                    related_monster["place"],
                                    related_monster["deck_id"],
                                    related_monster["x"],
                                    related_monster["y"],
                                    related_monster["mine_or_other"],
                                    cost,
                                ):
                                    change_val.append(0)
                                    continue
                                if flag_change_how != "0":
                                    if "flag" not in user_hands[index]:
                                        user_hands[index]["flag"] = 0
                                    if flag_change_how == "1":
                                        user_hands[index]["flag"] += int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "2":
                                        user_hands[index]["flag"] -= int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "3":
                                        user_hands[index]["flag"] = int(flag_change_val)
                                    elif flag_change_how == "4":
                                        user_hands[index]["flag"] = (
                                            int(flag_change_val)
                                            | user_hands[index]["flag"]
                                        )
                                    elif flag_change_how == "5":
                                        user_hands[index]["flag"] -= (
                                            (int(flag_change_val))
                                            & user_hands[index]["flag"]
                                        )
                                if (
                                    len(monster_effect["monster_variable_change_name"])
                                    != 0
                                ):
                                    change_val_eternal = {}
                                    if "persist" in monster_effect:
                                        if monster_effect["persist"][0] is True:
                                            change_val_eternal["persist"] = True
                                    change_val_eternal["variables"] = {}
                                    change_val_eternal[
                                        "monster_variable_change_life"
                                    ] = monster_effect["monster_variable_change_life"][
                                        0
                                    ]
                                    change_val_eternal[
                                        "monster_variable_change_life_length"
                                    ] = monster_effect[
                                        "monster_variable_change_life_length"
                                    ][
                                        0
                                    ]
                                    change_val_eternal["effect_kind"] = monster_effect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    for index in range(
                                        len(
                                            monster_effect[
                                                "monster_variable_change_name"
                                            ]
                                        )
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index]
                                        if (
                                            "monster_variable_change_initial"
                                            in monster_effect
                                        ):
                                            ini = monster_effect[
                                                "monster_variable_change_initial"
                                            ][index]
                                        else:
                                            ini = False
                                        if "monster_variable_change_add" in monster_effect:
                                            add = monster_effect["monster_variable_change_add"][index]
                                        else:
                                            add = 0
                                        change_val_eternal["variables"][
                                            variable_name
                                        ] = {}
                                        change_value = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index],
                                                related_monster,
                                                False,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][variable_name][
                                            "value"
                                        ] = change_value
                                        change_val.append(change_value)
                                        change_val_eternal["variables"][variable_name][
                                            "ini"
                                        ] = ini
                                        change_val_eternal["variables"][variable_name]["add"] = add
                                else:
                                    change_val_eternal = None
                                if change_val_eternal is not None:
                                    if "eternal" not in user_hands[index]:
                                        user_hands[index]["eternal"] = []
                                    user_hands[index]["eternal"].append(
                                        change_val_eternal
                                    )
                                tmp2 = {}
                                tmp2["det"] = user_hands[index]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_hands[index][
                                    "place_unique_id"
                                ]
                                self.raise_trigger_monster_change_val(tmp2, change_value, "effect",
                                                                  effect_kind_rel, chain_user, 1, variable_name)
                            if mine_or_other == "1":
                                self.hands[deck_id]["myhand"] = user_hands
                            elif mine_or_other == "2":
                                self.hands[deck_id]["otherhand"] = user_hands
                            else:
                                self.hands[deck_id]["commonhand"] = user_hands
                        else:
                            cost_result = self.cost_result
                            if "variable" not in cost_result:
                                cost_result["variable"] = {}
                            if "hand" not in cost_result["variable"]:
                                cost_result["variable"]["hand"] = []
                            if len(monster_effect["monster_variable_change_name"]) != 0:
                                change_val_eternal = {}
                                if "persist" in monster_effect:
                                    if monster_effect["persist"][0] is True:
                                        change_val_eternal["persist"] = True
                                change_val_eternal["variables"] = {}
                                change_val_eternal[
                                    "monster_variable_change_life"
                                ] = monster_effect["monster_variable_change_life"][0]
                                change_val_eternal[
                                    "monster_variable_change_life_length"
                                ] = monster_effect[
                                    "monster_variable_change_life_length"
                                ][
                                    0
                                ]
                                change_val_eternal["effect_kind"] = monster_effect[
                                    "monster_variable_change_effect_kind"
                                ][0]
                                for index in range(
                                    len(monster_effect["monster_variable_change_name"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index]
                                    if (
                                        "monster_variable_change_initial"
                                        in monster_effect
                                    ):
                                        ini = monster_effect[
                                            "monster_variable_change_initial"
                                        ][index]
                                    else:
                                        ini = False
                                    if "monster_variable_change_add" in monster_effect:
                                        add = monster_effect["monster_variable_change_add"][index]
                                    else:
                                        add = 0
                                    change_val_eternal["variables"][variable_name] = {}
                                    change_value = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index],
                                            related_monster,
                                            False,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][variable_name][
                                        "value"
                                    ] = change_value
                                    change_val.append(change_value)
                                    change_val_eternal["variables"][variable_name][
                                        "ini"
                                    ] = ini
                                    change_val_eternal["variables"][variable_name]["add"] = add
                            else:
                                change_val_eternal = None
                            cost_result_tmp = {}
                            cost_result_tmp["change_variable"] = change_val_eternal
                            cost_result_tmp["place_unique_id"] = place_unique_id
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["user"] = int(mine_or_other)
                        cost_result["variable"]["hand"].append(cost_result_tmp)
                        self.cost_result = cost_result

        self.field = field
        return change_val

    def change_monster_variable_eternal_cost(
        self, monster_effect, effect_kind, monster_condition,change_val_flag,accumulate_flag
    ):
        return self.change_monster_variable_eternal(
            monster_effect, effect_kind, monster_condition, 1,change_val_flag,accumulate_flag
        )

    def change_monster_variable_eternal(
        self, monster_effect, effect_kind, monster_condition, cost=0,change_val_flag = False,accumulate_flag = False
    ):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        variable = json.loads(duel.global_variable)
        if cost == 0:
            chain_user = chain_user[str(duel.chain - 1)]
        else:
            chain_user = chain_user[str(self.tmp_chain)]
        field = self.field
        monster_effect = json.loads(monster_effect)
        flag_change_how = monster_effect["flag_change_how"]
        flag_change_val = monster_effect["flag_change_val"]
        exclude = monster_effect["exclude"]
        monster_effect_monster = monster_effect["monster"]
        monster_effect_text_monster0 = monster_effect_monster[0]["monster"]
        monsters = []
        return_change_val = []
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        if len(monster_effect["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect:
                if monster_effect["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect["monster_variable_change_name"])):
                variable_name = monster_effect["monster_variable_change_name"][index]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                # change_val_eternal["variables"][variable_name]["value"] = str(self.calculate_boland(monster_effect["monster_variable_change_val"][index] ,None,False,1))
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        for monster_effect_det in monster_effect_monster:
            if "as_monster_condition" not in monster_effect_det:
                continue
            if monster_effect_det["as_monster_condition"] == "":
                continue
            as_monsters = monster_effect_det["as_monster_condition"]
            if not isinstance(as_monsters, list):
                tmp_monster = []
                tmp_monster.append(as_monsters)
                as_monsters = tmp_monster
            for as_monster in as_monsters:
                if as_monster[0] == "~":
                    tmp = self.cost
                    if duel.in_cost is True:
                        tmp = tmp[str(self.tmp_chain)]
                    else:
                        tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "%":
                    tmp = self.timing_mess
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                elif as_monster[0] == "-":
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 2))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                else:
                    tmp = self.mess
                    tmp = tmp[str(int(duel.chain - 1))]
                    if as_monster in tmp:
                        place1 = tmp[as_monster]
                    else:
                        place1 = []
                for place2 in place1:
                    place = place2["place"]
                    if place == "player":
                        mine_or_other_player = place2["mine_or_other"]
                        change_val_tmp = str(
                            self.calculate_boland(
                                monster_effect[
                                    "monster_variable_val_player"
                                ],
                                None,
                                False,
                                1,
                                change_val_flag = change_val_flag,
                                accumulate_val_flag = accumulate_flag

                            )
                        )
                        variable_id = monster_effect[
                            "monster_variable_player_id"
                        ]
                        how = monster_effect[
                            "monster_variable_player_how"
                        ]
                        if cost == 1:
                            cost_result = self.cost_result
                            if "global_change_val" not in cost_result:
                                cost_result["global_change_val"] = []
                            tmp = {}
                            tmp["mine_or_other"] = mine_or_other_player
                            tmp["variable"] = variable
                            tmp["variable_id"] = variable_id
                            tmp["change_val"] = change_val_tmp
                            tmp["change_how"] = how
                            cost_result["global_change_val"].append(tmp)
                            self.cost_result = cost_result
                        if self.duel.alt_global != "":
                            alt_val = self.change_alt_global2(
                                variable_id, mine_or_other_player, how, effect_kind, change_val
                                )
                        else:
                            alt_val = 0
                        change_val_tmp -= alt_val
                        instead_val = self.check_variable_instead( variable_id,
                        mine_or_other_player,
                        change_val_tmp,
                        cost,
                        chain_user,
                        effect_kind,
                            )
                        change_val_tmp -= instead_val
                        if change_val_flag:
                            self.raise_trigger_change_val(
                                None, change_val_tmp, cost, effect_kind, chain_user, 0
                            )
                        return_change_val.append(change_val_tmp)
                        if mine_or_other_player == 1:
                            if how == 0:
                                variable[str(variable_id)]["1_value"] += change_val_tmp
                            elif how == 1:
                                variable[str(variable_id)]["1_value"] -= change_val_tmp
                            elif how == 2:
                                variable[str(variable_id)]["1_value"] = change_val_tmp
                        elif mine_or_other_player == 2:
                            if how == 0:
                                variable[str(variable_id)]["2_value"] += change_val_tmp
                            elif how == 1:
                                variable[str(variable_id)]["2_value"] -= change_val_tmp
                            elif how == 2:
                                variable[str(variable_id)]["2_value"] = change_val_tmp
                        else:
                            if how == 0:
                                variable[str(variable_id)]["value"] += change_val_tmp
                            elif how == 1:
                                variable[str(variable_id)]["value"] -= change_val_tmp
                            elif how == 2:
                                variable[str(variable_id)]["value"] = change_val_tmp
                    if place == "field":
                        x = int(place2["x"])
                        y = int(place2["y"])
                        field = self.field
                        if cost == 0:
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.config.sort is True:
                                    x = self.search_place_unique_id(y,place_unique_id)
                                    if x == -1:
                                        continue
                                if (
                                    "det" not in field[x][y]
                                    or field[x][y]["det"] is None
                                ):
                                    continue
                                if (
                                    field[x][y]["det"]["place_unique_id"]
                                    != place_unique_id
                                ):
                                    continue
                                variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][0]
                                if "minus" in monster_effect:
                                    minus = monster_effect["minus"][0]
                                else:
                                    minus = False
                                tmp2 = {}
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                change_val_tmp = str(
                                    self.calculate_boland(
                                        monster_effect[
                                            "monster_variable_change_val"
                                        ][0],
                                        tmp2,
                                        minus,
                                        1,
                                    )
                                )
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    chain_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                    change_val_tmp
                                ):
                                    continue
                                if monster_condition != "":
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                monsters.append(tmp2)
                                if(change_val_eternal is None):
                                    return_change_val.append(0)
                                if flag_change_how != "0":
                                    if "flag" not in field[x][y]["det"]:
                                        field[x][y]["det"]["flag"] = 0
                                    if flag_change_how == "1":
                                        field[x][y]["det"]["flag"] += int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "2":
                                        field[x][y]["det"]["flag"] -= int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "3":
                                        field[x][y]["det"]["flag"] = int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "4":
                                        field[x][y]["det"]["flag"] = (
                                            int(flag_change_val)
                                            | field[x][y]["det"]["flag"]
                                        )
                                    elif flag_change_how == "5":
                                        field[x][y]["det"]["flag"] -= (
                                            (int(flag_change_val))
                                            & field[x][y]["det"]["flag"]
                                        )
                                if change_val_eternal is not None:
                                    for index2 in range(
                                        len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][variable_name][
                                            "value"

                                        ]  = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        self.raise_trigger_monster_change_val( tmp2, change_val_tmp, "effect", effect_kind, chain_user, 1 ,variable_name)
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                    if "eternal" not in field[x][y]["det"]:
                                        field[x][y]["det"]["eternal"] = []
                                    field[x][y]["det"]["eternal"].append(
                                        change_val_eternal

                                    )
                                self.field = field
                                continue
                        else:
                            place_unique_id = place2["place_unique_id"]
                            if self.config.sort is True:
                                x = self.search_place_unique_id(y,place_unique_id)
                                if x == -1:
                                    continue
                            else:
                                if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                    continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if monster_condition != "":
                                if not self.validate_answer(
                                    tmp2, monster_condition, "", duel
                                ):
                                    continue
                            monsters.append(tmp2)
                            if(change_val_eternal is None):
                                return_change_val.append(0)

                            cost_result = self.cost_result
                            if "variable" not in cost_result:
                                cost_result["variable"] = {}

                            if "field" not in cost_result["variable"]:
                                cost_result["variable"]["field"] = []
                            if change_val_eternal is not None:
                                for index2 in range(
                                    len(change_val_eternal["variables"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if "minus" in monster_effect:
                                        minus = monster_effect["minus"][index2]
                                    else:
                                        minus = False
                                    change_val_tmp = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index2],
                                            tmp2,
                                            minus,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][variable_name][
                                        "value"

                                    ]  = change_val_tmp
                                    change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                    ] =  monster_effect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    if index2 == 0:
                                        return_change_val.append(change_val_tmp)
                                cost_result_tmp = {}
                                cost_result_tmp["x"] = x
                                cost_result_tmp["y"] = y
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["change_variable"] = change_val_eternal
                                cost_result_tmp["effect_kind"] = monster_effect[
                                    "monster_variable_change_effect_kind"
                                ][0]

                                cost_result["variable"]["field"].append(cost_result_tmp)
                            if flag_change_how != "0":
                                if "flag" not in field[x][y]["det"]:
                                    change_flag = 0
                                else:
                                    change_flag = field[x][y]["det"]["flag"]
                                if flag_change_how == "1":
                                    change_flag += int(flag_change_val)
                                elif flag_change_how == "2":
                                    change_flag -= int(flag_change_val)
                                elif flag_change_how == "3":
                                    change_flag = int(flag_change_val)
                                elif flag_change_how == "4":
                                    change_flag = int(flag_change_val) | change_flag
                                elif flag_change_how == "5":
                                    change_flag -= int(flag_change_val) & change_flag
                                cost_result_tmp = {}
                                cost_result_tmp["x"] = x
                                cost_result_tmp["y"] = y
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["change_flag"] = change_flag
                                if "flag" not in cost_result:
                                    cost_result["flag"] = {}
                                if "field" not in cost_result["flag"]:
                                    cost_result["flag"]["field"] = []
                                cost_result["flag"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            continue

                    mine_or_other = place2["mine_or_other"]
                    deck_id = place2["deck_id"]
                    place_unique_id = place2["place_unique_id"]
                    if (self.user == 1 and int(mine_or_other) == 1) or (
                        2 == self.user and int(mine_or_other) == 2
                    ):
                        mine_or_other2 = "1"
                    elif (self.user != 1 and int(mine_or_other) == 1) or (
                        2 != self.user and int(mine_or_other) == 2
                    ):
                        mine_or_other2 = "2"
                    else:
                        mine_or_other2 = "3"
                    if place == "deck":
                        if mine_or_other2 == "1":
                            tmp = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == "2":
                            tmp = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp = self.decks[deck_id]["commondeck"]
                        user_decks = tmp
                        for index in range(len(user_decks)):
                            if place_unique_id == user_decks[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_decks[index],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_decks[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_decks[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        monsters.append(tmp2)
                                        if change_val_eternal is None:
                                            return_change_val.append(tmp2)

                                        if flag_change_how != "0":
                                            if "flag" not in user_decks[index]:
                                                user_decks[index]["flag"] = 0
                                            if flag_change_how == "1":
                                                user_decks[index]["flag"] += int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "2":
                                                user_decks[index]["flag"] -= int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "3":
                                                user_decks[index]["flag"] = int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "4":
                                                user_decks[index]["flag"] = (
                                                    int(flag_change_val)
                                                    | user_decks[index]["flag"]
                                                )
                                            elif flag_change_how == "5":
                                                user_decks[index]["flag"] -= (
                                                    (int(flag_change_val))
                                                    & user_decks[index]["flag"]
                                                )
                                        if change_val_eternal is not None:
                                            for index2 in range(
                                                len(change_val_eternal["variables"])
                                            ):
                                                variable_name = monster_effect[
                                                    "monster_variable_change_name"
                                                ][index2]
                                                if "minus" in monster_effect:
                                                    minus = monster_effect["minus"][index2]
                                                else:
                                                    minus = False
                                                change_val_tmp = str(
                                                    self.calculate_boland(
                                                        monster_effect[
                                                            "monster_variable_change_val"
                                                        ][index2],
                                                        tmp2,
                                                        minus,
                                                        1,
                                                    )
                                                )
                                                change_val_eternal["variables"][
                                                    variable_name
                                                ]["value"] = change_val_tmp
                                                change_val_eternal["variables"][variable_name][
                                                    "effect_kind"
                                                ] = monster_effect[
                                                    "monster_variable_change_effect_kind"
                                                ][0]
                                                if index2 == 0:
                                                    return_change_val.append(change_val_tmp)
                                            if "eternal" not in user_decks[index]:
                                                user_decks[index]["eternal"] = []
                                            user_decks[index]["eternal"].append(
                                                change_val_eternal
                                            )
                                            tmp2 = {}
                                            tmp2["det"] = user_decks[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "deck"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_decks[index][
                                                "place_unique_id"
                                            ]
                                            self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect", effect_kind,
                                                                          chain_user, 1, variable_name)
                                    if mine_or_other2 == "1":
                                        self.decks[deck_id]["mydeck"] = user_decks
                                    elif mine_or_other2 == "2":
                                        self.decks[deck_id]["otherdeck"] = user_decks
                                    else:
                                        self.decks[deck_id]["commondeck"] = user_decks
                                else:
                                    if self.check_not_effected(
                                        user_decks[index],
                                        chain_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        continue
                                    tmp2 = {}
                                    tmp2["det"] = user_decks[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "deck"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_decks[index][
                                        "place_unique_id"
                                    ]
                                    if monster_condition != "":
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    monsters.append(tmp2)
                                    if change_val_eternal is None:
                                        return_change_val.append(0)
                                    cost_result = self.cost_result
                                    if "variable" not in cost_result:
                                        cost_result["variable"] = {}
                                    if "deck" not in cost_result["variable"]:
                                        cost_result["variable"]["deck"] = []
                                    if "flag" not in cost_result:
                                        cost_result["flag"] = {}
                                    if "deck" not in cost_result["flag"]:
                                        cost_result["flag"]["deck"] = []
                                    cost_result_tmp = {}
                                    if change_val_eternal is not None:
                                        for index2 in range(
                                            len(change_val_eternal["variables"])
                                        ):
                                            variable_name = monster_effect[
                                                "monster_variable_change_name"
                                            ][index2]
                                            if "minus" in monster_effect:
                                                minus = monster_effect["minus"][index2]
                                            else:
                                                minus = False
                                            change_val_tmp = str(
                                                self.calculate_boland(
                                                    monster_effect[
                                                        "monster_variable_change_val"
                                                    ][index2],
                                                    tmp2,
                                                    minus,
                                                    1,
                                                )
                                            )
                                            change_val_eternal["variables"][
                                                variable_name
                                            ]["value"] = change_val_tmp
                                            change_val_eternal["variables"][variable_name][
                                                "effect_kind"
                                            ] = monster_effect[
                                                "monster_variable_change_effect_kind"
                                            ][0]
                                            if index2 == 0:
                                                return_change_val.append(change_val_tmp)
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result["variable"]["deck"].append(
                                        cost_result_tmp
                                    )
                                    if flag_change_how != "0":
                                        if "flag" not in user_decks[index]:
                                            change_flag = 0
                                        else:
                                            change_flag = user_decks[index]["flag"]
                                        if flag_change_how == "1":
                                            change_flag += int(flag_change_val)
                                        elif flag_change_how == "2":
                                            change_flag -= int(flag_change_val)
                                        elif flag_change_how == "3":
                                            change_flag = int(flag_change_val)
                                        elif flag_change_how == "4":
                                            change_flag = (
                                                int(flag_change_val) | change_flag
                                            )
                                        elif flag_change_how == "5":
                                            change_flag -= (
                                                int(flag_change_val) & change_flag
                                            )
                                        cost_result_tmp = {}
                                        cost_result_tmp["x"] = 0
                                        cost_result_tmp["y"] = 0
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["user"] = int(mine_or_other)
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["change_flag"] = change_flag
                                        cost_result["flag"]["deck"].append(
                                            cost_result_tmp
                                        )
                                    self.cost_result = cost_result

                    if place == "grave":
                        if mine_or_other2 == "1":
                            tmp = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == "2":
                            tmp = self.graves[deck_id]["othergrave"]
                        else:
                            tmp = self.graves[deck_id]["commongrave"]
                        user_graves = tmp
                        for index in range(len(user_graves)):
                            if place_unique_id == user_graves[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_graves[index],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_graves[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_graves[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        monsters.append(tmp2)
                                        if change_val_eternal is None:
                                            return_change_val.append(0)
                                        if flag_change_how != "0":
                                            if "flag" not in user_graves[index]:
                                                user_graves[index]["flag"] = 0
                                            if flag_change_how == "1":
                                                user_graves[index]["flag"] += int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "2":
                                                user_graves[index]["flag"] -= int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "3":
                                                user_graves[index]["flag"] = int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "4":
                                                user_graves[index]["flag"] = (
                                                    int(flag_change_val)
                                                    | user_graves[index]["flag"]
                                                )
                                            elif flag_change_how == "5":
                                                user_graves[index]["flag"] -= (
                                                    (int(flag_change_val))
                                                    & user_graves[index]["flag"]
                                                )
                                        if change_val_eternal is not None:
                                            for index2 in range(
                                                len(change_val_eternal["variables"])
                                            ):
                                                variable_name = monster_effect[
                                                    "monster_variable_change_name"
                                                ][index2]
                                                if "minus" in monster_effect:
                                                    minus = monster_effect["minus"][index2]
                                                else:
                                                    minus = False
                                                change_val_tmp = str(
                                                    self.calculate_boland(
                                                        monster_effect[
                                                            "monster_variable_change_val"
                                                        ][index2],
                                                        tmp2,
                                                        minus,
                                                        1,
                                                    )
                                                )
                                                change_val_eternal["variables"][
                                                    variable_name
                                                ]["value"] = change_val_tmp
                                                change_val_eternal["variables"][variable_name][
                                                    "effect_kind"
                                                ] = monster_effect[
                                                    "monster_variable_change_effect_kind"
                                                ][0]
                                                if index2 == 0:
                                                    return_change_val.append(change_val_tmp)
                                            if "eternal" not in user_graves[index]:
                                                user_graves[index]["eternal"] = []
                                            user_graves[index]["eternal"].append(
                                                change_val_eternal
                                            )
                                            tmp2 = {}
                                            tmp2["det"] = user_graves[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "grave"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_graves[index][
                                                "place_unique_id"
                                            ]
                                            self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                                          effect_kind,
                                                                          chain_user, 1, variable_name)
                                    if mine_or_other2 == "1":
                                        self.graves[deck_id]["mygrave"] = user_graves
                                    elif mine_or_other2 == "2":
                                        self.graves[deck_id]["othergrave"] = user_graves
                                    else:
                                        self.graves[deck_id][
                                            "commongrave"
                                        ] = user_graves
                                else:
                                    if self.check_not_effected(
                                        user_graves[index],
                                        chain_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        continue
                                    tmp2 = {}
                                    tmp2["det"] = user_graves[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "grave"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_graves[index][
                                        "place_unique_id"
                                    ]
                                    if monster_condition != "":
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    monsters.append(tmp2)
                                    if return_change_val is None:
                                        return_change_val.append(0)
                                    cost_result = self.cost_result
                                    if "variable" not in cost_result:
                                        cost_result["variable"] = {}
                                    if "grave" not in cost_result["variable"]:
                                        cost_result["variable"]["grave"] = []
                                    if "flag" not in cost_result:
                                        cost_result["flag"] = {}
                                    if "grave" not in cost_result["flag"]:
                                        cost_result["flag"]["grave"] = []
                                    if change_val_eternal is not None:
                                        for index2 in range(
                                            len(change_val_eternal["variables"])
                                        ):
                                            variable_name = monster_effect[
                                                "monster_variable_change_name"
                                            ][index2]
                                            if "minus" in monster_effect:
                                                minus = monster_effect["minus"][index2]
                                            else:
                                                minus = False
                                            change_val_tmp = str(
                                                self.calculate_boland(
                                                    monster_effect[
                                                        "monster_variable_change_val"
                                                    ][index2],
                                                    tmp2,
                                                    minus,
                                                    1,
                                                )
                                            )
                                            change_val_eternal["variables"][
                                                variable_name
                                            ]["value"] = change_val_tmp
                                            change_val_eternal["variables"][variable_name][
                                                "effect_kind"
                                            ] = monster_effect[
                                                "monster_variable_change_effect_kind"
                                            ][0]
                                            if index2 == 0:
                                                return_change_val.append(change_val_tmp)
                                    cost_result_tmp = {}
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result["variable"]["grave"].append(
                                        cost_result_tmp
                                    )
                                    if flag_change_how != "0":
                                        if "flag" not in user_graves[index]:
                                            change_flag = 0
                                        else:
                                            change_flag = user_graves[index]["flag"]
                                        if flag_change_how == "1":
                                            change_flag += int(flag_change_val)
                                        elif flag_change_how == "2":
                                            change_flag -= int(flag_change_val)
                                        elif flag_change_how == "3":
                                            change_flag = int(flag_change_val)
                                        elif flag_change_how == "4":
                                            change_flag = (
                                                int(flag_change_val) | change_flag
                                            )
                                        elif flag_change_how == "5":
                                            change_flag -= (
                                                int(flag_change_val) & change_flag
                                            )
                                        cost_result_tmp = {}
                                        cost_result_tmp["x"] = 0
                                        cost_result_tmp["y"] = 0
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["user"] = int(mine_or_other)
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["change_flag"] = change_flag
                                        cost_result["flag"]["grave"].append(
                                            cost_result_tmp
                                        )
                                    self.cost_result = cost_result
                    if place == "hand":
                        if mine_or_other2 == "1":
                            tmp = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == "2":
                            tmp = self.hands[deck_id]["otherhand"]
                        else:
                            tmp = self.hands[deck_id]["commonhand"]
                        user_hands = tmp
                        for index in range(len(user_hands)):
                            if place_unique_id == user_hands[index]["place_unique_id"]:
                                if cost == 0:
                                    if not self.check_not_effected(
                                        user_hands[index],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        tmp2 = {}
                                        tmp2["det"] = user_hands[index]
                                        tmp2["mine_or_other"] = mine_or_other
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hands[index][
                                            "place_unique_id"
                                        ]
                                        if monster_condition != "":
                                            if not self.validate_answer(
                                                tmp2, monster_condition, "", duel
                                            ):
                                                continue
                                        monsters.append(tmp2)
                                        if change_val_eternal is None:
                                            return_change_val.append(0)
                                        if flag_change_how != "0":
                                            if "flag" not in user_hands[index]:
                                                user_hands[index]["flag"] = 0
                                            if flag_change_how == "1":
                                                user_hands[index]["flag"] += int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "2":
                                                user_hands[index]["flag"] -= int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "3":
                                                user_hands[index]["flag"] = int(
                                                    flag_change_val
                                                )
                                            elif flag_change_how == "4":
                                                user_hands[index]["flag"] = (
                                                    int(flag_change_val)
                                                    | user_hands[index]["flag"]
                                                )
                                            elif flag_change_how == "5":
                                                user_hands[index]["flag"] -= (
                                                    (int(flag_change_val))
                                                    & user_hands[index]["flag"]
                                                )
                                        if change_val_eternal is not None:
                                            for index2 in range(
                                                len(change_val_eternal["variables"])
                                            ):
                                                variable_name = monster_effect[
                                                    "monster_variable_change_name"
                                                ][index2]
                                                if "minus" in monster_effect:
                                                    minus = monster_effect["minus"][index2]
                                                else:
                                                    minus = False
                                                change_val_tmp = str(
                                                    self.calculate_boland(
                                                        monster_effect[
                                                            "monster_variable_change_val"
                                                        ][index2],
                                                        tmp2,
                                                        minus,
                                                        1,
                                                    )
                                                )
                                                change_val_eternal["variables"][
                                                    variable_name
                                                ]["value"] = change_val_tmp
                                                change_val_eternal["variables"][variable_name][
                                                    "effect_kind"
                                                ] = monster_effect[
                                                    "monster_variable_change_effect_kind"
                                                ][0]
                                                if index2 == 0:
                                                    return_change_val.append(change_val_tmp)
                                            if "eternal" not in user_hands[index]:
                                                user_hands[index]["eternal"] = []
                                            user_hands[index]["eternal"].append(
                                                change_val_eternal
                                            )
                                            tmp2 = {}
                                            tmp2["det"] = user_hands[index]
                                            tmp2["mine_or_other"] = mine_or_other
                                            tmp2["user"] = chain_user
                                            tmp2["place"] = "hand"
                                            tmp2["deck_id"] = deck_id
                                            tmp2["x"] = 0
                                            tmp2["y"] = 0
                                            tmp2["place_unique_id"] = user_hands[index][
                                                "place_unique_id"
                                            ]
                                            self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                                          effect_kind,
                                                                          chain_user, 1, variable_name)
                                    if mine_or_other2 == "1":
                                        self.hands[deck_id]["myhand"] = user_hands
                                    elif mine_or_other2 == "2":
                                        self.hands[deck_id]["otherhand"] = user_hands
                                    else:
                                        self.hands[deck_id]["commonhand"] = user_hands
                                else:
                                    if self.check_not_effected(
                                        user_hands[index],
                                        chain_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other,
                                        cost,
                                    ):
                                        continue
                                    tmp2 = {}
                                    tmp2["det"] = user_hands[index]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "hand"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_hands[index][
                                        "place_unique_id"
                                    ]
                                    if monster_condition != "":
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    monsters.append(tmp2)
                                    if change_val_eternal is None:
                                        return_change_val.append(0)
                                    cost_result = self.cost_result
                                    if "variable" not in cost_result:
                                        cost_result["variable"] = {}
                                    if "hand" not in cost_result["variable"]:
                                        cost_result["variable"]["hand"] = []
                                    if "flag" not in cost_result:
                                        cost_result["flag"] = {}
                                    if "hand" not in cost_result["flag"]:
                                        cost_result["flag"]["hand"] = []
                                    cost_result_tmp = {}
                                    if change_val_eternal is not None:
                                        for index2 in range(
                                            len(change_val_eternal["variables"])
                                        ):
                                            variable_name = monster_effect[
                                                "monster_variable_change_name"
                                            ][index2]
                                            if "minus" in monster_effect:
                                                minus = monster_effect["minus"][index2]
                                            else:
                                                minus = False
                                            change_val_tmp = str(
                                                self.calculate_boland(
                                                    monster_effect[
                                                        "monster_variable_change_val"
                                                    ][index2],
                                                    tmp2,
                                                    minus,
                                                    1,
                                                )
                                            )
                                            change_val_eternal["variables"][
                                                variable_name
                                            ]["value"] = change_val_tmp
                                            change_val_eternal["variables"][variable_name][
                                                "effect_kind"
                                            ] = monster_effect[
                                                "monster_variable_change_effect_kind"
                                            ][0]
                                            if index2 == 0:
                                                return_change_val.append(change_val_tmp)
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result["variable"]["hand"].append(
                                        cost_result_tmp
                                    )
                                    if flag_change_how != "0":
                                        if "flag" not in user_hands[index]:
                                            change_flag = 0
                                        else:
                                            change_flag = user_hands[index]["flag"]
                                        if flag_change_how == "1":
                                            change_flag += int(flag_change_val)
                                        elif flag_change_how == "2":
                                            change_flag -= int(flag_change_val)
                                        elif flag_change_how == "3":
                                            change_flag = int(flag_change_val)
                                        elif flag_change_how == "4":
                                            change_flag = (
                                                int(flag_change_val) | change_flag
                                            )
                                        elif flag_change_how == "5":
                                            change_flag -= (
                                                int(flag_change_val) & change_flag
                                            )
                                        cost_result_tmp = {}
                                        cost_result_tmp["x"] = 0
                                        cost_result_tmp["y"] = 0
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["user"] = int(mine_or_other)
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["change_flag"] = change_flag
                                        cost_result["flag"]["hand"].append(
                                            cost_result_tmp
                                        )
                                    self.cost_result = cost_result

        field = self.field
        for monster_effect_det2 in monster_effect_monster:
            if "min_equation_number" not in monster_effect_det2:
                continue
            min_equation_number = int(
                self.calculate_boland(monster_effect_det2["min_equation_number"])
            )
            monster_effect_det = monster_effect_det2["monster"]
            field_tmp = []
            for place in monster_effect_det["place"]:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    effect_user = chain_user
                    #if tmp_deck is None:
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user != 1
                    ):
                        mine_or_other = 1
                    elif (place_tmp[2] == "1" and effect_user != 1) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other = 2
                    else:
                        mine_or_other = 3
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user != self.user) or (
                        place_tmp[2] == "2" and effect_user == self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if mine_or_other2 == 1:
                        tmp_deck = self.get_deck_with_effect(
                            self.decks[deck_id]["mydeck"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "deck",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                        org_deck = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp_deck = self.get_deck_with_effect(
                            self.decks[deck_id]["otherdeck"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "deck",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                        org_deck = self.decks[deck_id]["otherdeck"]
                    else:
                        tmp_deck = self.get_deck_with_effect(
                            self.decks[deck_id]["commondeck"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "deck",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                        org_deck = self.decks[deck_id]["commondeck"]
                    user_decks = org_deck
                    if not tmp_deck:
                        return
                    if "move_how" not in monster_effect:
                        for index3 in range(tmp_deck):
                            if not self.check_not_effected(
                                user_decks[index3],
                                chain_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                tmp2 = {}
                                tmp2["det"] = user_decks[index3]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_decks[index3][
                                    "place_unique_id"
                                ]
                                place_unique_id = user_decks[index3][
                                    "place_unique_id"
                                ]

                                monsters.append(tmp2)
                                if change_val_eternal is None:
                                    return_change_val.append(0)
                                if flag_change_how != "0":
                                    if "flag" not in user_decks[index3]:
                                        user_decks[index3]["flag"] = 0
                                    if flag_change_how == "1":
                                        user_decks[index3]["flag"] += int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "2":
                                        user_decks[index3]["flag"] -= int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "3":
                                        user_decks[index3]["flag"] = int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "4":
                                        user_decks[index3]["flag"] = (
                                            int(flag_change_val)
                                            | user_decks[index3]["flag"]
                                        )
                                    elif flag_change_how == "5":
                                        user_decks[index3]["flag"] -= (
                                            (int(flag_change_val))
                                            & user_decks[index3]["flag"]
                                        )
                                    if cost == 1:
                                        cost_result = self.cost_result
                                        if "variable" not in cost_result:
                                            cost_result["variable"] = {}
                                        if "deck" not in cost_result["variable"]:
                                            cost_result["variable"]["deck"] = []
                                        if "flag" not in cost_result:
                                            cost_result["flag"] = {}
                                        if "deck" not in cost_result["flag"]:
                                            cost_result["flag"]["deck"] = []
                                        cost_result_tmp = {}
                                        if change_val_eternal is not None:
                                            for index2 in range(
                                                    len(change_val_eternal["variables"])
                                            ):
                                                variable_name = monster_effect[
                                                    "monster_variable_change_name"
                                                ][index2]
                                                if "minus" in monster_effect:
                                                    minus = monster_effect["minus"][index2]
                                                else:
                                                    minus = False
                                                change_val_tmp = str(
                                                    self.calculate_boland(
                                                        monster_effect[
                                                            "monster_variable_change_val"
                                                        ][index2],
                                                        tmp2,
                                                        minus,
                                                        1,
                                                    )
                                                )
                                                change_val_eternal["variables"][
                                                    variable_name
                                                ]["value"] = change_val_tmp
                                                change_val_eternal["variables"][variable_name][
                                                    "effect_kind"
                                                ] = monster_effect[
                                                    "monster_variable_change_effect_kind"
                                                ][0]
                                                if index2 == 0:
                                                    return_change_val.append(change_val_tmp)
                                        cost_result_tmp[
                                            "change_variable"
                                        ] = change_val_eternal
                                        cost_result_tmp["place_unique_id"] = place_unique_id
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["user"] = int(mine_or_other)
                                        cost_result["variable"]["deck"].append(
                                            cost_result_tmp
                                        )
                                        if flag_change_how != "0":
                                            if "flag" not in user_decks[index]:
                                                change_flag = 0
                                            else:
                                                change_flag = user_decks[index]["flag"]
                                            if flag_change_how == "1":
                                                change_flag += int(flag_change_val)
                                            elif flag_change_how == "2":
                                                change_flag -= int(flag_change_val)
                                            elif flag_change_how == "3":
                                                change_flag = int(flag_change_val)
                                            elif flag_change_how == "4":
                                                change_flag = (
                                                        int(flag_change_val) | change_flag
                                                )
                                            elif flag_change_how == "5":
                                                change_flag -= (
                                                        int(flag_change_val) & change_flag
                                                )
                                            cost_result_tmp = {}
                                            cost_result_tmp["x"] = 0
                                            cost_result_tmp["y"] = 0
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result_tmp["user"] = int(mine_or_other)
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = place_unique_id
                                            cost_result_tmp["change_flag"] = change_flag
                                            cost_result["flag"]["deck"].append(
                                                cost_result_tmp
                                            )
                                        self.cost_result = cost_result
                                        continue
                                if change_val_eternal is not None:
                                    for index2 in range(
                                        len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                    if "eternal" not in user_decks[index3]:
                                        user_decks[index3]["eternal"] = []
                                    user_decks[index3]["eternal"].append(
                                        change_val_eternal
                                    )
                                    tmp2 = {}
                                    tmp2["det"] = user_decks[index3]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "deck"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_decks[index3][
                                        "place_unique_id"
                                    ]
                                    self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                              effect_kind,
                                                              chain_user, 1, variable_name)
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "1" and effect_user != self.user) or (
                                place_tmp[2] == "2" and effect_user == self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.decks[deck_id]["mydeck"] = user_decks
                            elif mine_or_other2 == 2:
                                self.decks[deck_id]["otherdeck"] = user_decks
                            else:
                                self.decks[deck_id]["commondeck"] = user_decks
                        continue
                    elif monster_effect["move_how"] == 0:
                        range_det = tmp_deck
                    elif monster_effect["move_how"] == 1:
                        reversed_tmp = list(reversed(tmp_deck))
                        range_det = reversed_tmp
                    else:
                        range_det = tmp_deck
                        random.shuffle(range_det)
                    counter = 0
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_decks[range_i],
                            chain_user,
                            effect_kind,
                            "deck",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            tmp2 = {}
                            tmp2["det"] = user_decks[range_i]
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = chain_user
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_decks[range_i][
                                "place_unique_id"
                            ]
                            place_unique_id = user_decks[range_i][
                                "place_unique_id"
                            ]
                            if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                            ):
                                continue
                            counter+=1
                            if counter > min_equation_number:
                                break
                            monsters.append(tmp2)
                            if change_val_eternal is None:
                                return_change_val.append(0)
                            if flag_change_how != "0":
                                if "flag" not in user_decks[range_i]:
                                    user_decks[range_i]["flag"] = 0
                                if flag_change_how == "1":
                                    user_decks[range_i]["flag"] += int(flag_change_val)
                                elif flag_change_how == "2":
                                    user_decks[range_i]["flag"] -= int(flag_change_val)
                                elif flag_change_how == "3":
                                    user_decks[range_i]["flag"] = int(flag_change_val)
                                elif flag_change_how == "4":
                                    user_decks[range_i]["flag"] = (
                                        int(flag_change_val)
                                        | user_decks[range_i]["flag"]
                                    )
                                elif flag_change_how == "5":
                                    user_decks[range_i]["flag"] -= (
                                        (int(flag_change_val))
                                        & user_decks[range_i]["flag"]
                                    )
                            if change_val_eternal is not None:
                                if cost == 0:
                                    for index2 in range(
                                        len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_eternal["variables"][variable_name][
                                            "value"
                                        ] = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                    if "eternal" not in user_decks[range_i]:
                                        user_decks[range_i]["eternal"] = []
                                    user_decks[range_i]["eternal"].append(
                                        change_val_eternal
                                    )
                                    tmp2 = {}
                                    tmp2["det"] = user_decks[range_i]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "deck"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_decks[range_i][
                                        "place_unique_id"
                                    ]
                                    self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                                  effect_kind,
                                                                  chain_user, 1, variable_name)
                            if cost == 1:
                                cost_result = self.cost_result
                                if "variable" not in cost_result:
                                    cost_result["variable"] = {}
                                if "deck" not in cost_result["variable"]:
                                    cost_result["variable"]["deck"] = []
                                if "flag" not in cost_result:
                                    cost_result["flag"] = {}
                                if "deck" not in cost_result["flag"]:
                                    cost_result["flag"]["deck"] = []
                                cost_result_tmp = {}
                                if change_val_eternal is not None:
                                    for index2 in range(
                                            len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                cost_result_tmp[
                                    "change_variable"
                                ] = change_val_eternal
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["deck_id"] = deck_id
                                cost_result_tmp["user"] = int(mine_or_other)
                                cost_result["variable"]["deck"].append(
                                    cost_result_tmp
                                )
                                if flag_change_how != "0":
                                    if "flag" not in user_decks[range_i]:
                                        change_flag = 0
                                    else:
                                        change_flag = user_decks[range_i]["flag"]
                                    if flag_change_how == "1":
                                        change_flag += int(flag_change_val)
                                    elif flag_change_how == "2":
                                        change_flag -= int(flag_change_val)
                                    elif flag_change_how == "3":
                                        change_flag = int(flag_change_val)
                                    elif flag_change_how == "4":
                                        change_flag = (
                                                int(flag_change_val) | change_flag
                                        )
                                    elif flag_change_how == "5":
                                        change_flag -= (
                                                int(flag_change_val) & change_flag
                                        )
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = 0
                                    cost_result_tmp["y"] = 0
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result_tmp[
                                        "place_unique_id"
                                    ] = place_unique_id
                                    cost_result_tmp["change_flag"] = change_flag
                                    cost_result["flag"]["deck"].append(
                                        cost_result_tmp
                                    )
                                self.cost_result = cost_result
                                continue

                    if cost == 0:
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        else:
                            self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    effect_user = chain_user
                    #if tmp_deck is None:
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user != 1
                    ):
                        mine_or_other = 1
                    elif (place_tmp[2] == "1" and effect_user != 1) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other = 2
                    else:
                        mine_or_other = 3
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "2" and effect_user == self.user) or (
                        place_tmp[2] == "1" and effect_user != self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if mine_or_other2 == 1:
                        tmp_deck = self.get_grave_with_effect(
                            self.graves[deck_id]["mygrave"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "grave",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                        org_grave = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp_deck = self.get_grave_with_effect(
                            self.graves[deck_id]["othergrave"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "grave",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                        org_grave = self.graves[deck_id]["othergrave"]
                    else:
                        tmp_deck = self.get_grave_with_effect(
                            self.graves[deck_id]["commongrave"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "grave",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                        org_grave = self.graves[deck_id]["commongrave"]
                    user_graves = org_grave
                    if not user_graves:
                        return None
                    if "move_how" not in monster_effect:
                        for index3 in range(len(user_graves)):
                            if not self.check_not_effected(
                                user_graves[index3],
                                chain_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                tmp2 = {}
                                tmp2["det"] = user_graves[index3]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_graves[index3][
                                    "place_unique_id"
                                ]
                                if monster_condition != "":
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                monsters.append(tmp2)
                                if change_val_eternal is None:
                                    return_change_val.append(0)
                                if flag_change_how != "0":
                                    if "flag" not in user_graves[index3]:
                                        user_graves[index3]["flag"] = 0
                                    if flag_change_how == "1":
                                        user_graves[index3]["flag"] += int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "2":
                                        user_graves[index3]["flag"] -= int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "3":
                                        user_graves[index3]["flag"] = int(
                                            flag_change_val
                                        )
                                    elif flag_change_how == "4":
                                        user_graves[index3]["flag"] = (
                                            int(flag_change_val)
                                            | user_graves[index3]["flag"]
                                        )
                                    elif flag_change_how == "5":
                                        user_graves[index3]["flag"] -= (
                                            (int(flag_change_val))
                                            & user_graves[index3]["flag"]
                                        )
                                if change_val_eternal is not None:
                                    for index2 in range(
                                        len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                    if "eternal" not in user_graves[index3]:
                                        user_graves[index3]["eternal"] = []
                                    user_graves[index3]["eternal"].append(
                                        change_val_eternal
                                    )
                                    tmp2 = {}
                                    tmp2["det"] = user_graves[index3]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "grave"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_graves[index3][
                                        "place_unique_id"
                                    ]
                                    self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                                      effect_kind,
                                                                      chain_user, 1, variable_name)
                                if cost == 1:
                                    cost_result = self.cost_result
                                    if "variable" not in cost_result:
                                        cost_result["variable"] = {}
                                    if "grave" not in cost_result["variable"]:
                                        cost_result["variable"]["grave"] = []
                                    if "flag" not in cost_result:
                                        cost_result["flag"] = {}
                                    if "grave" not in cost_result["flag"]:
                                        cost_result["flag"]["grave"] = []
                                    cost_result_tmp = {}
                                    if change_val_eternal is not None:
                                        for index2 in range(
                                                len(change_val_eternal["variables"])
                                        ):
                                            variable_name = monster_effect[
                                                "monster_variable_change_name"
                                            ][index2]
                                            if "minus" in monster_effect:
                                                minus = monster_effect["minus"][index2]
                                            else:
                                                minus = False
                                            change_val_tmp = str(
                                                self.calculate_boland(
                                                    monster_effect[
                                                        "monster_variable_change_val"
                                                    ][index2],
                                                    tmp2,
                                                    minus,
                                                    1,
                                                )
                                            )
                                            change_val_eternal["variables"][
                                                variable_name
                                            ]["value"] = change_val_tmp
                                            change_val_eternal["variables"][variable_name][
                                                "effect_kind"
                                            ] = monster_effect[
                                                "monster_variable_change_effect_kind"
                                            ][0]
                                            if index2 == 0:
                                                return_change_val.append(change_val_tmp)
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result["variable"]["grave"].append(
                                        cost_result_tmp
                                    )
                                    if flag_change_how != "0":
                                        if "flag" not in user_graves[index3]:
                                            change_flag = 0
                                        else:
                                            change_flag = user_graves[index3]["flag"]
                                        if flag_change_how == "1":
                                            change_flag += int(flag_change_val)
                                        elif flag_change_how == "2":
                                            change_flag -= int(flag_change_val)
                                        elif flag_change_how == "3":
                                            change_flag = int(flag_change_val)
                                        elif flag_change_how == "4":
                                            change_flag = (
                                                    int(flag_change_val) | change_flag
                                            )
                                        elif flag_change_how == "5":
                                            change_flag -= (
                                                    int(flag_change_val) & change_flag
                                            )
                                        cost_result_tmp = {}
                                        cost_result_tmp["x"] = 0
                                        cost_result_tmp["y"] = 0
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["user"] = int(mine_or_other)
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["change_flag"] = change_flag
                                        cost_result["flag"]["grave"].append(
                                            cost_result_tmp
                                        )
                                    self.cost_result = cost_result
                                    continue
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "2" and effect_user == self.user) or (
                                place_tmp[2] == "1" and effect_user != self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                            continue
                    elif monster_effect["move_how"] == 0:
                        range_det = tmp_deck
                    elif monster_effect["move_how"] == 1:
                        reversed_tmp = list(reversed(tmp_deck))
                        range_det = reversed_tmp
                    else:
                        range_det = tmp_deck
                        random.shuffle(range_det)
                    counter = 0
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_graves[range_i],
                            chain_user,
                            effect_kind,
                            "grave",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            # log表示用
                            tmp2 = {}
                            tmp2["det"] = user_graves[range_i]
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = chain_user
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_graves[range_i][
                                "place_unique_id"
                            ]
                            place_unique_id = user_graves[range_i][
                                "place_unique_id"
                            ]
                            if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                            ):
                                continue
                            counter+=1
                            if counter > min_equation_number:
                                break
                            monsters.append(tmp2)
                            if change_val_eternal is None:
                                return_change_val.append(0)
                            if "flag" not in user_graves[range_i]:
                                user_graves[range_i]["flag"] = 0
                            if flag_change_how == "1":
                                user_graves[range_i]["flag"] += int(flag_change_val)
                            elif flag_change_how == "2":
                                user_graves[range_i]["flag"] -= int(flag_change_val)
                            elif flag_change_how == "3":
                                user_graves[range_i]["flag"] = int(flag_change_val)
                            elif flag_change_how == "4":
                                user_graves[range_i]["flag"] = (
                                    int(flag_change_val) | user_graves[range_i]["flag"]
                                )
                            elif flag_change_how == "5":
                                user_graves[range_i]["flag"] -= (
                                    (int(flag_change_val))
                                    & user_graves[range_i]["flag"]
                                )
                            if change_val_eternal is not None:
                                for index2 in range(
                                    len(change_val_eternal["variables"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if "minus" in monster_effect:
                                        minus = monster_effect["minus"][index2]
                                    else:
                                        minus = False
                                    change_val_tmp = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index2],
                                            tmp2,
                                            minus,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][
                                        variable_name
                                    ]["value"] = change_val_tmp
                                    change_val_eternal["variables"][variable_name][
                                        "effect_kind"
                                    ] =  monster_effect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    if index2 == 0:
                                        return_change_val.append(change_val_tmp)
                                if "eternal" not in user_graves[range_i]:
                                    user_graves[range_i]["eternal"] = []
                                user_graves[range_i]["eternal"].append(
                                    change_val_eternal
                                )
                                tmp2 = {}
                                tmp2["det"] = user_graves[range_i]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_graves[range_i][
                                    "place_unique_id"
                                ]
                                self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                                  effect_kind,
                                                                  chain_user, 1, variable_name)
                            if cost == 1:
                                cost_result = self.cost_result
                                if "variable" not in cost_result:
                                    cost_result["variable"] = {}
                                if "grave" not in cost_result["variable"]:
                                    cost_result["variable"]["grave"] = []
                                if "flag" not in cost_result:
                                    cost_result["flag"] = {}
                                if "grave" not in cost_result["flag"]:
                                    cost_result["flag"]["grave"] = []
                                cost_result_tmp = {}
                                if change_val_eternal is not None:
                                    for index2 in range(
                                            len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                cost_result_tmp[
                                    "change_variable"
                                ] = change_val_eternal
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["deck_id"] = deck_id
                                cost_result_tmp["user"] = int(mine_or_other)
                                cost_result["variable"]["grave"].append(
                                    cost_result_tmp
                                )
                                if flag_change_how != "0":
                                    if "flag" not in user_graves[range_i]:
                                        change_flag = 0
                                    else:
                                        change_flag = user_graves[range_i]["flag"]
                                    if flag_change_how == "1":
                                        change_flag += int(flag_change_val)
                                    elif flag_change_how == "2":
                                        change_flag -= int(flag_change_val)
                                    elif flag_change_how == "3":
                                        change_flag = int(flag_change_val)
                                    elif flag_change_how == "4":
                                        change_flag = (
                                                int(flag_change_val) | change_flag
                                        )
                                    elif flag_change_how == "5":
                                        change_flag -= (
                                                int(flag_change_val) & change_flag
                                        )
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = 0
                                    cost_result_tmp["y"] = 0
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result_tmp[
                                        "place_unique_id"
                                    ] = place_unique_id
                                    cost_result_tmp["change_flag"] = change_flag
                                    cost_result["flag"]["grave"].append(
                                        cost_result_tmp
                                    )
                                self.cost_result = cost_result
                                continue
                        if cost == 0:
                            if (place_tmp[2] == "1" and effect_user == self.user) or (
                                place_tmp[2] == "2" and effect_user != self.user
                            ):
                                mine_or_other2 = 1
                            elif (place_tmp[2] == "2" and effect_user == self.user) or (
                                place_tmp[2] == "1" and effect_user != self.user
                            ):
                                mine_or_other2 = 2
                            else:
                                mine_or_other2 = 3
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves
                            else:
                                self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    effect_user = chain_user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user != 1
                    ):
                        mine_or_other = 1
                    elif (place_tmp[2] == "1" and effect_user != 1) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other = 2
                    else:
                        mine_or_other = 3
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "2" and effect_user == self.user) or (
                        place_tmp[2] == "1" and effect_user != self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if mine_or_other2 == 1:
                        tmp_deck = self.get_hand_with_effect(
                            self.hands[deck_id]["myhand"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                    elif mine_or_other2 == 2:
                        tmp_deck = self.get_hand_with_effect(
                            self.hands[deck_id]["otherhand"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                    else:
                        tmp_deck = self.get_hand_with_effect(
                            self.hands[deck_id]["commonhand"],
                            monster_effect_det2,
                            effect_kind,
                            exclude,
                            effect_user,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        )
                    user_hands = tmp_deck
                    if not user_hands:
                        return None
                    if "move_how" not in monster_effect:
                        for index3 in range(len(user_hands)):
                            if not self.check_not_effected(
                                user_hands[index3],
                                chain_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                cost,
                            ):
                                # log表示用
                                tmp2 = {}
                                tmp2["det"] = user_hands[index3]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_hands[index3][
                                    "place_unique_id"
                                ]
                                if monster_condition != "":
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                monsters.append(tmp2)
                                if change_val_eternal is None:
                                    return_change_val.append(0)
                                if "flag" not in user_hands[index3]:
                                    user_hands[index3]["flag"] = 0
                                if flag_change_how == "1":
                                    user_hands[index3]["flag"] += int(flag_change_val)
                                elif flag_change_how == "2":
                                    user_hands[index3]["flag"] -= int(flag_change_val)
                                elif flag_change_how == "3":
                                    user_hands[index3]["flag"] = int(flag_change_val)
                                elif flag_change_how == "4":
                                    user_hands[index3]["flag"] = (
                                        int(flag_change_val)
                                        | user_hands[index3]["flag"]
                                    )
                                elif flag_change_how == "5":
                                    user_hands[index3]["flag"] -= (
                                        (int(flag_change_val))
                                        & user_hands[index3]["flag"]
                                    )
                                if change_val_eternal is not None:
                                    for index2 in range(
                                        len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                minus,
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                if cost == 1:
                                    cost_result = self.cost_result
                                    if "variable" not in cost_result:
                                        cost_result["variable"] = {}
                                    if "hand" not in cost_result["variable"]:
                                        cost_result["variable"]["hand"] = []
                                    if "flag" not in cost_result:
                                        cost_result["flag"] = {}
                                    if "hand" not in cost_result["flag"]:
                                        cost_result["flag"]["hand"] = []
                                    cost_result_tmp = {}
                                    if change_val_eternal is not None:
                                        for index2 in range(
                                                len(change_val_eternal["variables"])
                                        ):
                                            variable_name = monster_effect[
                                                "monster_variable_change_name"
                                            ][index2]
                                            if "minus" in monster_effect:
                                                minus = monster_effect["minus"][index2]
                                            else:
                                                minus = False
                                            change_val_tmp = str(
                                                self.calculate_boland(
                                                    monster_effect[
                                                        "monster_variable_change_val"
                                                    ][index2],
                                                    tmp2,
                                                    minus,
                                                    1,
                                                )
                                            )
                                            change_val_eternal["variables"][
                                                variable_name
                                            ]["value"] = change_val_tmp
                                            change_val_eternal["variables"][variable_name][
                                                "effect_kind"
                                            ] = monster_effect[
                                                "monster_variable_change_effect_kind"
                                            ][0]
                                            if index2 == 0:
                                                return_change_val.append(change_val_tmp)
                                    cost_result_tmp[
                                        "change_variable"
                                    ] = change_val_eternal
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result["variable"]["hand"].append(
                                        cost_result_tmp
                                    )
                                    if flag_change_how != "0":
                                        if "flag" not in user_hands[index3]:
                                            change_flag = 0
                                        else:
                                            change_flag = user_hands[index3]["flag"]
                                        if flag_change_how == "1":
                                            change_flag += int(flag_change_val)
                                        elif flag_change_how == "2":
                                            change_flag -= int(flag_change_val)
                                        elif flag_change_how == "3":
                                            change_flag = int(flag_change_val)
                                        elif flag_change_how == "4":
                                            change_flag = (
                                                    int(flag_change_val) | change_flag
                                            )
                                        elif flag_change_how == "5":
                                            change_flag -= (
                                                    int(flag_change_val) & change_flag
                                            )
                                        cost_result_tmp = {}
                                        cost_result_tmp["x"] = 0
                                        cost_result_tmp["y"] = 0
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result_tmp["user"] = int(mine_or_other)
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["change_flag"] = change_flag
                                        cost_result["flag"]["hand"].append(
                                            cost_result_tmp
                                        )
                                    self.cost_result = cost_result
                                    continue
                                else:
                                    if "eternal" not in user_hands[index3]:
                                        user_hands[index3]["eternal"] = []
                                    user_hands[index3]["eternal"].append(
                                        change_val_eternal
                                    )
                                    tmp2 = {}
                                    tmp2["det"] = user_hands[index3]
                                    tmp2["mine_or_other"] = mine_or_other
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "hand"
                                    tmp2["deck_id"] = deck_id
                                    tmp2["x"] = 0
                                    tmp2["y"] = 0
                                    tmp2["place_unique_id"] = user_hands[index3][
                                        "place_unique_id"
                                    ]
                                    self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                              effect_kind,
                                                              chain_user, 1, variable_name)
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "2" and effect_user == self.user) or (
                            place_tmp[2] == "1" and effect_user != self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        else:
                            self.hands[deck_id]["commonhand"] = user_hands
                        continue
                    elif monster_effect["move_how"] == 0:
                        range_det = tmp_deck
                    elif monster_effect["move_how"] == 1:
                        reversed_tmp = list(reversed(tmp_deck))
                        range_det = reversed_tmp
                    else:
                        range_det = tmp_deck
                        random.shuffle(range_det)
                    counter = 0
                    for range_i in range_det:
                        if not self.check_not_effected(
                            user_hands[range_i],
                            chain_user,
                            effect_kind,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other,
                            cost,
                        ):
                            # log表示用
                            tmp2 = {}
                            tmp2["det"] = user_hands[range_i]
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = chain_user
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_hands[range_i][
                                "place_unique_id"
                            ]
                            place_unique_id = user_hands[range_i][
                                "place_unique_id"
                            ]
                            if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                            ):
                                continue
                            counter+=1
                            if counter > min_equation_number:
                                break
                            monsters.append(tmp2)
                            if "flag" not in user_hands[range_i]:
                                user_hands[range_i]["flag"] = 0
                            if flag_change_how == "1":
                                user_hands[range_i]["flag"] += int(flag_change_val)
                            elif flag_change_how == "2":
                                user_hands[range_i]["flag"] -= int(flag_change_val)
                            elif flag_change_how == "3":
                                user_hands[range_i]["flag"] = int(flag_change_val)
                            elif flag_change_how == "4":
                                user_hands[range_i]["flag"] = (
                                    int(flag_change_val) | user_hands[range_i]["flag"]
                                )
                            elif flag_change_how == "5":
                                user_hands[range_i]["flag"] -= (
                                    (int(flag_change_val))
                                    & user_hands[range_i]["flag"]
                                )
                            if change_val_eternal is not None:
                                for index2 in range(
                                    len(change_val_eternal["variables"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    if "minus" in monster_effect:
                                        minus = monster_effect["minus"][index2]
                                    else:
                                        minus = False
                                    change_val_tmp = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index2],
                                            tmp2,
                                            minus,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][
                                        variable_name
                                    ]["value"] = change_val_tmp
                                    change_val_eternal["variables"][variable_name][
                                        "effect_kind"
                                    ] =  monster_effect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    if index2 == 0:
                                        return_change_val.append(change_val_tmp)
                                if "eternal" not in user_hands[range_i]:
                                    user_hands[range_i]["eternal"] = []
                                user_hands[range_i]["eternal"].append(
                                    change_val_eternal
                                )
                                tmp2 = {}
                                tmp2["det"] = user_hands[range_i]
                                tmp2["mine_or_other"] = mine_or_other
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = user_hands[range_i][
                                    "place_unique_id"
                                ]
                                self.raise_trigger_monster_change_val(tmp2, change_val_tmp, "effect",
                                                                  effect_kind,
                                                                      chain_user, 1, variable_name)
                            if cost == 1:
                                cost_result = self.cost_result
                                if "variable" not in cost_result:
                                    cost_result["variable"] = {}
                                if "hand" not in cost_result["variable"]:
                                    cost_result["variable"]["hand"] = []
                                if "flag" not in cost_result:
                                    cost_result["flag"] = {}
                                if "hand" not in cost_result["flag"]:
                                    cost_result["flag"]["hand"] = []
                                cost_result_tmp = {}
                                if change_val_eternal is not None:
                                    for index2 in range(
                                            len(change_val_eternal["variables"])
                                    ):
                                        variable_name = monster_effect[
                                            "monster_variable_change_name"
                                        ][index2]
                                        if "minus" in monster_effect:
                                            minus = monster_effect["minus"][index2]
                                        else:
                                            minus = False
                                        change_val_tmp = str(
                                            self.calculate_boland(
                                                monster_effect[
                                                    "monster_variable_change_val"
                                                ][index2],
                                                tmp2,
                                                monster_effect["minus"][index2],
                                                1,
                                            )
                                        )
                                        change_val_eternal["variables"][
                                            variable_name
                                        ]["value"] = change_val_tmp
                                        change_val_eternal["variables"][variable_name][
                                            "effect_kind"
                                        ] = monster_effect[
                                            "monster_variable_change_effect_kind"
                                        ][0]
                                        if index2 == 0:
                                            return_change_val.append(change_val_tmp)
                                cost_result_tmp[
                                    "change_variable"
                                ] = change_val_eternal
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["deck_id"] = deck_id
                                cost_result_tmp["user"] = int(mine_or_other)
                                cost_result["variable"]["hand"].append(
                                    cost_result_tmp
                                )
                                if flag_change_how != "0":
                                    if "flag" not in user_hands[range_i]:
                                        change_flag = 0
                                    else:
                                        change_flag = user_hands[range_i]["flag"]
                                    if flag_change_how == "1":
                                        change_flag += int(flag_change_val)
                                    elif flag_change_how == "2":
                                        change_flag -= int(flag_change_val)
                                    elif flag_change_how == "3":
                                        change_flag = int(flag_change_val)
                                    elif flag_change_how == "4":
                                        change_flag = (
                                                int(flag_change_val) | change_flag
                                        )
                                    elif flag_change_how == "5":
                                        change_flag -= (
                                                int(flag_change_val) & change_flag
                                        )
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = 0
                                    cost_result_tmp["y"] = 0
                                    cost_result_tmp["deck_id"] = deck_id
                                    cost_result_tmp["user"] = int(mine_or_other)
                                    cost_result_tmp[
                                        "place_unique_id"
                                    ] = place_unique_id
                                    cost_result_tmp["change_flag"] = change_flag
                                    cost_result["flag"]["hand"].append(
                                        cost_result_tmp
                                    )
                                self.cost_result = cost_result
                                continue
                            if cost == 0:
                                if (
                                    place_tmp[2] == "1" and effect_user == self.user
                                ) or (place_tmp[2] == "2" and effect_user != self.user):
                                    mine_or_other2 = 1
                                elif (
                                    place_tmp[2] == "2" and effect_user == self.user
                                ) or (place_tmp[2] == "1" and effect_user != self.user):
                                    mine_or_other2 = 2
                                else:
                                    mine_or_other2 = 3
                                if mine_or_other2 == 1:
                                    self.hands[deck_id]["myhand"] = user_hands
                                elif mine_or_other2 == 2:
                                    self.hands[deck_id]["otherhand"] = user_hands
                                else:
                                    self.hands[deck_id]["commonhand"] = user_hands
                elif place_tmp[0] == "field":
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    effect_user = chain_user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            tmp2 = {}
                            tmp2["det"] = field[x][y]["det"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            for index2 in range(
                                len(change_val_eternal["variables"])
                            ):
                                if "minus" in monster_effect:
                                    minus = monster_effect["minus"][index2]
                                else:
                                    minus = False
                                variable_name = monster_effect[
                                    "monster_variable_change_name"
                                ][index2]
                                change_val_tmp = str(
                                    self.calculate_boland(
                                        monster_effect[
                                            "monster_variable_change_val"
                                        ][index2],
                                        tmp2,
                                        minus,
                                        1,
                                    )
                                )
                                change_val_eternal["variables"][
                                    variable_name
                                ]["value"] = change_val_tmp
                                change_val_eternal["variables"][variable_name][
                                    "effect_kind"
                                ] =  monster_effect[
                                    "monster_variable_change_effect_kind"
                                ][0]
                                if index2 == 0:
                                    return_change_val.append(change_val_tmp)
                            change_val_tmp = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index2],
                                            tmp2,
                                            minus,
                                            1,
                                        )
                                    )
                            if self.check_not_effected(
                                field[x][y]["det"],
                                chain_user,
                                effect_kind,
                                "field",
                                0,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                cost,
                                change_val_tmp
                            ):
                                continue
                            place_unique_id = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.validate_answer(
                                tmp2, monster_effect_det, exclude, duel
                            ):
                                for index2 in range(
                                    len(change_val_eternal["variables"])
                                ):
                                    variable_name = monster_effect[
                                        "monster_variable_change_name"
                                    ][index2]
                                    change_val_tmp = str(
                                        self.calculate_boland(
                                            monster_effect[
                                                "monster_variable_change_val"
                                            ][index2],
                                            tmp2,
                                            minus,
                                            1,
                                        )
                                    )
                                    change_val_eternal["variables"][
                                        variable_name
                                    ]["value"] = change_val_tmp
                                    change_val_eternal["variables"][variable_name][
                                        "effect_kind"
                                    ] =  monster_effect[
                                        "monster_variable_change_effect_kind"
                                    ][0]
                                    if index2 == 0:
                                        return_change_val.append(change_val_tmp)
                                monsters.append(tmp2)
                                if change_val_eternal is not None:
                                    if cost == 0:
                                        if "eternal" not in field[x][y]["det"]:
                                            field[x][y]["det"]["eternal"] = []
                                        self.raise_trigger_monster_change_val( tmp2, change_val_tmp, "effect", effect_kind, chain_user, 1 ,variable_name)
                                        field[x][y]["det"]["eternal"].append(
                                            change_val_eternal
                                        )
                                    else:
                                        cost_result = self.cost_result
                                        if "variable" not in cost_result:
                                            cost_result["variable"] = {}

                                        if "field" not in cost_result["variable"]:
                                            cost_result["variable"]["field"] = []
                                        if change_val_eternal is not None:
                                            for index2 in range(
                                                    len(change_val_eternal["variables"])
                                            ):
                                                variable_name = monster_effect[
                                                    "monster_variable_change_name"
                                                ][index2]
                                                if "minus" in monster_effect:
                                                    minus = monster_effect["minus"][index2]
                                                else:
                                                    minus = False
                                                change_val_eternal["variables"][variable_name][
                                                    "value"
                                                ] = str(
                                                    self.calculate_boland(
                                                        monster_effect[
                                                            "monster_variable_change_val"
                                                        ][index2],
                                                        tmp2,
                                                        minus,
                                                        1,
                                                    )
                                                )
                                            cost_result_tmp = {}
                                            cost_result_tmp["x"] = x
                                            cost_result_tmp["y"] = y
                                            cost_result_tmp["place_unique_id"] = place_unique_id
                                            cost_result_tmp["change_variable"] = change_val_eternal
                                            cost_result["variable"]["field"].append(cost_result_tmp)
                                        if flag_change_how != "0":
                                            if "flag" not in field[x][y]["det"]:
                                                change_flag = 0
                                            else:
                                                change_flag = field[x][y]["det"]["flag"]
                                            if flag_change_how == "1":
                                                change_flag += int(flag_change_val)
                                            elif flag_change_how == "2":
                                                change_flag -= int(flag_change_val)
                                            elif flag_change_how == "3":
                                                change_flag = int(flag_change_val)
                                            elif flag_change_how == "4":
                                                change_flag = int(flag_change_val) | change_flag
                                            elif flag_change_how == "5":
                                                change_flag -= int(flag_change_val) & change_flag
                                            cost_result_tmp = {}
                                            cost_result_tmp["x"] = x
                                            cost_result_tmp["y"] = y
                                            cost_result_tmp["place_unique_id"] = place_unique_id
                                            cost_result_tmp["change_flag"] = change_flag
                                            if "flag" not in cost_result:
                                                cost_result["flag"] = {}
                                            if "field" not in cost_result["flag"]:
                                                cost_result["flag"]["field"] = []
                                            cost_result["flag"]["field"].append(cost_result_tmp)
                                        self.cost_result = cost_result

        self.field = field
        data = []
        data.append(monsters)
        data.append(return_change_val)
        duel.global_variable = json.dumps(variable)
        return data

    def change_monster_variable_cost(self, cost_text, effect_kind, cost_condition):
        self.change_monster_variable(cost_text, effect_kind, cost_condition, 1)

    def end_cost_shuffle(self, cost_user):
        if self.cost_result == "":
            return
        cost = self.cost_result
        if "clear" not in cost:
            return
        for cost_det in cost:
            for place in cost_det["place"].values():
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] == "deck":
                    if (place_tmp[2] == "1" and cost_user == self.user) or (
                        place_tmp[2] == "2" and cost_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "2" and cost_user == self.user) or (
                        place_tmp[2] == "1" and cost_user != self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        tmp = self.decks[deck_id]["commondeck"]
                    user_decks = tmp
                    np.random.shuffle(user_decks)
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif mine_or_other2 == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
                if place_tmp[0] == "grave":
                    if (place_tmp[2] == "1" and cost_user == self.user) or (
                        place_tmp[2] == "2" and cost_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "2" and cost_user == self.user) or (
                        place_tmp[2] == "1" and cost_user != self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    np.random.shuffle(user_graves)
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
                if place_tmp[0] == "hand":
                    if (place_tmp[2] == "1" and cost_user == self.user) or (
                        place_tmp[2] == "2" and cost_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "2" and cost_user == self.user) or (
                        place_tmp[2] == "1" and cost_user != self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    np.random.shuffle(user_hands)
                    if place_tmp[2] == "1":
                        self.hands[deck_id]["myhand"] = user_hands
                    elif place_tmp[2] == "2":
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif place_tmp[2] == "3":
                        self.hands[deck_id]["commonhand"] = user_hands
        return

    def end_cost_clear_relation(self, cost_user):
        if self.cost_result == "":
            return
        cost = self.cost_result
        if "clear_relation" not in cost:
            return
        for relation in cost["clear_relation"]:
            relation_name = relation["relation_name"]
            relation_kind = relation["relation_kind"]
            relation_to = relation["relation_to"]
            if relation_to == "1":
                relation_from = "0"
            else:
                relation_from = "1"
            place = relation["place"]
            if place == "field":
                field = self.field
                x = relation["x"]
                y = relation["y"]
                for i in range(field[x][y]["det"]["rel"][relation_kind]):
                    if (
                        field[x][y]["det"]["rel"][relation_kind][i]["name"]
                        == relation_name
                        and field[x][y]["det"]["rel"][relation_kind][i]["to"]
                        == relation_to
                    ):
                        self.delete_relation(
                            field[x][y]["det"]["rel"][relation_kind]["monster"],
                            relation_name,
                            relation_kind,
                            relation_from,
                        )
                        del field[x][y]["det"]["rel"][relation_kind][i]
                self.field = field
            else:
                deck_id = relation["deck_id"]
                mine_or_other = relation["mine_or_other"]
                order = relation["order"]
                if self.user == 1:
                    mine_or_other2 = mine_or_other
                elif self.user == 2:
                    if mine_or_other == 1:
                        mine_or_other2 = 2
                    elif mine_or_other == 2:
                        mine_or_other2 = 1
                    else:
                        mine_or_other2 = mine_or_other
                if place == "deck":
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        tmp = self.decks[deck_id]["commondeck"]
                    user_decks = tmp
                    user_deck = user_decks[order]
                    if "rel" in user_deck and relation_kind in user_deck["rel"]:
                        for j in range(len(user_deck["rel"][relation_kind])):
                            if (
                                user_deck["rel"][relation_kind][j]["name"]
                                == relation_name
                                and user_deck["rel"][relation_kind][j]["to"]
                                == relation_to
                            ):
                                self.delete_relation(
                                    user_deck["rel"][relation_kind]["monster"],
                                    relation_name,
                                    relation_kind,
                                    relation_from,
                                )
                                del user_deck["rel"][relation_kind][j]
                    user_decks[order] = user_deck
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif mine_or_other2 == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
                elif place == "grave":
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    user_grave = user_graves[order]
                    if "rel" in user_grave and relation_kind in user_grave["rel"]:
                        for j in range(len(user_grave["rel"][relation_kind])):
                            if (
                                user_grave["rel"][relation_kind][j]["name"]
                                == relation_name
                                and user_grave["rel"][relation_kind][j]["to"]
                                == relation_to
                            ):
                                self.delete_relation(
                                    user_grave["rel"][relation_kind]["monster"],
                                    relation_name,
                                    relation_kind,
                                    relation_from,
                                )
                                del user_grave["rel"][relation_kind][j]
                    user_graves[order] = user_grave
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
                elif place == "hand":
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    user_hand = user_hands[order]
                    if "rel" in user_hand and relation_kind in user_hand["rel"]:
                        for j in range(len(user_hand["rel"][relation_kind])):
                            if (
                                user_hand["rel"][relation_kind][j]["name"]
                                == relation_name
                                and user_hand["rel"][relation_kind][j]["to"]
                                == relation_to
                            ):
                                self.delete_relation(
                                    user_hand["rel"][relation_kind]["monster"],
                                    relation_name,
                                    relation_kind,
                                    relation_from,
                                )
                                del user_hand["rel"][relation_kind][j]
                    user_hands[order] = user_hand
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif mine_or_other2 == 3:
                        self.hands[deck_id]["commonhand"] = user_hands

    def end_cost_clear(self, cost_user):
        if self.cost_result == "":
            return
        cost = self.cost_result
        if "clear" not in cost:
            return
        for cost_det in cost:
            for place in cost_det["place"].values():
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if (place_tmp[2] == "1" and cost_user == self.user) or (
                    place_tmp[2] == "2" and cost_user != self.user
                ):
                    mine_or_other2 = 1
                elif (place_tmp[2] == "2" and cost_user == self.user) or (
                    place_tmp[2] == "1" and cost_user != self.user
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3
                if place_tmp[0] == "deck":
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        tmp = self.decks[deck_id]["commondeck"]
                    user_decks = tmp
                    result_user_decks = []
                    for user_deck in user_decks:
                        user_deck["flag"] = 0
                        result_user_decks.append(user_deck)
                    if place_tmp[2] == "1":
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif place_tmp[2] == "2":
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif place_tmp[2] == "3":
                        self.decks[deck_id]["commondeck"] = user_decks
                if place_tmp[0] == "grave":
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    result_user_graves = []
                    for user_grave in user_graves:
                        user_grave["flag"] = 0
                        result_user_graves.append(user_grave)
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
                if place_tmp[0] == "hand":
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    result_user_hands = []
                    for user_hand in user_hands:
                        user_hand["flag"] = 0
                        result_user_hands.append(user_hand)
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif mine_or_other2 == 3:
                        self.hands[deck_id]["commonhand"] = user_hands
                elif place_tmp[0] == "field":
                    if (place_tmp[2] == "1" and cost_user == 1) or (
                        place_tmp[2] == "2" and cost_user == 2
                    ):
                        mine_or_other = 1
                    elif (place_tmp[2] == "2" and cost_user == 1) or (
                        place_tmp[2] == "1" and cost_user == 2
                    ):
                        mine_or_other = 2
                    else:
                        mine_or_other = 3
                    field = self.field
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            mine_or_other_field = field[0][y]["mine_or_other"]
                            if (
                                kind.find(str(deck_id)) > -1
                                and mine_or_other == mine_or_other_field
                            ):
                                if field[x][y]["det"] is not None:
                                    field[x][y]["det"]["flag"] = 0
                    self.field = field
        return

    def delete_relation(self, monster, relation_name, relation_kind, relation_to):
        place = monster["place"]
        if place == "field":
            field = self.field
            x = monster["x"]
            y = monster["y"]
            for i in reversed(range(len(field[x][y]["det"]["rel"][relation_kind]))):
                if (
                    field[x][y]["det"]["rel"][relation_kind][i]["name"] == relation_name
                    and int(field[x][y]["det"]["rel"][relation_kind][i]["to"]) == int(relation_to)
                ):
                    del field[x][y]["det"]["rel"][relation_kind][i]
            self.field = field
        else:
            deck_id = monster["deck_id"]
            mine_or_other = int(monster["mine_or_other"])
            place_unique_id = monster["det"]["place_unique_id"]
            if self.user == 1:
                mine_or_other2 = mine_or_other
            elif self.user == 2:
                if mine_or_other == 1:
                    mine_or_other2 = 2
                elif mine_or_other == 2:
                    mine_or_other2 = 1
                else:
                    mine_or_other2 = mine_or_other
            if place == "deck":
                if mine_or_other2 == 1:
                    tmp = self.decks[deck_id]["mydeck"]
                elif mine_or_other2 == 2:
                    tmp = self.decks[deck_id]["otherdeck"]
                elif mine_or_other2 == 3:
                    tmp = self.decks[deck_id]["commondeck"]
                user_decks = tmp
                for i in range(len(user_decks)):
                    if user_decks[i]["place_unique_id"] == place_unique_id:
                        if (
                            "rel" in user_decks[i]
                            and relation_kind in user_decks[i]["rel"]
                        ):
                            for j in range(len(user_decks[i]["rel"][relation_kind])):
                                if (
                                    user_decks[i]["rel"][relation_kind][j]["name"]
                                    == relation_name
                                    and user_decks[i]["rel"][relation_kind][j]["to"]
                                    == relation_to
                                ):
                                    del user_decks[i]["rel"][relation_kind][j]
                if mine_or_other2 == 1:
                    self.decks[deck_id]["mydeck"] = user_decks
                elif mine_or_other2 == 2:
                    self.decks[deck_id]["otherdeck"] = user_decks
                elif mine_or_other2 == 3:
                    self.decks[deck_id]["commondeck"] = user_decks
            elif place == "grave":
                if mine_or_other2 == 1:
                    tmp = self.graves[deck_id]["mygrave"]
                elif mine_or_other2 == 2:
                    tmp = self.graves[deck_id]["othergrave"]
                elif mine_or_other2 == 3:
                    tmp = self.graves[deck_id]["commongrave"]
                user_graves = tmp
                for i in range(len(user_graves)):
                    if user_graves[i]["place_unique_id"] == place_unique_id:
                        if (
                            "rel" in user_graves[i]
                            and relation_kind in user_graves[i]["rel"]
                        ):
                            for j in range(len(user_graves[i]["rel"][relation_kind])):
                                if (
                                    user_graves[i]["rel"][relation_kind][j]["name"]
                                    == relation_name
                                    and user_graves[i]["rel"][relation_kind][j]["to"]
                                    == relation_to
                                ):
                                    del user_graves[i]["rel"][relation_kind][j]
                if mine_or_other2 == 1:
                    self.graves[deck_id]["mygrave"] = user_graves
                elif mine_or_other2 == 2:
                    self.graves[deck_id]["othergrave"] = user_graves
                elif mine_or_other2 == 3:
                    self.graves[deck_id]["commongrave"] = user_graves
            elif place == "hand":
                if mine_or_other2 == 1:
                    tmp = self.hands[deck_id]["myhand"]
                elif mine_or_other2 == 2:
                    tmp = self.hands[deck_id]["otherhand"]
                elif mine_or_other2 == 3:
                    tmp = self.hands[deck_id]["commonhand"]
                user_hands = tmp
                for i in range(len(user_hands)):
                    if user_hands[i]["place_unique_id"] == place_unique_id:
                        if (
                            "rel" in user_hands[i]
                            and relation_kind in user_hands[i]["rel"]
                        ):
                            for j in range(len(user_hands[i]["rel"][relation_kind])):
                                if (
                                    user_hands[i]["rel"][relation_kind][j]["name"]
                                    == relation_name
                                    and user_hands[i]["rel"][relation_kind][j]["to"]
                                    == relation_to
                                ):
                                    del user_hands[i]["rel"][relation_kind][j]
                if mine_or_other2 == 1:
                    self.hands[deck_id]["myhand"] = user_hands
                elif mine_or_other2 == 2:
                    self.hands[deck_id]["otherhand"] = user_hands
                elif mine_or_other2 == 3:
                    self.hands[deck_id]["commonhand"] = user_hands

    def clear_relation_cost(self, effect, effect_kind, condition):
        self.clear_relation(effect, effect_kind, condition, 1)

    def clear_relation(self, effect, effect_kind, condition, cost=0):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        monster_effect_text = json.loads(effect)
        for monster_effect_det in monster_effect_text:
            relation = monster_effect_det["relation"]
            relation_name = relation["relation_name"]
            relation_kind = relation["relation_kind"]
            relation_to = relation["relation_to"]
            if relation_to == "1":
                relation_from = "0"
            else:
                relation_from = "1"
            for place in monster_effect_det["place"].values():
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if (place_tmp[2] == "1" and effect_user == self.user) or (
                    place_tmp[2] == "2" and effect_user != self.user
                ):
                    mine_or_other2 = 1
                elif (place_tmp[2] == "2" and effect_user == self.user) or (
                    place_tmp[2] == "1" and effect_user != self.user
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3
                if self.user == 1:
                    mine_or_other = mine_or_other2
                else:
                    if mine_or_other2 == 1:
                        mine_or_other = 2
                    elif mine_or_other2 == 2:
                        mine_or_other = 1
                    else:
                        mine_or_other = mine_or_other2
                if place_tmp[0] == "deck":
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        tmp = self.decks[deck_id]["commondeck"]
                    user_decks = tmp
                    result_user_decks = []
                    for user_deck in user_decks:
                        if "rel" in user_deck and relation_kind in user_deck["rel"]:
                            for i in range(len(user_deck["rel"][relation_kind])):
                                if (
                                    user_deck["rel"][relation_kind][i]["name"]
                                    == relation_name
                                    and user_deck["rel"][relation_kind][i]["to"]
                                    == relation_to
                                ):
                                    if cost == 1:
                                        cost_result = self.cost_result
                                        if "clear_relation" not in cost_result:
                                            cost_result["clear_relation"] = []
                                        tmp = {}
                                        tmp["place"] = "deck"
                                        tmp["deck_id"] = deck_id
                                        tmp["order"] = i
                                        tmp["mine_or_other"] = mine_or_other
                                        tmp["x"] = 0
                                        tmp["y"] = 0
                                        tmp["relation_to"] = relation_to
                                        tmp["relation_kind"] = relation_kind
                                        tmp["relation_name"] = relation_name
                                        cost_result["clear_relation"].append(tmp)
                                    else:
                                        self.delete_relation(
                                            user_deck["rel"][relation_kind]["monster"],
                                            relation_name,
                                            relation_kind,
                                            relation_from,
                                        )
                                        del user_deck["rel"][relation_kind][i]
                        result_user_decks.append(user_deck)
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif mine_or_other2 == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    result_user_graves = []
                    for user_grave in user_graves:
                        if "rel" in user_grave and relation_kind in user_grave["rel"]:
                            for i in range(len(user_grave["rel"][relation_kind])):
                                if (
                                    user_grave["rel"][relation_kind][i]["kind"]
                                    == relation_kind
                                    and user_grave["rel"][relation_kind][i]["to"]
                                    == relation_to
                                ):
                                    if cost == 1:
                                        cost_result = self.cost_result
                                        if "clear_relation" not in cost_result:
                                            cost_result["clear_relation"] = []
                                        tmp = {}
                                        tmp["place"] = "grave"
                                        tmp["deck_id"] = deck_id
                                        tmp["order"] = i
                                        tmp["mine_or_other"] = mine_or_other
                                        tmp["x"] = 0
                                        tmp["y"] = 0
                                        tmp["relation_to"] = relation_to
                                        tmp["relation_kind"] = relation_kind
                                        tmp["relation_name"] = relation_name
                                        cost_result["clear_relation"].append(tmp)
                                    else:
                                        self.delete_relation(
                                            user_grave["rel"][relation_kind]["monster"],
                                            relation_name,
                                            relation_kind,
                                            relation_from,
                                        )
                                        del user_grave["rel"][relation_kind][i]
                        result_user_graves.append(user_grave)
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    result_user_hands = []
                    for user_hand in user_hands:
                        if "rel" in user_hand and relation_kind in user_hand["rel"]:
                            for i in range(len(user_hand["rel"][relation_kind])):
                                if (
                                    user_hand["rel"][relation_kind][i]["name"]
                                    == relation_name
                                    and user_hand["rel"][relation_kind][i]["to"]
                                    == relation_to
                                ):
                                    if cost == 1:
                                        cost_result = self.cost_result
                                        if "clear_relation" not in cost_result:
                                            cost_result["clear_relation"] = []
                                        tmp = {}
                                        tmp["place"] = "hand"
                                        tmp["deck_id"] = deck_id
                                        tmp["order"] = i
                                        tmp["mine_or_other"] = mine_or_other
                                        tmp["x"] = 0
                                        tmp["y"] = 0
                                        tmp["relation_to"] = relation_to
                                        tmp["relation_kind"] = relation_kind
                                        tmp["relation_name"] = relation_name
                                        cost_result["clear_relation"].append(tmp)
                                    else:
                                        self.delete_relation(
                                            user_hand["rel"][relation_kind]["monster"],
                                            relation_name,
                                            relation_kind,
                                            relation_from,
                                        )
                                        del user_hand["rel"][relation_kind][i]
                        result_user_hands.append(user_hand)
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif mine_or_other2 == 3:
                        self.hands[deck_id]["commonhand"] = user_hands
                elif place_tmp[0] == "field":
                    field = self.field
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            mine_or_other_field = field[x][y]["mine_or_other"]
                            if (
                                kind.find(str(deck_id)) > -1
                                and mine_or_other_field == mine_or_other
                            ):
                                if field[x][y]["det"] is not None:
                                    if (
                                        "rel" in field[x][y]["det"]
                                        and relation_kind in field[x][y]["det"]["rel"]
                                    ):
                                        for i in reversed(
                                            range(
                                                len(
                                                    field[x][y]["det"]["rel"][
                                                        relation_kind
                                                    ]
                                                )
                                            )
                                        ):
                                            if (
                                                field[x][y]["det"]["rel"][
                                                    relation_kind
                                                ][i]["name"]
                                                == relation_name
                                                and int(field[x][y]["det"]["rel"][
                                                    relation_kind
                                                ][i]["to"])
                                                == int(relation_to)
                                            ):
                                                if cost == 1:
                                                    cost_result = self.cost_result
                                                    if (
                                                        "clear_relation"
                                                        not in cost_result
                                                    ):
                                                        cost_result[
                                                            "clear_relation"
                                                        ] = []
                                                    tmp = {}
                                                    tmp["place"] = "field"
                                                    tmp["deck_id"] = 0
                                                    tmp["order"] = 0
                                                    tmp["mine_or_other"] = field[x][y][
                                                        "mine_or_other"
                                                    ]
                                                    tmp["x"] = x
                                                    tmp["y"] = y
                                                    tmp["relation_to"] = relation_to
                                                    tmp["relation_kind"] = relation_kind
                                                    tmp["relation_name"] = relation_name
                                                    cost_result[
                                                        "clear_relation"
                                                    ].append(tmp)
                                                else:
                                                    self.delete_relation(
                                                        field[x][y]["det"]["rel"][
                                                            relation_kind
                                                        ][i]["monster"],
                                                        relation_name,
                                                        relation_kind,
                                                        relation_from,
                                                    )
                                                    del field[x][y]["det"]["rel"][
                                                        relation_kind
                                                    ][i]
                    field = self.field
        return

    def clear(self):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        chain_det = json.loads(self.duel.chain_det)
        monster_effect_wrapper = MonsterEffectWrapper.objects.get(
            id=int(chain_det[str(duel.chain - 1)])
        )
        monster_effect = monster_effect_wrapper.monster_effect
        monster_effect_text = json.loads(monster_effect.monster_effect)
        for monster_effect_det in monster_effect_text:
            for place in monster_effect_det["place"].values():
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if (place_tmp[2] == "1" and effect_user == self.user) or (
                    place_tmp[2] == "2" and effect_user != self.user
                ):
                    mine_or_other2 = 1
                elif (place_tmp[2] == "2" and effect_user == self.user) or (
                    place_tmp[2] == "1" and effect_user != self.user
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3
                # mine_or_otherは絶対値 mine_or_other2は相対値
                if self.user == 1:
                    mine_or_other = mine_or_other2
                else:
                    if mine_or_other2 == 1:
                        mine_or_other = 2
                    elif mine_or_other2 == 2:
                        mine_or_other = 1
                    else:
                        mine_or_other = mine_or_other2
                if place_tmp[0] == "deck":
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        tmp = self.decks[deck_id]["commondeck"]
                    user_decks = tmp
                    result_user_decks = []
                    for user_deck in user_decks:
                        user_deck["flag"] = 0
                        result_user_decks.append(user_deck)
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif mine_or_other2 == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    result_user_graves = []
                    for user_grave in user_graves:
                        user_grave["flag"] = 0
                        result_user_graves.append(user_grave)
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    result_user_hands = []
                    for user_hand in user_hands:
                        user_hand["flag"] = 0
                        result_user_hands.append(user_hand)
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif mine_or_other2 == 3:
                        self.hands[deck_id]["commonhand"] = user_hands
                elif place_tmp[0] == "field":
                    field = self.field
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            mine_or_other_field = field[x][y]["mine_or_other"]
                            if (
                                kind.find(str(deck_id)) > -1
                                and mine_or_other_field == mine_or_other
                            ):
                                if field[x][y]["det"] is not None:
                                    field[x][y]["det"]["flag"] = 0
                    field = self.field
        return

    def shuffle(self):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        chain_det = json.loads(self.duel.chain_det)
        monster_effect_wrapper = MonsterEffectWrapper.objects.get(
            id=int(chain_det[str(duel.chain - 1)])
        )
        monster_effect = monster_effect_wrapper.monster_effect
        monster_effect_text = json.loads(monster_effect.monster_effect)
        for monster_effect_det in monster_effect_text:
            for place in monster_effect_det["place"].values():
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if (place_tmp[2] == "1" and effect_user == self.user) or (
                    place_tmp[2] == "2" and effect_user != self.user
                ):
                    mine_or_other2 = 1
                elif (place_tmp[2] == "2" and effect_user == self.user) or (
                    place_tmp[2] == "1" and effect_user != self.user
                ):
                    mine_or_other2 = 2
                else:
                    mine_or_other2 = 3
                if place_tmp[0] == "deck":
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        tmp = self.decks[deck_id]["commondeck"]
                    user_decks = tmp
                    np.random.shuffle(user_decks)
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = user_decks
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = user_decks
                    elif mine_or_other2 == 3:
                        self.decks[deck_id]["commondeck"] = user_decks
                elif place_tmp[0] == "grave":
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    np.random.shuffle(user_graves)
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = user_graves
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = user_graves
                    elif mine_or_other2 == 3:
                        self.graves[deck_id]["commongrave"] = user_graves
                elif place_tmp[0] == "hand":
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    np.random.shuffle(user_hands)
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = user_hands
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = user_hands
                    elif mine_or_other2 == 3:
                        self.hands[deck_id]["commonhand"] = user_hands
        return

    def clear_cost(self):
        cost_det = duel.cost_det
        cost_wrapper = CostWrapper.objects.get(id=cost_det)
        cost = cost_wrapper.cost
        cost_text = json.loads(cost.cost)
        for cost_det in cost_text:
            for place in cost_det["place"].values():
                cost_result = self.cost_result
                if "clear" not in cost_result:
                    cost_result["clear"] = []

                    cost_result_tmp = {}
                    cost_result_tmp["place"] = place
                    cost_result["clear"].append(cost_result_tmp)
                    self.cost_result = cost_result
        return

    def shuffle_cost(self):
        duel = self.duel
        cost_det = duel.cost_det
        cost_wrapper = CostWrapper.objects.get(id=cost_det)
        cost = cost_wrapper.cost
        cost_text = json.loads(cost.cost)
        for cost_det in cost_text:
            for place in cost_det["place"].values():
                cost_result = self.cost_result
                if "shuffle" not in cost_result:
                    cost_result["shuffle"] = []

                    cost_result_tmp = {}
                    cost_result_tmp["place"] = place
                    cost_result["shuffle"].append(cost_result_tmp)
                    self.cost_result = cost_result
        return

    def move_from_monster_simple_eternal(
        self, monster_effect_kind, user, monster_effect
    ):
        return self.move_from_monster_simple(
            monster_effect_kind, 2, user, monster_effect
        )

    def move_from_monster_simple_cost(self, monster_effect_kind):
        return self.move_from_monster_simple(monster_effect_kind, 1)

    def move_from_monster_simple(
        self, effect_kind, cost=0, user=None, monster_effect=None
    ):
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            effect_user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_text = json.loads(monster_effect.monster_effect)
            monster_effect_text_monster = monster_effect_text["monster"]
        elif cost == 2:
            effect_user = user
            monster_effect_text = json.loads(
                monster_effect.monster_effect.monster_effect
            )
            monster_effect_text_monster = monster_effect_text["monster"]
        else:
            effect_user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost = cost_wrapper.cost
            monster_effect_text = json.loads(cost.cost)
            monster_effect_text_monster = monster_effect_text["monster"]
        return_value = []
        exclude = monster_effect_text["exclude"]

        user_decks2 = None
        user_graves2 = None
        user_hands2 = None
        for monster_effect_det in monster_effect_text_monster:
            if (
                "as_monster_condition" in monster_effect_det
                and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monster_effects = monster_effect_det["as_monster_condition"]
                as_monster_effects = as_monster_effects.split(",")
                for as_monster_effect in as_monster_effects:
                    tmp = self.mess
                    cost_tmp = self.cost
                    timing_tmp = self.timing_mess
                    if str(duel.chain - 1) not in tmp:
                        tmp[str(duel.chain - 1)] = {}
                    if as_monster_effect[0] == "~":
                        if duel.in_cost is True:
                            if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                                continue
                            else:
                                place1 = cost_tmp[str(self.tmp_chain)][
                                    as_monster_effect
                                ]
                        else:
                            if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                                continue
                            else:
                                place1 = cost_tmp[str(duel.chain - 1)][
                                    as_monster_effect
                                ]
                    elif as_monster_effect[0] == "%":
                        if as_monster_effect not in timing_tmp:
                            continue
                        else:
                            place1 = timing_tmp[as_monster_effect]
                    elif as_monster_effect not in tmp[str(duel.chain - 1)]:
                        continue
                    else:
                        place1 = tmp[str(duel.chain - 1)][as_monster_effect]
                    for place2 in place1:
                        place = place2["place"]
                        if place == "field":
                            x = int(place2["x"])
                            y = int(place2["y"])
                            field = self.field
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if cost == 0:
                                    if self.config.sort is True:
                                        x = self.search_place_unique_id(y,place_unique_id)
                                        if x == -1:
                                            continue
                                    if (
                                        field[x][y]["det"]["place_unique_id"]
                                        != place_unique_id
                                    ):
                                        continue
                                    if self.check_not_effected(
                                        field[x][y]["det"],
                                        effect_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                    ):
                                        continue
                                    field[x][y]["det"]["kind"] = effect_kind
                                    field[x][y]["det"]["user"] = int(
                                        field[x][y]["mine_or_other"]
                                    )
                                    field[x][y]["det"]["user_det"] = effect_user
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "field"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = copy.deepcopy(
                                        field[x][y]["det"]
                                    )
                                    return_tmp["det"] = self.copy_monster_from_field(
                                        field[x][y]["det"],
                                        field[x][y]["kind"],
                                        field[x][y]["mine_or_other"],
                                    )
                                    return_value.append(return_tmp)
                                    field[x][y]["det"] = None
                                    if self.config.sort is True:
                                        field = self.sortField(field,y)
                                    self.field = field
                                    continue
                                else:
                                    if self.check_not_effected(
                                        field[x][y]["det"],
                                        effect_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                    ):
                                        continue
                                    cost_result = self.cost_result
                                    if "remove" not in cost_result:
                                        cost_result["remove"] = {}

                                    if "field" not in cost_result["remove"]:
                                        cost_result["remove"]["field"] = []
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = field[x][y][
                                        "det"
                                    ]["place_unique_id"]

                                    cost_result["remove"]["field"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    continue

                        mine_or_other2 = int(place2["mine_or_other"])
                        mine_or_other3 = mine_or_other2
                        if self.user == 2:
                            if mine_or_other2 == 1:
                                mine_or_other2 = 2
                            elif mine_or_other2 == 2:
                                mine_or_other2 = 1
                        deck_id = place2["deck_id"]
                        place_unique_id = place2["place_unique_id"]
                        if place == "deck":
                            if mine_or_other2 == 1:
                                deck = self.decks[deck_id]["mydeck"]
                            elif mine_or_other2 == 2:
                                deck = self.decks[deck_id]["otherdeck"]
                            elif mine_or_other2 == 3:
                                deck = self.decks[deck_id]["commondeck"]
                            user_decks = deck
                            for user_deck in user_decks:
                                if place_unique_id == user_deck["place_unique_id"]:
                                    if not self.check_not_effected(
                                        user_deck,
                                        effect_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        if cost == 0:
                                            user_decks.remove(user_deck)
                                            user_deck["kind"] = effect_kind
                                            user_deck["user"] = mine_or_other3
                                            user_deck["user_det"] = effect_user
                                            return_tmp = {}
                                            return_tmp["x"] = 0
                                            return_tmp["y"] = 0
                                            return_tmp["place"] = "deck"
                                            return_tmp["deck_id"] = deck_id
                                            return_tmp["mine_or_other"] = mine_or_other3
                                            return_tmp["org_det"] = copy.deepcopy(
                                                user_deck
                                            )
                                            return_tmp[
                                                "det"
                                            ] = self.copy_monster_from_deck(
                                                user_deck, deck_id, mine_or_other3
                                            )
                                            return_value.append(return_tmp)
                                            if mine_or_other2 == 1:
                                                self.decks[deck_id][
                                                    "mydeck"
                                                ] = user_decks
                                            elif mine_or_other2 == 2:
                                                self.decks[deck_id][
                                                    "otherdeck"
                                                ] = user_decks
                                            elif mine_or_other2 == 3:
                                                self.decks[deck_id][
                                                    "commondeck"
                                                ] = user_decks
                                        else:
                                            cost_result = self.cost_result
                                            if "remove" not in cost_result:
                                                cost_result["remove"] = {}
                                            if "deck" not in cost_result["remove"]:
                                                cost_result["remove"]["deck"] = []
                                                place_unique_id = user_deck[
                                                    "place_unique_id"
                                                ]
                                                cost_result_tmp = {}
                                                cost_result_tmp[
                                                    "place_unique_id"
                                                ] = place_unique_id
                                                cost_result_tmp["user"] = mine_or_other3
                                                cost_result_tmp["deck_id"] = deck_id
                                                cost_result["remove"]["deck"].append(
                                                    cost_result_tmp
                                                )
                                                self.cost_result = cost_result
                                                return_tmp = {}
                                                return_tmp["x"] = 0
                                                return_tmp["y"] = 0
                                                return_tmp["place"] = "deck"
                                                return_tmp["deck_id"] = deck_id
                                                return_tmp["org_det"] = copy.deepcopy(
                                                    user_deck
                                                )
                                                return_tmp[
                                                    "det"
                                                ] = self.copy_monster_from_deck(
                                                    user_deck, deck_id, mine_or_other3
                                                )
                                                return_value.append(return_tmp)
                        if place == "grave":
                            if mine_or_other2 == 1:
                                grave = self.graves[deck_id]["mygrave"]
                            elif mine_or_other2 == 2:
                                grave = self.graves[deck_id]["othergrave"]
                            elif mine_or_other2 == 3:
                                grave = self.graves[deck_id]["commongrave"]
                            user_graves = grave
                            for user_grave in user_graves:
                                if place_unique_id == user_grave["place_unique_id"]:
                                    if not self.check_not_effected(
                                        user_grave,
                                        effect_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        if cost == 0:
                                            user_graves.remove(user_grave)
                                            user_grave["kind"] = effect_kind
                                            user_grave["user"] = mine_or_other3
                                            user_grave["user_det"] = effect_user
                                            return_tmp = {}
                                            return_tmp["x"] = 0
                                            return_tmp["y"] = 0
                                            return_tmp["place"] = "grave"
                                            return_tmp["deck_id"] = deck_id
                                            return_tmp["mine_or_other"] = mine_or_other3
                                            return_tmp["org_det"] = copy.deepcopy(
                                                user_grave
                                            )
                                            return_tmp[
                                                "det"
                                            ] = self.copy_monster_from_grave(
                                                user_grave, deck_id, mine_or_other3
                                            )
                                            return_value.append(return_tmp)
                                            if mine_or_other2 == 1:
                                                self.graves[deck_id][
                                                    "mygrave"
                                                ] = user_graves
                                            elif mine_or_other2 == 2:
                                                self.graves[deck_id][
                                                    "othergrave"
                                                ] = user_graves
                                            elif mine_or_other2 == 3:
                                                self.graves[deck_id][
                                                    "commongrave"
                                                ] = user_graves
                                        else:
                                            cost_result = self.cost_result
                                            if "remove" not in cost_result:
                                                cost_result["remove"] = {}
                                            if "grave" not in cost_result["remove"]:
                                                cost_result["remove"]["grave"] = []
                                            place_unique_id = user_grave[
                                                "place_unique_id"
                                            ]
                                            cost_result_tmp = {}
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = place_unique_id
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp[
                                                "user_det"
                                            ] = self.duel.cost_user
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["remove"]["grave"].append(
                                                cost_result_tmp
                                            )
                                            self.cost_result = cost_result
                                            return_tmp = {}
                                            return_tmp["x"] = 0
                                            return_tmp["y"] = 0
                                            return_tmp["place"] = "grave"
                                            return_tmp["mine_or_other"] = mine_or_other3
                                            return_tmp["deck_id"] = deck_id
                                            return_tmp["org_det"] = copy.deepcopy(
                                                user_grave
                                            )
                                            return_tmp[
                                                "det"
                                            ] = self.copy_monster_from_grave(
                                                user_grave, deck_id, mine_or_other3
                                            )
                                            return_value.append(return_tmp)
                        if place == "hand":
                            if mine_or_other2 == 1:
                                hand = self.hands[deck_id]["myhand"]
                            elif mine_or_other2 == 2:
                                hand = self.hands[deck_id]["otherhand"]
                            elif mine_or_other2 == 3:
                                hand = self.hands[deck_id]["commonhand"]
                            user_hands = hand
                            for user_hand in user_hands:
                                if place_unique_id == user_hand["place_unique_id"]:
                                    if not self.check_not_effected(
                                        user_hand,
                                        effect_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        if cost == 0:
                                            user_hands.remove(user_hand)
                                            return_tmp = {}
                                            return_tmp["x"] = 0
                                            return_tmp["y"] = 0
                                            return_tmp["place"] = "hand"
                                            return_tmp["mine_or_other"] = mine_or_other3
                                            return_tmp["deck_id"] = deck_id
                                            return_tmp["org_det"] = copy.deepcopy(
                                                user_hand
                                            )
                                            return_tmp[
                                                "det"
                                            ] = self.copy_monster_from_hand(
                                                user_hand, deck_id, mine_or_other3
                                            )
                                            return_value.append(return_tmp)
                                            if mine_or_other2 == 1:
                                                self.hands[deck_id][
                                                    "myhand"
                                                ] = user_hands
                                            elif mine_or_other2 == 2:
                                                self.hands[deck_id][
                                                    "otherhand"
                                                ] = user_hands
                                            elif mine_or_other2 == 3:
                                                self.hands[deck_id][
                                                    "commonhand"
                                                ] = user_hands
                                        else:
                                            cost_result = self.cost_result
                                            if "remove" not in cost_result:
                                                cost_result["remove"] = {}
                                            if "hand" not in cost_result["remove"]:
                                                cost_result["remove"]["hand"] = []
                                            place_unique_id = user_hand[
                                                "place_unique_id"
                                            ]
                                            cost_result_tmp = {}
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = place_unique_id
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp[
                                                "user_det"
                                            ] = self.duel.cost_user
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["remove"]["hand"].append(
                                                cost_result_tmp
                                            )
                                            self.cost_result = cost_result
                                            return_tmp = {}
                                            return_tmp["x"] = 0
                                            return_tmp["y"] = 0
                                            return_tmp["place"] = "hand"
                                            return_tmp["deck_id"] = deck_id
                                            return_tmp["mine_or_other"] = mine_or_other3
                                            return_tmp["org_det"] = copy.deepcopy(
                                                user_hand
                                            )
                                            return_tmp[
                                                "det"
                                            ] = self.copy_monster_from_hand(
                                                user_hand, deck_id, mine_or_other3
                                            )
                                            return_value.append(return_tmp)

            place_array_tmp = []
            for place in monster_effect_det["monster"]["place"]:
                place_tmp = place["det"].split("_")
                if place["det"] == "":
                    continue
                if place["and_or"] != "" and place_tmp[0] == "field":
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    continue
                else:
                    place_array = place_array_tmp
                    place_array_tmp = []
                deck_id = int(place_tmp[1])
                tmp_deck = None
                for tmp_i in range(
                    int(
                        self.calculate_boland(
                            monster_effect_det["min_equation_number"], None, False
                        )
                    )
                ):
                    tmp_i2 = 0
                    if monster_effect_text["field_x"]:
                        field = self.field
                        for str_x in monster_effect_text["field_x"]:
                            x = int(str_x)
                            y = int(monster_effect_text["field_y"][tmp_i2])
                            if cost == 0:
                                if field[x][y]["det"] is not None:
                                    if not self.check_not_effected(
                                        field[x][y]["det"],
                                        effect_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                    ):
                                        det = field[x][y]["det"].copy()
                                        org_det = copy.deepcopy(det)
                                        field[x][y]["det"] = None
                                        det = self.copy_monster_from_field(
                                            det,
                                            field[x][y]["kind"],
                                            field[x][y]["mine_or_other"],
                                        )
                                        if self.config.sort is True:
                                            field = self.sortField(field,y)
                                        self.field = field
                                        det["kind"] = effect_kind
                                        det["user"] = int(field[x][y]["mine_or_other"])
                                        det["user_det"] = effect_user
                                else:
                                    field[x][y]["det"] = None
                                    if self.config.sort is True:
                                        field = self.sortField(field,y)
                                    self.field = field
                                    det = None
                                return_tmp = {}
                                return_tmp["x"] = x
                                return_tmp["y"] = y
                                return_tmp["mine_or_other"] = field[x][y][
                                    "mine_or_other"
                                ]
                                return_tmp["place"] = "field"
                                return_tmp["deck_id"] = 0
                                return_tmp["org_det"] = org_det
                                return_tmp["det"] = det
                                return_value.append(return_tmp)
                            else:
                                cost_result = self.cost_result
                                cost_result_tmp = {}
                                cost_result_tmp["x"] = x
                                cost_result_tmp["y"] = y
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result["remove"]["field"].append(cost_result_tmp)
                                self.cost_result = cost_result
                                det = self.copy_monster_from_field(
                                    det,
                                    field[x][y]["kind"],
                                    field[x][y]["mine_or_other"],
                                )
                                return_tmp = {}
                                return_tmp["x"] = x
                                return_tmp["y"] = y
                                return_tmp["mine_or_other"] = field[x][y][
                                    "mine_or_other"
                                ]
                                return_tmp["place"] = "field"
                                return_tmp["deck_id"] = 0
                                return_tmp["org_det"] = org_det
                                return_tmp["det"] = det
                                return_value.append(return_tmp)
                        continue
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user != self.user) or (
                        place_tmp[2] == "2" and effect_user == self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if self.user == 1:
                        mine_or_other3 = mine_or_other2
                    else:
                        if mine_or_other2 == 1:
                            mine_or_other3 = 2
                        elif mine_or_other2 == 2:
                            mine_or_other3 = 1
                        else:
                            mine_or_other3 = 3
                    if place_tmp[0] == "deck":
                        if user_decks2 is None:
                            if mine_or_other2 == 1:
                                deck = self.decks[deck_id]["mydeck"]
                            elif mine_or_other2 == 2:
                                deck = self.decks[deck_id]["otherdeck"]
                            elif mine_or_other2 == 3:
                                deck = self.decks[deck_id]["commondeck"]
                            user_decks2 = deck
                        if len(user_decks2) == 0:
                            return return_value
                        if cost == 0:
                            if monster_effect_text["move_how"] == 0:
                                org_user_deck = copy.deepcopy(user_decks2[0])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks2[0], deck_id, mine_or_other3
                               )
                                del user_decks2[0]
                            elif monster_effect_text["move_how"] == 1:
                                org_user_deck = copy.deepcopy(user_decks2[-1])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks2[-1], deck_id, mine_or_other3
                                )
                                user_decks2.pop()
                            else:
                                range_i = random.randrange(len(user_decks2))
                                org_user_deck = copy.deepcopy(user_decks2[range_i])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks2[range_i], deck_id, mine_or_other3
                                )
                                user_decks2.pop(range_i)
                            if mine_or_other2 == 1:
                                self.decks[deck_id]["mydeck"] = user_decks2
                            elif mine_or_other2 == 2:
                                self.decks[deck_id]["otherdeck"] = user_decks2
                            elif mine_or_other2 == 3:
                                self.decks[deck_id]["commondeck"] = user_decks2
                            user_deck["kind"] = effect_kind
                            user_deck["user"] = mine_or_other3
                            user_deck["user_det"] = effect_user
                            return_tmp = {}
                            return_tmp["x"] = 0
                            return_tmp["y"] = 0
                            return_tmp["place"] = "deck"
                            return_tmp["mine_or_other"] = mine_or_other3
                            return_tmp["deck_id"] = deck_id
                            return_tmp["org_det"] = org_user_deck
                            return_tmp["det"] = user_deck
                            return_value.append(return_tmp)
                        else:
                            cost_result = self.cost_result
                            if monster_effect_text["move_how"] == 0:
                                org_user_deck = copy.deepcopy(user_decks2[0])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks2[0], deck_id, mine_or_other3
                                )
                                del user_decks2[0]
                            elif monster_effect_text["move_how"] == 1:
                                org_user_deck = copy.deepcopy(user_decks2[-1])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks2[-1], deck_id, mine_or_other3
                                )
                                user_decks2.pop()
                            else:
                                range_i = random.randrange(len(user_decks2))
                                org_user_deck = copy.deepcopy(user_decks2[range_i])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks2[range_i], deck_id, mine_or_other3
                                )
                                user_decks2.pop(range_i)
                            if "remove" not in cost_result:
                                cost_result["remove"] = {}
                            if "deck" not in cost_result["remove"]:
                                cost_result["remove"]["deck"] = []
                            place_unique_id = user_deck["place_unique_id"]
                            cost_result_tmp = {}
                            cost_result_tmp["place_unique_id"] = place_unique_id
                            cost_result_tmp["user"] = mine_or_other3
                            cost_result_tmp["user_det"] = self.duel.cost_user
                            cost_result_tmp["deck_id"] = deck_id
                            cost_result["remove"]["deck"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            return_tmp = {}
                            return_tmp["x"] = 0
                            return_tmp["y"] = 0
                            return_tmp["place"] = "deck"
                            return_tmp["deck_id"] = deck_id
                            return_tmp["mine_or_other"] = mine_or_other3
                            return_tmp["org_det"] = org_user_deck
                            return_tmp["det"] = user_deck
                            return_value.append(return_tmp)
                    elif place_tmp[0] == "grave":
                        if user_graves2 is None:
                            if mine_or_other2 == 1:
                                tmp_deck = self.get_grave_with_effect(
                                    self.graves[deck_id]["mygrave"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                grave = self.graves[deck_id]["mygrave"]
                            elif mine_or_other2 == 2:
                                tmp_deck = self.get_grave_with_effect(
                                    self.graves[deck_id]["othergrave"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                grave = self.graves[deck_id]["othergrave"]
                            elif mine_or_other2 == 3:
                                tmp_deck = self.get_grave_with_effect(
                                    self.graves[deck_id]["commongrave"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                grave = self.graves[deck_id]["commongrave"]

                            user_graves2 = grave
                        if len(user_graves2) == 0:
                            return return_value
                        if cost == 0:
                            if monster_effect_text["move_how"] == 0:
                                org_user_grave = copy.deepcopy(user_graves2[0])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves2[0], deck_id, mine_or_other3
                                )
                                del user_graves2[0]
                            elif monster_effect_text["move_how"] == 1:
                                org_user_grave = copy.deepcopy(user_graves2[-1])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves2[-1], deck_id, mine_or_other3
                                )
                                user_graves2.pop()
                            else:
                                range_i = random.randrange(len(user_graves2))
                                org_user_grave = copy.deepcopy(user_graves2[range_i])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves2[range_i], deck_id, mine_or_other3
                                )
                                user_graves2.pop(range_i)
                            if mine_or_other2 == 1:
                                self.graves[deck_id]["mygrave"] = user_graves2
                            elif mine_or_other2 == 2:
                                self.graves[deck_id]["othergrave"] = user_graves2
                            elif mine_or_other2 == 3:
                                self.graves[deck_id]["commongrave"] = user_graves2
                            user_grave["kind"] = effect_kind
                            user_grave["user"] = mine_or_other3
                            user_grave["user_det"] = effect_user
                            return_tmp = {}
                            return_tmp["x"] = 0
                            return_tmp["y"] = 0
                            return_tmp["place"] = "grave"
                            return_tmp["deck_id"] = deck_id
                            return_tmp["org_det"] = org_user_grave
                            return_tmp["det"] = user_grave
                            return_tmp["mine_or_other"] = mine_or_other3
                            return_value.append(return_tmp)
                        else:
                            cost_result = self.cost_result
                            if monster_effect_text["move_how"] == 0:
                                org_user_grave = copy.deepcopy(user_graves2[0])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves2[0], deck_id, mine_or_other3
                                )
                                del user_graves2[0]
                            elif monster_effect_text["move_how"] == 1:
                                org_user_grave = copy.deepcopy(user_graves2[-1])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves2[-1], deck_id, mine_or_other3
                                )
                                user_graves2.pop()
                            else:
                                range_i = random.randrange(len(user_graves2))
                                org_user_grave = copy.deepcopy(user_graves2[range_i])
                                user_graves2.pop(range_i)
                            if "remove" not in cost_result:
                                cost_result["remove"] = {}
                            if "grave" not in cost_result["remove"]:
                                cost_result["remove"]["grave"] = []
                            place_unique_id = user_grave["place_unique_id"]
                            cost_result_tmp = {}
                            cost_result_tmp["place_unique_id"] = place_unique_id
                            cost_result_tmp["user"] = mine_or_other3
                            cost_result_tmp["user_det"] = self.duel.cost_user
                            cost_result_tmp["deck_id"] = deck_id
                            cost_result["remove"]["grave"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            return_tmp = {}
                            return_tmp["x"] = 0
                            return_tmp["y"] = 0
                            return_tmp["place"] = "grave"
                            return_tmp["deck_id"] = deck_id
                            return_tmp["org_det"] = org_user_grave
                            return_tmp["det"] = user_grave
                            return_tmp["mine_or_other"] = mine_or_other3
                            return_value.append(return_tmp)
                    elif place_tmp[0] == "hand":
                        if user_hands2 is None:
                            if mine_or_other2 == 1:
                                hand = self.hands[deck_id]["myhand"]
                            elif mine_or_other2 == 2:
                                hand = self.hands[deck_id]["otherhand"]
                            elif mine_or_other2 == 3:
                                hand = self.hands[deck_id]["commonhand"]
                            user_hands2 = hand
                        if len(user_hands2) == 0:
                            return return_value
                        if cost == 0:
                            if monster_effect_text["move_how"] == 0:
                                org_user_hand = copy.deepcopy(user_hands2[0])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands2[0], deck_id, mine_or_other3
                                )
                                del user_hands2[0]
                            elif monster_effect_text["move_how"] == 1:
                                org_user_hand = copy.deepcopy(user_hands2[-1])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands2[-1], deck_id, mine_or_other3
                                )
                                user_hands2.pop()
                            else:
                                range_i = random.randrange(len(user_hands2))
                                org_user_hand = copy.deepcopy(user_hands2[range_i])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands2[range_i], deck_id, mine_or_other3
                                )
                                user_hands2.pop(range_i)
                            if mine_or_other2 == 1:
                                self.hands[deck_id]["myhand"] = user_hands2
                            elif mine_or_other2 == 2:
                                self.hands[deck_id]["otherhand"] = user_hands2
                            elif mine_or_other2 == 3:
                                self.hands[deck_id]["commonhand"] = user_hands2
                            user_hand["kind"] = effect_kind
                            user_hand["user"] = mine_or_other3
                            user_hand["user_det"] = effect_user
                            return_tmp = {}
                            return_tmp["x"] = 0
                            return_tmp["y"] = 0
                            return_tmp["place"] = "hand"
                            return_tmp["deck_id"] = deck_id
                            return_tmp["org_det"] = org_user_hand
                            return_tmp["det"] = user_hand
                            return_tmp["mine_or_other"] = mine_or_other3
                            return_value.append(return_tmp)
                        else:
                            cost_result = self.cost_result
                            if monster_effect_text["move_how"] == 0:
                                org_user_hand = copy.deepcopy(user_hands2[0])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands2[0], deck_id, mine_or_other3
                                )
                                del user_hands2[0]
                            elif monster_effect_text["move_how"] == 1:
                                org_user_hand = copy.deepcopy(user_hands2[-1])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands2[-1], deck_id, mine_or_other3
                                )
                                user_hands2.pop(-1)
                                tmp_deck.pop()
                            else:
                                range_i = random.randrange(len(user_hands2))
                                org_user_hand = copy.deepcopy(user_hands2[range_i])

                                user_hand = self.copy_monster_from_hand(
                                    user_hands2[range_i], deck_id, mine_or_other3
                                )
                                user_hands2.pop(range_i)
                            if "remove" not in cost_result:
                                cost_result["remove"] = {}
                            if "hand" not in cost_result["remove"]:
                                cost_result["remove"]["hand"] = []
                            place_unique_id = user_hand["place_unique_id"]
                            cost_result_tmp = {}
                            cost_result_tmp["place_unique_id"] = place_unique_id
                            cost_result_tmp["user"] = mine_or_other3
                            cost_result_tmp["user_det"] = self.duel.cost_user
                            cost_result_tmp["deck_id"] = deck_id
                            cost_result["remove"]["hand"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            return_tmp = {}
                            return_tmp["x"] = 0
                            return_tmp["y"] = 0
                            return_tmp["place"] = "hand"
                            return_tmp["deck_id"] = deck_id
                            return_tmp["org_det"] = org_user_hand
                            return_tmp["det"] = user_hand
                            return_tmp["mine_or_other"] = mine_or_other3
                            return_value.append(return_tmp)
                    elif place_tmp[0] == "field":
                        field_size = FieldSize.objects.get(id=1)
                        field = self.field
                        flag_field_place = True
                        current_and_or = "and"
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for x in range(field_x):
                            for y in range(field_size.field_y):
                                for place_tmp2 in place_array:
                                    and_or = place_tmp2["and_or"]
                                    det = place_tmp2["det"]
                                    splitted_det = det.split("_")
                                    kind = splitted_det[1]
                                    if self.field_free is False:
                                        kind = field[x][y]["kind"]
                                    else:
                                        kind = field[0][y]["kind"]
                                    if kind != "":
                                        tmp = kind.split("_")
                                    else:
                                        tmp = []
                                    if current_and_or == "and":
                                        if kind in tmp:
                                            if flag_field_place is True:
                                                flag_field_place = True
                                        else:
                                            flag_field_place = False
                                    elif current_and_or == "or":
                                        if kind in tmp:
                                            flag_field_place = True
                                        else:
                                            if flag_field_place is False:
                                                flag_field_place = False
                                    mine_or_other = int(splitted_det[2])
                                    current_and_or = and_or
                                if flag_field_place is False:
                                    continue
                                if (
                                    mine_or_other == 1
                                    and user == 1
                                    or mine_or_other == 2
                                    and user == 2
                                ):
                                    mine_or_other = 1
                                elif (
                                    mine_or_other == 1
                                    and user == 2
                                    or mine_or_other == 2
                                    and user == 1
                                ):
                                    mine_or_other = 2
                                else:
                                    mine_or_other = 3
                                if field[x][y]["mine_or_other"] != mine_or_other:
                                    continue
                                if not self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["org_det"] = copy.deepcopy(field[x][y]["det"])
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]

                                if not self.validate_answer(
                                    tmp2, monster_effect_det["monster"], exclude, duel
                                ):

                                    continue
                                if cost == 0:
                                    if field[x][y]["det"] is not None:
                                        det = field[x][y]["det"].copy()
                                        org_det = copy.deepcopy(det)
                                        field[x][y]["det"] = None
                                        det = self.copy_monster_from_field(
                                            det,
                                            field[x][y]["kind"],
                                            field[x][y]["mine_or_other"],
                                        )
                                        if self.config.sort is True:
                                            field = self.sortField(field,y)
                                        self.field = field
                                        det["kind"] = effect_kind
                                        det["user"] = int(field[x][y]["mine_or_other"])
                                        det["user_det"] = effect_user
                                    else:
                                        field[x][y]["det"] = None
                                        if self.config.sort is True:
                                            field = self.sortField(field,y)
                                        self.field = field
                                        det = None
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "field"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = org_det
                                    return_tmp["det"] = det
                                    return_tmp["mine_or_other"] = field[x][y][
                                        "mine_or_other"
                                    ]
                                    return_value.append(return_tmp)
                                else:
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result["remove"]["field"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    det = self.copy_monster_from_field(
                                        det,
                                        field[x][y]["kind"],
                                        field[x][y]["mine_or_other"],
                                    )
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "field"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = org_det
                                    return_tmp["det"] = det
                                    return_tmp["mine_or_other"] = field[x][y][
                                        "mine_or_other"
                                    ]
                                    return_value.append(return_tmp)

        return return_value

    def move_from_monster_eternal(self, cost_kind, user, monster_effect):
        return self.move_from_monster(cost_kind, 2, user, monster_effect)

    def move_from_monster_cost(self, cost_kind):
        return self.move_from_monster(cost_kind, 1)

    def copy_special_effect(self, cost, effect_kind,answered = False):
        duel = self.duel
        phase = duel.phase
        turn = duel.user_turn
        del_flag = False
        copied_cost = -3
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(self.tmp_chain)]
        if effect_user == 1:
            other_user = 2
        else:
            other_user = 1
        copy_monster = json.loads(cost.cost)
        as_monster_effect = copy_monster["copy_monster"]
        copy_effect_kind = copy_monster["copy_kind"]
        if "copy2" in copy_monster:
            copy2 = copy_monster["copy2"]
        else:
            copy2 = False
        if "force" in copy_monster:
            force = copy_monster["force"]
        else:
            force = False
        tmp_mess = self.mess
        cost_tmp = self.cost
        timing_tmp = self.timing_mess
        trigger_monster = tmp_mess[str(self.tmp_chain)]["trigger"][0]
        if as_monster_effect[0] == "~":
            if duel.in_cost is True:
                if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                    return -3
                else:
                    place1 = cost_tmp[str(self.tmp_chain)][as_monster_effect]
            else:
                if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                    return -3
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][as_monster_effect]
        elif as_monster_effect[0] == "%":
            if as_monster_effect not in timing_tmp:
                return  -3
            else:
                place1 = timing_tmp[as_monster_effect]
        elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
            return -3
        else:
            place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
        return_monster = []
        place2 = place1[-1]
        return_monster.append(place2)
        id = self.get_monster_id_easy(place2["det"])
        monster_det = Monster.objects.get(id=id)
        if copy2 ==3:
            triggers = monster_det.trigger.filter(copy3=True).all()
        elif copy2 is True:
            triggers = monster_det.trigger.filter(copy2=True).all()
        else:
            triggers = monster_det.trigger.filter(copy=True).all()
        duel.chain_variable = "{}"
        for trigger in triggers:
            if copy_effect_kind != "":
                flag = self.check_effect_kind(copy_effect_kind, trigger.trigger_kind)
                if flag is False:
                    continue
            if not copy2 or copy2 == 3:
                if force is False and trigger.force is False  and answered is False:
                    if duel.is_ai is False or effect_user == 1:
                        if effect_user ==  duel.user_turn:
                            duel.ask = 1
                        elif effect_user !=  duel.user_turn:
                            duel.ask = 2
                        return -1
                    else:
                        self.answer_ai()
                copied_cost = self.invoke_copy_trigger(
                    trigger,
                    trigger_monster["place"],
                    trigger_monster["det"],
                    trigger_monster["mine_or_other"],
                    effect_user,
                    trigger_monster["deck_id"],
                    trigger_monster["x"],
                    trigger_monster["y"],
                    None,
                    None,
                    None,
                    None,
                    None,
                )
            else:
                if self.check_launch_trigger_for_copy2(
                    trigger,
                    phase,
                    turn,
                    effect_user,
                    other_user,
                    trigger_monster["mine_or_other"],
                    trigger_monster["place"],
                    trigger_monster["det"]["place_unique_id"],
                    trigger_monster["deck_id"],
                    trigger_monster["x"],
                    trigger_monster["y"],
                ):
                    if trigger.force is False  and answered is False and force is False:
                        if duel.is_ai is False or effect_user == 1:
                            if effect_user ==  self.duel.user_turn:
                                duel.ask = 1
                            elif effect_user !=  self.duel.user_turn:
                                duel.ask = 2
                            return -1
                        else:
                            self.answer_ai()
                    copied_cost = self.invoke_copy_trigger(
                        trigger,
                        trigger_monster["place"],
                        trigger_monster["det"],
                        trigger_monster["mine_or_other"],
                        effect_user,
                        trigger_monster["deck_id"],
                        trigger_monster["x"],
                        trigger_monster["y"],
                        None,
                        None,
                        None,
                        None,
                        None
                    )
        return_value = []
        return_value.append(copied_cost)
        return_value.append(return_monster)
        return return_value


    def copy_effect2(self, monster_effect, effect_kind):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        copy_monster = json.loads(monster_effect.monster_effect)
        as_monster_effect = copy_monster["copy_monster"]
        copy_effect_cost = copy_monster["copy_effect_cost"]
        copy_effect_kind = copy_monster["copy_kind"]
        tmp_mess = self.mess
        cost_tmp = self.cost
        timing_tmp = self.timing_mess
        copied_flag = False
        trigger_monster = tmp_mess[str(duel.chain - 1)]["trigger"][0]
        if as_monster_effect[0] == "~":
            if duel.in_cost is True:
                if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                    return
                else:
                    place1 = cost_tmp[str(self.tmp_chain)][as_monster_effect]
            else:
                if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                    return
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][as_monster_effect]
        elif as_monster_effect[0] == "%":
            if as_monster_effect not in timing_tmp:
                return
            else:
                place1 = timing_tmp[as_monster_effect]
        elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
            return
        else:
            place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
        for place2 in place1:
            id = place2["det"]["id"]
            monster_det = Monster.objects.get(id=id)
            triggers = monster_det.trigger.filter(copy=True).all()
            duel.chain_variable = "{}"
            for trigger in triggers:
                if copy_effect_kind != "":
                    if not self.check_effect_kind(
                        copy_effect_kind, trigger.trigger_kind
                    ):
                        continue
                copied_flag = True
                self.invoke_trigger(
                    trigger,
                    trigger_monster["place"],
                    trigger_monster["det"],
                    trigger_monster["mine_or_other"],
                    effect_user,
                    trigger_monster["deck_id"],
                    trigger_monster["x"],
                    trigger_monster["y"],
                    None,
                    None,
                    None,
                    None,
                    None,
                    copy_effect_cost,
                    copy_flag = True,
                    who = 0
                )
        if copied_flag is True:
            return "copy"
        else:
            return None

    def copy_effect(self, monster_effect, effect_kind, cost=1):
        duel = self.duel
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        copy_monster = json.loads(monster_effect.monster_effect)
        as_monster_effect = copy_monster["copy_monster"]
        copy_effect_cost = copy_monster["copy_effect_cost"]
        copy_effect_kind = copy_monster["copy_kind"]
        monster_condition = monster_effect.monster_condition
        tmp_mess = self.mess
        cost_tmp = self.cost
        timing_tmp = self.timing_mess
        copied_flag = False
        if as_monster_effect[0] == "~":
            if duel.in_cost is True:
                if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                    return
                else:
                    place1 = cost_tmp[str(self.tmp_chain)][as_monster_effect]
            else:
                if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                    return
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][as_monster_effect]
        elif as_monster_effect[0] == "%":
            if as_monster_effect not in timing_tmp:
                return
            else:
                place1 = timing_tmp[as_monster_effect]
        elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
            return
        else:
            place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
        for place2 in place1:
            place = place2["place"]
            if place == "field":
                x = int(place2["x"])
                y = int(place2["y"])
                field = self.field
                if "place_unique_id" in place2:
                    place_unique_id = place2["place_unique_id"]
                    if self.check_not_effected(
                        field[x][y]["det"],
                        effect_user,
                        effect_kind,
                        "field",
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                        cost,
                    ):
                        continue
                    if monster_condition != "":
                        tmp2 = {}
                        tmp2["det"] = field[x][y]["det"]
                        tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                        tmp2["user"] = chain_user
                        tmp2["place"] = "field"
                        tmp2["deck_id"] = 0
                        tmp2["x"] = x
                        tmp2["y"] = y
                        tmp2["place_unique_id"] = field[x][y]["det"]["place_unique_id"]
                        if not self.validate_answer(tmp2, monster_condition, "", duel):
                            continue
                    if self.config.sort is True:
                        x = self.search_place_unique_id(y,place_unique_id)
                        if x == -1:
                            continue
                    else:
                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                            continue
                    id = self.get_monster_id(
                        field[x][y]["det"],
                        "field",
                        field[x][y]["mine_or_other"],
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                    )
                    monster_det = Monster.objects.get(id=id)
                    triggers = monster_det.trigger.filter(copy=True).all()
                    duel.chain_variable = "{}"
                    for trigger in triggers:
                        if copy_effect_kind != "":
                            if not self.check_effect_kind(
                                copy_effect_kind, trigger.trigger_kind
                            ):
                                continue
                        copied_flag = True
                        self.copying_flag += 1
                        self.invoke_trigger(
                            trigger,
                            "field",
                            field[x][y]["det"],
                            field[x][y]["mine_or_other"],
                            effect_user,
                            0,
                            x,
                            y,
                            None,
                            None,
                            None,
                            None,
                            None,
                            copy_effect_cost,
                            copy_flag = True,
                            who=0
                        )

            mine_or_other2 = int(place2["mine_or_other"])
            mine_or_other3 = mine_or_other2
            if self.user == 2:
                if mine_or_other2 == 1:
                    mine_or_other2 = 2
                elif mine_or_other2 == 2:
                    mine_or_other2 = 1
                else:
                    pass
            deck_id = place2["deck_id"]
            place_unique_id = place2["place_unique_id"]
            if place == "deck":
                if mine_or_other2 == 1:
                    deck = self.decks[deck_id]["mydeck"]
                elif mine_or_other2 == 2:
                    deck = self.decks[deck_id]["otherdeck"]
                elif mine_or_other2 == 3:
                    deck = self.decks[deck_id]["commondeck"]
                user_decks = deck
                for user_deck in user_decks:
                    if place_unique_id == user_deck["place_unique_id"]:
                        if self.check_not_effected(
                            user_deck,
                            effect_user,
                            effect_kind,
                            "deck",
                            deck_id,
                            0,
                            0,
                            mine_or_other3,
                            cost,
                        ):
                            continue
                        if monster_condition != "":
                            tmp2 = {}
                            tmp2["det"] = user_deck["det"]
                            tmp2["mine_or_other"] = mine_or_other3
                            tmp2["user"] = chain_user
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_deck["place_unique_id"]
                            if not self.validate_answer(
                                tmp2, monster_condition, "", duel
                            ):
                                continue
                        id = self.get_monster_id(
                            user_deck,
                            "deck",
                            mine_or_other3,
                            deck_id,
                            0,
                            0,
                            mine_or_other3,
                        )
                        monster_det = Monster.objects.get(id=id)
                        triggers = monster_det.trigger.filter(copy=True).all()
                        duel.chain_variable = "{}"
                        for trigger in triggers:
                            self.copying_flag += 1
                            self.invoke_trigger(
                                trigger,
                                "deck",
                                user_deck,
                                mine_or_other3,
                                effect_user,
                                deck_id,
                                0,
                                0,
                                None,
                                None,
                                None,
                                None,
                                None,
                                copy_effect_cost,
                                copy_flag = True,
                                who=0,
                            )
                        copied_flag = True
            if place == "grave":
                if mine_or_other2 == 1:
                    grave = self.graves[deck_id]["mygrave"]
                elif mine_or_other2 == 2:
                    grave = self.graves[deck_id]["othergrave"]
                elif mine_or_other2 == 3:
                    grave = self.graves[deck_id]["commongrave"]
                user_graves = grave
                for user_grave in user_graves:
                    if place_unique_id == user_grave["place_unique_id"]:
                        if self.check_not_effected(
                            user_grave,
                            effect_user,
                            effect_kind,
                            "grave",
                            deck_id,
                            0,
                            0,
                            mine_or_other3,
                            cost,
                        ):
                            continue
                        if monster_condition != "":
                            tmp2 = {}
                            tmp2["det"] = user_grave["det"]
                            tmp2["mine_or_other"] = mine_or_other3
                            tmp2["user"] = chain_user
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_grave["place_unique_id"]
                            if not self.validate_answer(
                                tmp2, monster_condition, "", duel
                            ):
                                continue
                        id = self.get_monster_id(
                            user_grave,
                            "grave",
                            mine_or_other3,
                            deck_id,
                            0,
                            0,
                            mine_or_other3,
                        )
                        monster_det = Monster.objects.get(id=id)
                        triggers = monster_det.trigger.filter(copy=True).all()
                        duel.chain_variable = "{}"
                        for trigger in triggers:
                            self.copying_flag += 1
                            self.invoke_trigger(
                                trigger,
                                "grave",
                                user_grave,
                                mine_or_other3,
                                effect_user,
                                deck_id,
                                0,
                                0,
                                None,
                                None,
                                None,
                                None,
                                None,
                                copy_effect_cost,
                                copy_flag = True,
                                who=0,
                            )
                            copied_flag = True
            if place == "hand":
                if mine_or_other2 == 1:
                    hand = self.hands[deck_id]["myhand"]
                elif mine_or_other2 == 2:
                    hand = self.hands[deck_id]["otherhand"]
                elif mine_or_other2 == 3:
                    hand = self.hands[deck_id]["commonhand"]
                user_hands = hand
                for user_hand in user_hands:
                    if place_unique_id == user_hand["place_unique_id"]:
                        if self.check_not_effected(
                            user_hand,
                            effect_user,
                            effect_kind,
                            "hand",
                            deck_id,
                            0,
                            0,
                            mine_or_other3,
                            cost,
                        ):
                            continue
                        if monster_condition != "":
                            tmp2 = {}
                            tmp2["det"] = user_hand["det"]
                            tmp2["mine_or_other"] = mine_or_other3
                            tmp2["user"] = chain_user
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_hand["place_unique_id"]
                            if not self.validate_answer(
                                tmp2, monster_condition, "", duel
                            ):
                                continue
                        id = self.get_monster_id(
                            user_hand,
                            "hand",
                            mine_or_other3,
                            deck_id,
                            0,
                            0,
                            mine_or_other3,
                        )
                        monster_det = Monster.objects.get(id=id)
                        triggers = monster_det.trigger.filter(copy=True).all()
                        duel.chain_variable = "{}"
                        for trigger in triggers:
                            self.copying_flag += 1
                            self.invoke_trigger(
                                trigger,
                                "hand",
                                user_hand,
                                mine_or_other3,
                                effect_user,
                                deck_id,
                                0,
                                0,
                                None,
                                None,
                                None,
                                None,
                                None,
                                copy_effect_cost,
                                copy_flag = True,
                                who=00,
                            )
                            copied_flag = True
        self.copying_flag = 0
        if copied_flag is True:
            return "copy"
        else:
            return None

    def move_from_monster_relation_cost(self, effect_kind):
        self.move_from_monster_relation(effect_kind, 1)

    def move_from_monster_relation(self, effect_kind, effect_kind_rel, cost=0):
        duel = self.duel
        chain_det = json.loads(self.duel.chain_det)
        chain_user = json.loads(duel.chain_user)
        if cost == 0:
            effect_user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_text = json.loads(monster_effect.monster_effect)
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_condition = monster_effect.monster_condition
        else:
            effect_user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost = cost_wrapper.cost
            monster_effect_text = json.loads(cost.cost)
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_condition = cost.cost_condition
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]

        return_value = []
        exclude = monster_effect_text["exclude"]
        for monster_effect_det in monster_effect_text_monster:
            if (
                "as_monster_condition" in monster_effect_det
                and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monster_effects = monster_effect_det["as_monster_condition"]
                as_monster_effects = as_monster_effects.split(",")
                for as_monster_effect in as_monster_effects:
                    tmp_mess = self.mess
                    cost_tmp = self.cost
                    timing_tmp = self.timing_mess
                    if as_monster_effect == "before":
                        place1 = tmp_mess[str(duel.chain - 1)]["trigger"]
                        det_from = place1[0]["det_from"]
                        tmp_monsters = self.get_relation_monster(
                            det_from["det"],
                            monster_effect_text,
                            effect_kind_rel,
                            effect_user,
                        )
                        return_value.extend(tmp_monsters)
                        continue
                    elif as_monster_effect[0] == "~":
                        if duel.in_cost is True:
                            if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                                continue
                            else:
                                place1 = cost_tmp[str(self.tmp_chain)][
                                    as_monster_effect
                                ]
                        else:
                            if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                                continue
                            else:
                                place1 = cost_tmp[str(duel.chain - 1)][
                                    as_monster_effect
                                ]
                    elif as_monster_effect[0] == "%":
                        if as_monster_effect not in timing_tmp:
                            continue
                        else:
                            place1 = timing_tmp[as_monster_effect]
                    elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
                        continue
                    else:
                        place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
                    for place2 in place1:
                        place = place2["place"]
                        if place == "field":
                            x = int(place2["x"])
                            y = int(place2["y"])
                            field = self.field
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                if cost == 0:
                                    if self.config.sort is True:
                                        x = self.search_place_unique_id(y,place_unique_id)
                                        if x == -1:
                                            continue
                                    else:
                                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                            continue
                                    tmp_monsters = self.get_relation_monster(
                                        field[x][y]["det"],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                                    continue

                        mine_or_other2 = int(place2["mine_or_other"])
                        mine_or_other3 = mine_or_other2
                        if self.user == 2:
                            if mine_or_other2 == 1:
                                mine_or_other2 = 2
                            elif mine_or_other2 == 2:
                                mine_or_other2 = 1
                            else:
                                pass
                        deck_id = place2["deck_id"]
                        place_unique_id = place2["place_unique_id"]
                        if place == "deck":
                            if mine_or_other2 == 1:
                                deck = self.decks[deck_id]["mydeck"]
                            elif mine_or_other2 == 2:
                                deck = self.decks[deck_id]["otherdeck"]
                            elif mine_or_other2 == 3:
                                deck = self.decks[deck_id]["commondeck"]
                            user_decks = deck
                            for user_deck in user_decks:
                                if place_unique_id == user_deck["place_unique_id"]:
                                    if self.check_not_effected(
                                        user_deck,
                                        effect_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        continue
                                    if monster_condition != "":
                                        tmp2 = {}
                                        tmp2["det"] = user_deck["det"]
                                        tmp2["mine_or_other"] = mine_or_other3
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_deck[
                                            "place_unique_id"
                                        ]
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    if cost == 0:
                                        tmp_monsters = self.get_relation_monster(
                                            user_deck,
                                            monster_effect_text,
                                            effect_kind_rel,
                                            effect_user,
                                        )
                                        return_value.extend(tmp_monsters)
                        if place == "grave":
                            if mine_or_other2 == 1:
                                grave = self.graves[deck_id]["mygrave"]
                            elif mine_or_other2 == 2:
                                grave = self.graves[deck_id]["othergrave"]
                            elif mine_or_other2 == 3:
                                grave = self.graves[deck_id]["commongrave"]
                            user_graves = grave
                            for user_grave in user_graves:
                                if place_unique_id == user_grave["place_unique_id"]:
                                    if self.check_not_effected(
                                        user_grave,
                                        effect_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        continue
                                    if monster_condition != "":
                                        tmp2 = {}
                                        tmp2["det"] = user_grave["det"]
                                        tmp2["mine_or_other"] = mine_or_other3
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_grave[
                                            "place_unique_id"
                                        ]
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    if cost == 0:
                                        tmp_monsters = self.get_relation_monster(
                                            user_grave,
                                            monster_effect_text,
                                            effect_kind_rel,
                                            effect_user,
                                        )
                                        return_value.extend(tmp_monsters)
                        if place == "hand":
                            if mine_or_other2 == 1:
                                hand = self.hands[deck_id]["myhand"]
                            elif mine_or_other2 == 2:
                                hand = self.hands[deck_id]["otherhand"]
                            elif mine_or_other2 == 3:
                                hand = self.hands[deck_id]["commonhand"]
                            user_hands = hand
                            for user_hand in user_hands:
                                if place_unique_id == user_hand["place_unique_id"]:
                                    if self.check_not_effected(
                                        user_hand,
                                        effect_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        continue
                                    if monster_condition != "":
                                        tmp2 = {}
                                        tmp2["det"] = user_hand["det"]
                                        tmp2["mine_or_other"] = mine_or_other3
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hand[
                                            "place_unique_id"
                                        ]
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    if cost == 0:
                                        tmp_monsters = self.get_relation_monster(
                                            user_hand,
                                            monster_effect_text,
                                            effect_kind_rel,
                                            effect_user,
                                        )
                                        return_value.extend(tmp_monsters)
                                    else:
                                        cost_result = self.cost_result
                                        if "remove" not in cost_result:
                                            cost_result["remove"] = {}
                                        if "hand" not in cost_result["remove"]:
                                            cost_result["remove"]["hand"] = []
                                        place_unique_id = user_hand["place_unique_id"]
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["user"] = mine_or_other3
                                        cost_result_tmp[
                                            "user_det"
                                        ] = self.duel.cost_user
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["remove"]["hand"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                        return_tmp = {}
                                        return_tmp["x"] = 0
                                        return_tmp["y"] = 0
                                        return_tmp["place"] = "hand"
                                        return_tmp["mine_or_other"] = mine_or_other3
                                        return_tmp["deck_id"] = deck_id
                                        return_tmp["org_det"] = copy.deepcopy(user_hand)
                                        return_tmp["det"] = self.copy_monster_from_hand(
                                            user_hand, deck_id, mine_or_other3
                                        )
                                        return_value.append(return_tmp)

            place_array_tmp = []
            for place in monster_effect_det["monster"]["place"]:
                place_tmp = place["det"].split("_")
                if place["det"] == "":
                    continue
                if place["and_or"] != "" and place_tmp[0] == "field":
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    continue
                else:
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    place_array = place_array_tmp
                    place_array_tmp = []
                deck_id = int(place_tmp[1])
                for tmp_i in range(
                    int(
                        self.calculate_boland(
                            monster_effect_det["min_equation_number"], None, False
                        )
                    )
                ):
                    tmp_i2 = 0
                    if monster_effect_text["field_x"]:
                        field = self.field
                        for str_x in monster_effect_text["field_x"]:
                            x = int(str_x)
                            y = int(monster_effect_text["field_y"][tmp_i2])
                            if cost == 0:
                                if field[x][y]["det"] is not None:
                                    place_unique_id = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.check_not_effected(
                                        field[x][y]["det"],
                                        effect_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                    ):
                                        tmp_monsters = self.get_relation_monster(
                                            field[x][y]["det"],
                                            monster_effect_text,
                                            effect_kind_rel,
                                            effect_user,
                                        )
                                        return_value.extend(tmp_monsters)
                            """
                            else:
                                cost_result_tmp = {}
                                cost_result_tmp["x"]= x
                                cost_result_tmp["y"]= y
                                cost_result_tmp["place_unique_id"]= place_unique_id
                                cost_result["remove"]["field"].append(cost_result_tmp)
                                self.cost_result = cost_result
                                det =self.copy_monster_from_field(det)
                                return_tmp={}
                                return_tmp["x"] = x
                                return_tmp["y"] = y
                                return_tmp["place"] = "field"
                                return_tmp["deck_id"] = 0
                                return_tmp["org_det"] = org_det
                                return_tmp["det"] = det
                                return_value.append( return_tmp)
                                """
                        continue
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user != self.user) or (
                        place_tmp[2] == "2" and effect_user == self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if self.user == 1:
                        mine_or_other3 = mine_or_other2
                    else:
                        if mine_or_other2 == 1:
                            mine_or_other3 = 2
                        elif mine_or_other2 == 2:
                            mine_or_other3 = 1
                        else:
                            mine_or_other3 = 3

                    if place_tmp[0] == "deck":
                        if mine_or_other2 == 1:
                            deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            deck = self.decks[deck_id]["otherdeck"]
                        elif mine_or_other2 == 3:
                            deck = self.decks[deck_id]["commondeck"]
                        user_decks = deck
                        if cost == 0:
                            if monster_effect_text["move_how"] == 0:
                                if not self.check_not_effected(
                                    user_decks[0],
                                    effect_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_decks[0],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                            elif monster_effect_text["move_how"] == 1:
                                if not self.check_not_effected(
                                    user_decks[-1],
                                    effect_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_decks[-1],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                            else:
                                rand_i = random.randrange(len(user_decks))
                                if not self.check_not_effected(
                                    user_decks[rand_i],
                                    effect_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_decks[rand_i],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                    elif place_tmp[0] == "grave":
                        if mine_or_other2 == 1:
                            grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            grave = self.graves[deck_id]["othergrave"]
                        elif mine_or_other2 == 3:
                            grave = self.graves[deck_id]["commongrave"]
                        user_graves = grave
                        if cost == 0:
                            if monster_effect_text["move_how"] == 0:
                                if not self.check_not_effected(
                                    user_graves[0],
                                    effect_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_graves[0],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                            elif monster_effect_text["move_how"] == 1:
                                if not self.check_not_effected(
                                    user_graves[-1],
                                    effect_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_graves[-1],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                            else:
                                rand_i = random.randrange(len(user_graves))
                                if not self.check_not_effected(
                                    user_graves[rand_i],
                                    effect_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_graves[rand_i],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                    elif place_tmp[0] == "hand":
                        if mine_or_other2 == 1:
                            hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            hand = self.hands[deck_id]["otherhand"]
                        elif mine_or_other2 == 3:
                            hand = self.hands[deck_id]["commonhand"]
                        user_hands = hand
                        if cost == 0:
                            if monster_effect_text["move_how"] == 0:
                                if not self.check_not_effected(
                                    user_hands[0],
                                    effect_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_hands[0],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                            elif monster_effect_text["move_how"] == 1:
                                if not self.check_not_effected(
                                    user_hands[-1],
                                    effect_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_hands[-1],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                            else:
                                rand_i = random.randrange(len(user_hands))
                                if not self.check_not_effected(
                                    user_hands[rand_i],
                                    effect_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    tmp_monsters = self.get_relation_monster(
                                        user_hands[rand_i],
                                        monster_effect_text,
                                        effect_kind_rel,
                                        effect_user,
                                    )
                                    return_value.extend(tmp_monsters)
                    elif place_tmp[0] == "field":
                        field_size = FieldSize.objects.get(id=1)
                        field = self.field
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for x in range(field_x):
                            for y in range(field_size.field_y):
                                flag_field_place = True
                                current_and_or = "and"
                                for place_tmp2 in place_array:
                                    and_or = place_tmp2["and_or"]
                                    det = place_tmp2["det"]
                                    splitted_det = det.split("_")
                                    kind = splitted_det[1]
                                    # jsonに入っているデータは相対的
                                    mine_or_other_relative = splitted_det[2]
                                    if (
                                        mine_or_other_relative == "1"
                                        and effect_user == self.user
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user != self.user
                                    ):
                                        mine_or_other2 = 1
                                    elif (
                                        mine_or_other_relative == "1"
                                        and effect_user != self.user
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == self.user
                                    ):
                                        mine_or_other2 = 2
                                    else:
                                        mine_or_other2 = 3
                                    if self.field_free is False:
                                        kinds = field[x][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    else:
                                        kinds = field[0][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    tmp = kinds.split("_")
                                    if current_and_or == "and":
                                        if (
                                            str(kind) in tmp
                                            and mine_or_other_field == mine_or_other2
                                        ):
                                            if flag_field_place is True:
                                                flag_field_place = True
                                        else:
                                            flag_field_place = False
                                    elif current_and_or == "or":
                                        if (
                                            str(kind) in tmp
                                            and mine_or_other_field == mine_or_other2
                                        ):
                                            flag_field_place = True
                                        else:
                                            if flag_field_place is False:
                                                flag_field_place = False
                                    current_and_or = and_or
                                if flag_field_place is False:
                                    continue
                                if field[x][y]["det"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["org_det"] = field[x][y]["det"]
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_det["monster"], exclude, duel
                                ):

                                    continue
                                if cost == 0:
                                    if field[x][y]["det"] is not None:
                                        tmp_monsters = self.get_relation_monster(
                                            field[x][y]["det"],
                                            monster_effect_text,
                                            effect_kind_rel,
                                            effect_user,
                                        )
                                        return_value.extend(tmp_monsters)

        return return_value

    def reload2_mess(self,reload_mess):
        tmp_cost = self.cost
        tmp_mess = self.mess
        tmp_timing_mess = self.timing_mess
        messes = reload_mess.split(",")
        for mess in messes:
            if mess[0] == "~":
                if mess not in tmp_cost[str(self.duel.chain - 1)]:
                    return
                tmp_cost[str(self.duel.chain - 1)][mess] = self.reload2_mess_det(tmp_cost[str(self.duel.chain-1)][mess])
                
            elif mess[0] == "%":
                if mess not in tmp_timing_mess:
                    return
                tmp_timing_mess[mess] = self.reload2_mess_det(tmp_timing_mess[mess])
            else:
                if mess not in tmp_mess[str(self.duel.chain - 1)]:
                    return
                tmp_mess[str(self.duel.chain - 1)][mess] = self.reload2_mess_det(
                    tmp_mess[str(self.duel.chain - 1)][mess]
                )
        self.cost = tmp_cost
        self.mess = tmp_mess
        self.timing_mess = tmp_timing_mess
    def reload2_mess_det(self,reload_mess):
        field = self.field
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is True:
            field_x = 20
        else:
            field_x = field_size.field_x
        return_value = []
        for mess in reload_mess:
            for x in range(field_x):
                for y in range(field_size.field_y):
                    if "det" in field[x][y] and field[x][y]["det"] is not None and field[x][y]["det"]["place_unique_id"] == mess["place_unique_id"]:
                        tmp2 = {}
                        tmp2["det"] = field[x][y]["det"]
                        tmp2["hide"] = field[x][y]["hide"] if ("hide" in field) else False
                        tmp2["x"] = x
                        tmp2["y"] = y
                        tmp2["deck_id"] = 0
                        tmp2["place_unique_id"] = field[x][y]["det"]["place_unique_id"]
                        tmp2["user"] = field[x][y]["mine_or_other"]
                        tmp2["place"] = "field"
                        tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                        return_value.append(tmp2)
        return return_value
                    
    def reload_mess(self, reload_mess):
        tmp_mess = self.mess
        tmp_timing_mess = self.timing_mess
        messes = reload_mess.split(",")
        for mess in messes:
            if mess[0] == "%":
                if mess not in tmp_timing_mess:
                    return
                tmp_timing_mess[mess] = self.reload_mess_det(tmp_timing_mess[mess])
            else:
                if mess not in tmp_mess[str(self.duel.chain - 1)]:
                    return
                tmp_mess[str(self.duel.chain - 1)][mess] = self.reload_mess_det(
                    tmp_mess[str(self.duel.chain - 1)][mess]
                )
        self.mess = tmp_mess
        self.timing_mess = tmp_timing_mess

    def reload_mess_det(self, mess_dets):
        index = -1
        for mess_det in mess_dets:
            index += 1
            if mess_det["place"] == "field":
                x = mess_det["x"]
                y = mess_det["y"]
                mess_dets[index]["det"] = self.field[x][y]["det"]
        return mess_dets

    def clear_cost_mess(self, clear_cost):
        tmp_cost = self.cost
        costs = clear_cost.split(",")
        for cost in costs:
            del tmp_cost[str(self.duel.chain)][cost]
        self.cost = tmp_cost

    def clear_mess(self, clear_mess):
        tmp_mess = self.mess
        messes = clear_mess.split(",")
        for mess in messes:
            if mess in tmp_mess[str(self.duel.chain - 1)]:
                del tmp_mess[str(self.duel.chain - 1)][mess]
        self.mess = tmp_mess

    def move_from_monster_under(
        self, effect_kind, cost=0, user=None, monster_effect=None
    ):
        duel = self.duel
        if cost == 0:
            chain_det = json.loads(self.duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            effect_user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_text = json.loads(monster_effect.monster_effect)
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_condition = monster_effect.monster_condition
        elif cost == 2:
            effect_user = user
            monster_effect_text = json.loads(
                monster_effect.monster_effect.monster_effect
            )
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_condition = monster_effect.monster_effect.monster_condition
        else:
            chain_det = json.loads(self.duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            effect_user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost2 = cost_wrapper.cost
            monster_effect_text = json.loads(cost2.cost)
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_condition = cost2.cost_condition
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        return_value = []
        exclude = monster_effect_text["exclude"]
        for monster_effect_det in monster_effect_text_monster:
            if (
                "as_monster_condition" in monster_effect_det
                and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monster_effects = monster_effect_det["as_monster_condition"]
                as_monster_effects = as_monster_effects.split(",")
                for as_monster_effect in as_monster_effects:
                    tmp_mess = self.mess
                    cost_tmp = self.cost
                    timing_tmp = self.timing_mess
                    if as_monster_effect[0] == "-":
                        place1 = tmp_mess[str(duel.chain - 2)][as_monster_effect[1:]]
                    elif as_monster_effect[0] == "~":
                        if duel.in_cost is True:
                            if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                                continue
                            else:
                                place1 = cost_tmp[str(self.tmp_chain)][
                                    as_monster_effect
                                ]
                        else:
                            if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                                continue
                            else:
                                place1 = cost_tmp[str(duel.chain - 1)][
                                    as_monster_effect
                                ]
                    elif as_monster_effect[0] == "%":
                        if as_monster_effect not in timing_tmp:
                            continue
                        else:
                            place1 = timing_tmp[as_monster_effect]
                    elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
                        continue
                    else:
                        place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
                    for place2 in place1:
                        place = place2["place"]
                        if place == "field":
                            x = int(place2["x"])
                            y = int(place2["y"])
                            field = self.field
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if field[x][y]["det"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                if cost != 1:
                                    for under in field[x][y]["det"]["under"]:
                                        under = self.copy_monster_from_under(under)
                                        under["kind"] = effect_kind
                                        under["user"] = int(
                                            field[x][y]["mine_or_other"]
                                        )
                                        under["mine_or_other"] = int(
                                            field[x][y]["mine_or_other"]
                                        )
                                        under["user_det"] = effect_user
                                        return_tmp = {}
                                        return_tmp["mine_or_other"] = int(
                                            field[x][y]["mine_or_other"]
                                        )
                                        return_tmp["x"] = x
                                        return_tmp["y"] = y
                                        return_tmp["place"] = "under"
                                        return_tmp["deck_id"] = 0
                                        return_tmp["org_det"] = under
                                        return_tmp["det"] = under
                                        return_value.append(return_tmp)
                                    del field[x][y]["det"]["under"]
                                    self.field = field
                                    continue
                                else:
                                    cost_result = self.cost_result
                                    if "remove" not in cost_result:
                                        cost_result["remove"] = {}

                                    self.cost_result = cost_result
                                    continue

                        mine_or_other2 = int(place2["mine_or_other"])
                        if self.user == 2:
                            if mine_or_other2 == 1:
                                mine_or_other2 = 2
                            elif mine_or_other2 == 2:
                                mine_or_other2 = 1
                            else:
                                pass
                        place_unique_id = place2["place_unique_id"]
            place_array_tmp = []
            for place in monster_effect_det["monster"]["place"]:
                place_tmp = place["det"].split("_")
                if place["det"] == "":
                    continue
                if place["and_or"] != "" and place_tmp[0] == "under":
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    continue
                else:
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    place_array = place_array_tmp
                    place_array_tmp = []
                for tmp_i in range(
                    int(
                        self.calculate_boland(
                            monster_effect_det["min_equation_number"], None, False
                        )
                    )
                ):
                    tmp_i2 = 0
                    if monster_effect_text["field_x"]:
                        field = self.field
                        for str_x in monster_effect_text["field_x"]:
                            x = int(str_x)
                            y = int(monster_effect_text["field_y"][tmp_i2])
                            if cost != 1:
                                if field[x][y]["det"] is not None:
                                    place_unique_id = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.check_not_effected(
                                        field[x][y]["det"],
                                        effect_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                    ):
                                        for under in field[x][y]["det"]["under"]:
                                            det = self.copy_monster_from_under(under)
                                            det["kind"] = effect_kind
                                            det["user"] = int(
                                                field[x][y]["mine_or_other"]
                                            )
                                            det["user_det"] = effect_user
                                            return_tmp = {}
                                            return_tmp["mine_or_other"] = int(
                                                field[x][y]["mine_or_other"]
                                            )
                                            return_tmp["x"] = x
                                            return_tmp["y"] = y
                                            return_tmp["place"] = "under"
                                            return_tmp["deck_id"] = 0
                                            return_tmp["det"] = det
                                            return_tmp["org_det"] = copy.deepcopy(field[x][y]["det"]["under"])
                                            return_value.append(return_tmp)
                                        del field[x][y]["det"]["under"]
                                else:
                                    field[x][y]["det"]["under"]
                                    self.field = field
                                    det = None
                            else:
                                for under in field[x][y]["det"]["under"]:
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["under_id"] = under[
                                        "place_unique_id"
                                    ]
                                    cost_result["remove"]["under"].append(
                                        cost_result_tmp
                                    )
                                    det = self.copy_monster_from_under(det)
                                    return_tmp = {}
                                    return_tmp["mine_or_other"] = int(
                                        field[x][y]["mine_or_other"]
                                    )
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "under"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = copy.deepcopy(field[x][y]["det"]["under"])
                                    return_tmp["det"] = det
                                    return_value.append(return_tmp)
                                self.cost_result = cost_result
                        continue
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user != self.user) or (
                        place_tmp[2] == "2" and effect_user == self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3

                    if place_tmp[0] == "under":
                        field_size = FieldSize.objects.get(id=1)
                        field = self.field
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for x in range(field_x):
                            for y in range(field_size.field_y):
                                flag_field_place = True
                                current_and_or = "and"
                                for place_tmp2 in place_array:
                                    and_or = place_tmp2["and_or"]
                                    det = place_tmp2["det"]
                                    splitted_det = det.split("_")
                                    kind = splitted_det[1]
                                    # jsonに入っているデータは相対的
                                    mine_or_other_relative = splitted_det[2]
                                    if (
                                        mine_or_other_relative == "1"
                                        and effect_user == 1
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == 2
                                    ):
                                        mine_or_other2 = 1
                                    elif (
                                        mine_or_other_relative == "1"
                                        and effect_user == 2
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == 1
                                    ):
                                        mine_or_other2 = 2
                                    else:
                                        mine_or_other2 = 3
                                    if self.field_free is False:
                                        kinds = field[x][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    else:
                                        kinds = field[0][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    tmp = kinds.split("_")
                                    if current_and_or == "and":
                                        if (
                                            str(kind) in tmp
                                            and mine_or_other_field == mine_or_other2
                                        ):
                                            if flag_field_place is True:
                                                flag_field_place = True
                                        else:
                                            flag_field_place = False
                                    elif current_and_or == "or":
                                        if (
                                            str(kind) in tmp
                                            and mine_or_other_field == mine_or_other2
                                        ):
                                            flag_field_place = True
                                        else:
                                            if flag_field_place is False:
                                                flag_field_place = False
                                    current_and_or = and_or
                                if flag_field_place is False:
                                    continue
                                if field[x][y]["det"] is None:
                                    continue
                                if "under" not in field[x][y]["det"] or field[x][y]["det"]["under"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["org_det"] = field[x][y]["det"]
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = effect_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_det["monster"], exclude, duel
                                ):
                                    continue
                                if cost != 1:
                                    if field[x][y]["det"] is not None:
                                        for under in field[x][y]["det"]["under"]:
                                            under = self.copy_monster_from_under(under)
                                            under["kind"] = effect_kind
                                            under["user"] = int(
                                                field[x][y]["mine_or_other"]
                                            )
                                            under["user_det"] = effect_user
                                            return_tmp = {}
                                            return_tmp["mine_or_other"] = int(
                                                field[x][y]["mine_or_other"]
                                            )
                                            return_tmp["x"] = x
                                            return_tmp["y"] = y
                                            return_tmp["place"] = "under"
                                            return_tmp["deck_id"] = 0
                                            return_tmp["org_det"] = under
                                            return_tmp["det"] = under
                                            return_value.append(return_tmp)
                                        del field[x][y]["det"]["under"]
                                        self.field = field
                                else:
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result["remove"]["under"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    for under in field[x][y]["det"]["under"]:
                                        return_tmp = {}
                                        return_tmp["mine_or_other"] = int(
                                            field[x][y]["mine_or_other"]
                                        )
                                        return_tmp["x"] = x
                                        return_tmp["y"] = y
                                        return_tmp["place"] = "under"
                                        return_tmp["deck_id"] = 0
                                        return_tmp["org_det"] = under
                                        return_tmp["det"] = under
                                        return_value.append(return_tmp)
        return return_value

    def move_from_monster(self, effect_kind, cost=0, user=None, monster_effect=None):
        duel = self.duel
        if cost == 0:
            chain_det = json.loads(self.duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            effect_user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_text = json.loads(monster_effect.monster_effect)
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_effect_text_monster0 = monster_effect_text_monster[0]["monster"]
            monster_condition = monster_effect.monster_condition
        elif cost == 2:
            effect_user = user
            monster_effect_text = json.loads(
                monster_effect.monster_effect.monster_effect
            )
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_effect_text_monster0 = monster_effect_text_monster[0]["monster"]
            monster_condition = monster_effect.monster_effect.monster_condition
        else:
            chain_det = json.loads(self.duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            effect_user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost2 = cost_wrapper.cost
            monster_effect_text = json.loads(cost2.cost)
            monster_effect_text_monster = monster_effect_text["monster"]
            monster_effect_text_monster0 = monster_effect_text_monster[0]["monster"]
            monster_condition = cost2.cost_condition
        if monster_condition != "":
            monster_condition = json.loads(monster_condition)
            monster_condition = monster_condition["monster"][0]["monster"]
        return_value = []
        exclude = monster_effect_text["exclude"]
        for monster_effect_det in monster_effect_text_monster:
            if (
                "as_monster_condition" in monster_effect_det
                and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monster_effects = monster_effect_det["as_monster_condition"]
                as_monster_effects = as_monster_effects.split(",")
                for as_monster_effect in as_monster_effects:
                    tmp_mess = self.mess
                    cost_tmp = self.cost
                    timing_tmp = self.timing_mess
                    if as_monster_effect[0] == "-":
                        if duel.chain - 2 < 0:
                            continue
                        place1 = tmp_mess[str(duel.chain - 2)][as_monster_effect[1:]]
                    elif as_monster_effect[0] == "~":
                        if duel.in_cost is True:
                            if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                                continue
                            else:
                                place1 = cost_tmp[str(self.tmp_chain)][
                                    as_monster_effect
                                ]
                        else:
                            if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                                continue
                            else:
                                place1 = cost_tmp[str(duel.chain - 1)][
                                    as_monster_effect
                                ]
                    elif as_monster_effect[0] == "%":
                        if as_monster_effect not in timing_tmp:
                            continue
                        else:
                            place1 = timing_tmp[as_monster_effect]
                    elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
                        continue
                    else:
                        place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
                    for place2 in place1:
                        place = place2["place"]
                        if place == "under":
                            x = int(place2["x"])
                            y = int(place2["y"])
                            field = self.field
                            under_id = place2["under_id"]

                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if field[x][y]["det"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                if "under" not in field[x][y]["det"]:
                                    continue
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue

                                if cost != 1:
                                    if self.config.sort is True:
                                        x = self.search_place_unique_id(y,place_unique_id)
                                        if x == -1:
                                            continue
                                    else:
                                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                            continue
                                    for index in range(
                                        len(field[x][y]["det"]["under"])
                                    ):
                                        if (
                                            under_id
                                            == field[x][y]["det"]["under"][index][
                                                "place_unique_id"
                                            ]
                                        ):
                                            break
                                    under = field[x][y]["det"]["under"].pop(index)
                                    under["kind"] = effect_kind
                                    under["user"] = int(field[x][y]["mine_or_other"])
                                    under["user_det"] = effect_user
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "under"
                                    return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = copy.deepcopy(under)
                                    return_tmp["det"] = self.copy_monster_from_under(
                                        under
                                    )
                                    return_value.append(return_tmp)
                                    self.field = field
                                    continue
                                else:
                                    cost_result = self.cost_result
                                    if "remove" not in cost_result:
                                        cost_result["remove"] = {}

                                    if "under" not in cost_result["remove"]:
                                        cost_result["remove"]["under"] = []
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result_tmp["under_id"] = under_id

                                    cost_result["remove"]["under"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "under"
                                    return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = copy.deepcopy(under)
                                    return_tmp["det"] = self.copy_monster_from_under(
                                        under
                                    )
                                    return_value.append(return_tmp)
                                    continue
                        if place == "field":
                            x = int(place2["x"])
                            y = int(place2["y"])
                            field = self.field
                            if "place_unique_id" in place2:
                                place_unique_id = place2["place_unique_id"]
                                if field[x][y]["det"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                if monster_condition != "":
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = chain_user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                        tmp2, monster_condition, "", duel
                                    ):
                                        continue
                                if cost != 1:
                                    if self.config.sort is True:
                                        x = self.search_place_unique_id(y,place_unique_id)
                                        if x == -1:
                                            continue
                                    else:
                                        if field[x][y]["det"]["place_unique_id"] != place_unique_id:
                                            continue
                                    field[x][y]["det"]["kind"] = effect_kind
                                    field[x][y]["det"]["user"] = int(
                                        field[x][y]["mine_or_other"]
                                    )
                                    field[x][y]["det"]["user_det"] = effect_user
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                    return_tmp["place"] = "field"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = copy.deepcopy(
                                        field[x][y]["det"]
                                    )
                                    return_tmp["det"] = self.copy_monster_from_field(
                                        field[x][y]["det"],
                                        field[x][y]["kind"],
                                        field[x][y]["mine_or_other"],
                                    )
                                    return_value.append(return_tmp)
                                    self.effect += "field_move;"+str(x)+";"+str(y)+"|"
                                    self.effect2 += "field_move;"+str(x)+";"+str(y)+"|"
                                    field[x][y]["det"] = None
                                    if self.config.sort is True:
                                        field = self.sortField(field,y)
                                    self.field = field
                                    continue
                                else:
                                    cost_result = self.cost_result
                                    if "remove" not in cost_result:
                                        cost_result["remove"] = {}

                                    if "field" not in cost_result["remove"]:
                                        cost_result["remove"]["field"] = []
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id

                                    cost_result["remove"]["field"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["place"] = "field"
                                    return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = copy.deepcopy(
                                        field[x][y]["det"]
                                    )
                                    return_tmp["det"] = self.copy_monster_from_field(
                                        field[x][y]["det"],
                                        field[x][y]["kind"],
                                        field[x][y]["mine_or_other"],
                                    )
                                    return_value.append(return_tmp)
                                    continue

                        mine_or_other2 = int(place2["mine_or_other"])
                        mine_or_other3 = mine_or_other2
                        if self.user == 2:
                            if mine_or_other2 == 1:
                                mine_or_other2 = 2
                            elif mine_or_other2 == 2:
                                mine_or_other2 = 1
                            else:
                                pass
                        deck_id = place2["deck_id"]
                        place_unique_id = place2["place_unique_id"]
                        if place == "deck":
                            if mine_or_other2 == 1:
                                deck = self.decks[deck_id]["mydeck"]
                            elif mine_or_other2 == 2:
                                deck = self.decks[deck_id]["otherdeck"]
                            elif mine_or_other2 == 3:
                                deck = self.decks[deck_id]["commondeck"]
                            user_decks = deck
                            for user_deck in user_decks:
                                if place_unique_id == user_deck["place_unique_id"]:
                                    if self.check_not_effected(
                                        user_deck,
                                        effect_user,
                                        effect_kind,
                                        "deck",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        continue
                                    if monster_condition != "":
                                        tmp2 = {}
                                        tmp2["det"] = user_deck["det"]
                                        tmp2["mine_or_other"] = user_deck["det"]["owner"]
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "deck"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_deck[
                                            "place_unique_id"
                                        ]
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    if cost != 1:
                                        user_decks.remove(user_deck)
                                        user_deck["kind"] = effect_kind
                                        user_deck["user"] = mine_or_other2
                                        user_deck["user_det"] = effect_user
                                        return_tmp = {}
                                        return_tmp["x"] = 0
                                        return_tmp["y"] = 0
                                        return_tmp["place"] = "deck"
                                        return_tmp["mine_or_other"] = user_deck["owner"]
                                        return_tmp["deck_id"] = deck_id
                                        return_tmp["org_det"] = copy.deepcopy(user_deck)
                                        return_tmp["det"] = self.copy_monster_from_deck(
                                            user_deck, deck_id, mine_or_other3
                                        )
                                        return_value.append(return_tmp)
                                        if mine_or_other2 == 1:
                                            self.decks[deck_id]["mydeck"] = user_decks
                                        elif mine_or_other2 == 2:
                                            self.decks[deck_id][
                                                "otherdeck"
                                            ] = user_decks
                                        elif mine_or_other2 == 3:
                                            self.decks[deck_id][
                                                "commondeck"
                                            ] = user_decks
                                    else:
                                        cost_result = self.cost_result
                                        if "remove" not in cost_result:
                                            cost_result["remove"] = {}
                                        if "deck" not in cost_result["remove"]:
                                            cost_result["remove"]["deck"] = []
                                            place_unique_id = user_deck[
                                                "place_unique_id"
                                            ]
                                            cost_result_tmp = {}
                                            cost_result_tmp[
                                                "place_unique_id"
                                            ] = place_unique_id
                                            cost_result_tmp["user"] = mine_or_other3
                                            cost_result_tmp[
                                                "user_det"
                                            ] = self.duel.cost_user
                                            cost_result_tmp["deck_id"] = deck_id
                                            cost_result["remove"]["deck"].append(
                                                cost_result_tmp
                                            )
                                            self.cost_result = cost_result
                                            return_tmp = {}
                                            return_tmp["x"] = 0
                                            return_tmp["y"] = 0
                                            return_tmp["place"] = "deck"
                                            return_tmp["mine_or_other"] = user_deck["owner"]
                                            return_tmp["deck_id"] = deck_id
                                            return_tmp["org_det"] = copy.deepcopy(
                                                user_deck
                                            )
                                            return_tmp[
                                                "det"
                                            ] = self.copy_monster_from_deck(
                                                user_deck, deck_id, mine_or_other3
                                            )
                                            return_value.append(return_tmp)
                        if place == "grave":
                            if mine_or_other2 == 1:
                                grave = self.graves[deck_id]["mygrave"]
                            elif mine_or_other2 == 2:
                                grave = self.graves[deck_id]["othergrave"]
                            elif mine_or_other2 == 3:
                                grave = self.graves[deck_id]["commongrave"]
                            user_graves = grave
                            for user_grave in user_graves:
                                if place_unique_id == user_grave["place_unique_id"]:
                                    if self.check_not_effected(
                                        user_grave,
                                        effect_user,
                                        effect_kind,
                                        "grave",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        continue
                                    if monster_condition != "":
                                        tmp2 = {}
                                        tmp2["det"] = user_grave["det"]
                                        tmp2["mine_or_other"] = user_grave["det"]["owner"]
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "grave"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_grave[
                                            "place_unique_id"
                                        ]
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    if cost != 1:
                                        user_graves.remove(user_grave)
                                        user_grave["kind"] = effect_kind
                                        user_grave["user"] = mine_or_other3
                                        user_grave["user_det"] = effect_user
                                        return_tmp = {}
                                        return_tmp["x"] = 0
                                        return_tmp["y"] = 0
                                        return_tmp["place"] = "grave"
                                        return_tmp["mine_or_other"] = user_grave["owner"]
                                        return_tmp["deck_id"] = deck_id
                                        return_tmp["org_det"] = copy.deepcopy(
                                            user_grave
                                        )
                                        return_tmp[
                                            "det"
                                        ] = self.copy_monster_from_grave(
                                            user_grave, deck_id, mine_or_other3
                                        )
                                        return_value.append(return_tmp)
                                        if mine_or_other2 == 1:
                                            self.graves[deck_id][
                                                "mygrave"
                                            ] = user_graves
                                        elif mine_or_other2 == 2:
                                            self.graves[deck_id][
                                                "othergrave"
                                            ] = user_graves
                                        elif mine_or_other2 == 3:
                                            self.graves[deck_id][
                                                "commongrave"
                                            ] = user_graves
                                    else:
                                        cost_result = self.cost_result
                                        if "remove" not in cost_result:
                                            cost_result["remove"] = {}
                                        if "grave" not in cost_result["remove"]:
                                            cost_result["remove"]["grave"] = []
                                        place_unique_id = user_grave["place_unique_id"]
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["user"] = mine_or_other3
                                        cost_result_tmp[
                                            "user_det"
                                        ] = self.duel.cost_user
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["remove"]["grave"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                        return_tmp = {}
                                        return_tmp["x"] = 0
                                        return_tmp["y"] = 0
                                        return_tmp["place"] = "grave"
                                        return_tmp["mine_or_other"] = user_grave["owner"]
                                        return_tmp["deck_id"] = deck_id
                                        return_tmp["org_det"] = copy.deepcopy(
                                            user_grave
                                        )
                                        return_tmp[
                                            "det"
                                        ] = self.copy_monster_from_grave(
                                            user_grave, deck_id, mine_or_other3
                                        )
                                        return_value.append(return_tmp)
                        if place == "hand":
                            if mine_or_other2 == 1:
                                hand = self.hands[deck_id]["myhand"]
                            elif mine_or_other2 == 2:
                                hand = self.hands[deck_id]["otherhand"]
                            elif mine_or_other2 == 3:
                                hand = self.hands[deck_id]["commonhand"]
                            user_hands = hand
                            for user_hand in user_hands:
                                if place_unique_id == user_hand["place_unique_id"]:
                                    if self.check_not_effected(
                                        user_hand,
                                        effect_user,
                                        effect_kind,
                                        "hand",
                                        deck_id,
                                        0,
                                        0,
                                        mine_or_other3,
                                        cost,
                                    ):
                                        continue
                                    if monster_condition != "":
                                        tmp2 = {}
                                        tmp2["det"] = user_hand["det"]
                                        tmp2["mine_or_other"] = user_hand["det"]["owner"]
                                        tmp2["user"] = chain_user
                                        tmp2["place"] = "hand"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = user_hand[
                                            "place_unique_id"
                                        ]
                                        if not self.validate_answer(
                                            tmp2, monster_condition, "", duel
                                        ):
                                            continue
                                    if cost != 1:
                                        user_hands.remove(user_hand)
                                        user_hand["kind"] = effect_kind
                                        user_hand["user"] = mine_or_other3
                                        user_hand["user_det"] = effect_user
                                        return_tmp = {}
                                        return_tmp["x"] = 0
                                        return_tmp["y"] = 0
                                        return_tmp["place"] = "hand"
                                        return_tmp["user"] = chain_user
                                        return_tmp["mine_or_other"] = user_hand["owner"]
                                        return_tmp["deck_id"] = deck_id
                                        return_tmp["org_det"] = copy.deepcopy(user_hand)
                                        return_tmp["det"] = self.copy_monster_from_hand(
                                            user_hand, deck_id, mine_or_other3
                                        )
                                        return_value.append(return_tmp)
                                        if mine_or_other2 == 1:
                                            self.hands[deck_id]["myhand"] = user_hands
                                        elif mine_or_other2 == 2:
                                            self.hands[deck_id][
                                                "otherhand"
                                            ] = user_hands
                                        elif mine_or_other2 == 3:
                                            self.hands[deck_id][
                                                "commonhand"
                                            ] = user_hands
                                    else:
                                        cost_result = self.cost_result
                                        if "remove" not in cost_result:
                                            cost_result["remove"] = {}
                                        if "hand" not in cost_result["remove"]:
                                            cost_result["remove"]["hand"] = []
                                        place_unique_id = user_hand["place_unique_id"]
                                        cost_result_tmp = {}
                                        cost_result_tmp[
                                            "place_unique_id"
                                        ] = place_unique_id
                                        cost_result_tmp["user"] = mine_or_other3
                                        cost_result_tmp[
                                            "user_det"
                                        ] = self.duel.cost_user
                                        cost_result_tmp["deck_id"] = deck_id
                                        cost_result["remove"]["hand"].append(
                                            cost_result_tmp
                                        )
                                        self.cost_result = cost_result
                                        return_tmp = {}
                                        return_tmp["x"] = 0
                                        return_tmp["y"] = 0
                                        return_tmp["place"] = "hand"
                                        return_tmp["user"] = chain_user
                                        return_tmp["mine_or_other"] = user_hand["owner"]
                                        return_tmp["deck_id"] = deck_id
                                        return_tmp["org_det"] = copy.deepcopy(user_hand)
                                        return_tmp["det"] = self.copy_monster_from_hand(
                                            user_hand, deck_id, mine_or_other3
                                        )
                                        return_value.append(return_tmp)

            place_array_tmp = []
            for place in monster_effect_det["monster"]["place"]:
                place_tmp = place["det"].split("_")
                if place["det"] == "":
                    continue
                if place["and_or"] != "" and place_tmp[0] == "field":
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    continue
                else:
                    tmptmp = {}
                    tmptmp["and_or"] = place["and_or"]
                    tmptmp["det"] = place["det"]
                    place_array_tmp.append(tmptmp)
                    place_array = place_array_tmp
                    place_array_tmp = []
                deck_id = int(place_tmp[1])
                tmp_deck = None
                for tmp_i in range(
                    int(
                        self.calculate_boland(
                            monster_effect_det["min_equation_number"], None, False
                        )
                    )
                ):
                    tmp_i2 = 0
                    if monster_effect_text["field_x"]:
                        field = self.field
                        for str_x in monster_effect_text["field_x"]:
                            x = int(str_x)
                            y = int(monster_effect_text["field_y"][tmp_i2])
                            if cost != 1:
                                if field[x][y]["det"] is not None:
                                    place_unique_id = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.check_not_effected(
                                        field[x][y]["det"],
                                        effect_user,
                                        effect_kind,
                                        "field",
                                        0,
                                        x,
                                        y,
                                        field[x][y]["mine_or_other"],
                                        cost,
                                    ):
                                        org_det = copy.deepcopy(field[x][y]["det"])
                                        det = field[x][y]["det"].copy()
                                        field[x][y]["det"] = None
                                        self.effect += "field_move;"+str(x)+";"+str(y)+"|"
                                        self.effect2 += "field_move;"+str(x)+";"+str(y)+"|"
                                        if self.config.sort is True:
                                            field = self.sortField(field,y)
                                        det = self.copy_monster_from_field(
                                            det,
                                            field[x][y]["kind"],
                                            field[x][y]["mine_or_other"],
                                        )
                                        self.field = field
                                        det["kind"] = effect_kind
                                        det["user"] = int(field[x][y]["mine_or_other"])
                                        det["user_det"] = effect_user
                                else:
                                    field[x][y]["det"] = None
                                    if self.config.sort is True:
                                        field = self.sortField(field,y)
                                    self.field = field
                                    det = None
                                return_tmp = {}
                                return_tmp["x"] = x
                                return_tmp["y"] = y
                                return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                return_tmp["place"] = "field"
                                return_tmp["deck_id"] = 0
                                return_tmp["det"] = det
                                return_tmp["org_det"] = org_det
                                return_value.append(return_tmp)
                            else:
                                cost_result_tmp = {}
                                cost_result_tmp["x"] = x
                                cost_result_tmp["y"] = y
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result["remove"]["field"].append(cost_result_tmp)
                                self.cost_result = cost_result
                                det = self.copy_monster_from_field(
                                    det,
                                    field[x][y]["kind"],
                                    field[x][y]["mine_or_other"],
                                )
                                return_tmp = {}
                                return_tmp["x"] = x
                                return_tmp["y"] = y
                                return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                return_tmp["place"] = "field"
                                return_tmp["deck_id"] = 0
                                return_tmp["org_det"] = org_det
                                return_tmp["det"] = det
                                return_value.append(return_tmp)
                        continue
                    if (place_tmp[2] == "1" and effect_user == self.user) or (
                        place_tmp[2] == "2" and effect_user != self.user
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user != self.user) or (
                        place_tmp[2] == "2" and effect_user == self.user
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    if self.user == 1:
                        mine_or_other3 = mine_or_other2
                    else:
                        if mine_or_other2 == 1:
                            mine_or_other3 = 2
                        elif mine_or_other2 == 2:
                            mine_or_other3 = 1
                        else:
                            mine_or_other3 = 3

                    if place_tmp[0] == "deck":
                        if tmp_deck is None:
                            if mine_or_other2 == 1:
                                tmp_deck = self.get_deck_with_effect(
                                    self.decks[deck_id]["mydeck"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                deck = self.decks[deck_id]["mydeck"]
                            elif mine_or_other2 == 2:
                                tmp_deck = self.get_deck_with_effect(
                                    self.decks[deck_id]["otherdeck"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                deck = self.decks[deck_id]["otherdeck"]
                            elif mine_or_other2 == 3:
                                tmp_deck = self.get_deck_with_effect(
                                    self.decks[deck_id]["commondeck"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                deck = self.decks[deck_id]["commondeck"]
                            user_decks = deck
                        if not tmp_deck:
                            return return_value
                        if cost != 1:
                            move_flag = False
                            if monster_effect_text["move_how"] == 0:
                                org_user_deck = copy.deepcopy(user_decks[tmp_deck[0]])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks[tmp_deck[0]], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_deck
                                tmp2["mine_or_other"] = org_user_deck["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_deck[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_deck,
                                    effect_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    del user_decks[tmp_deck[0]]
                                    del tmp_deck[0]
                                    for tmpdecktmp in range(len(tmp_deck)):
                                        tmp_deck[tmpdecktmp] -= 1
                                    move_flag = True
                            elif monster_effect_text["move_how"] == 1:
                                org_user_deck = copy.deepcopy(user_decks[tmp_deck[-1]])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks[tmp_deck[-1]], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_deck
                                tmp2["mine_or_other"] = org_user_deck["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_deck[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_deck,
                                    effect_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    user_decks.pop(tmp_deck[-1])
                                    tmp_deck.pop()
                                    move_flag = True
                            else:
                                rand_i = random.randrange(len(tmp_deck))
                                range_i = tmp_deck[rand_i]
                                org_user_deck = copy.deepcopy(user_decks[range_i])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks[range_i], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_deck
                                tmp2["mine_or_other"] = org_user_deck["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "deck"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_deck[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_deck,
                                    effect_user,
                                    effect_kind,
                                    "deck",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    user_decks.pop(range_i)
                                    tmp_deck.pop(rand_i)
                                    for tmpdecktmp in range(len(tmp_deck) - rand_i):
                                        tmp_deck[tmpdecktmp + rand_i] -= 1
                                    move_flag = True
                            if move_flag is True:
                                if mine_or_other2 == 1:
                                    self.decks[deck_id]["mydeck"] = user_decks
                                elif mine_or_other2 == 2:
                                    self.decks[deck_id]["otherdeck"] = user_decks
                                elif mine_or_other2 == 3:
                                    self.decks[deck_id]["commondeck"] = user_decks
                                user_deck["kind"] = effect_kind
                                user_deck["user"] = mine_or_other3
                                user_deck["user_det"] = effect_user
                                return_tmp = {}
                                return_tmp["x"] = 0
                                return_tmp["y"] = 0
                                return_tmp["mine_or_other"] = user_deck["owner"]
                                return_tmp["place"] = "deck"
                                return_tmp["deck_id"] = deck_id
                                return_tmp["org_det"] = org_user_deck
                                return_tmp["det"] = user_deck
                                return_value.append(return_tmp)
                        else:
                            cost_result = self.cost_result
                            if monster_effect_text["move_how"] == 0:
                                org_user_deck = copy.deepcopy(user_decks[tmp_deck[0]])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks[tmp_deck[0]], deck_id, mine_or_other3
                                )
                                del user_decks[tmp_deck[0]]
                                del tmp_deck[0]
                                for tmpdecktmp in range(len(tmp_deck)):
                                    tmp_deck[tmpdecktmp] -= 1
                            elif monster_effect_text["move_how"] == 1:
                                org_user_deck = copy.deepcopy(user_decks[tmp_deck[-1]])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks[tmp_deck[-1]], deck_id, mine_or_other3
                                )
                                user_decks.pop(tmp_deck[-1])
                                tmp_deck.pop()
                            else:
                                rand_i = random.randrange(len(tmp_deck))
                                range_i = tmp_deck[rand_i]
                                org_user_deck = copy.deepcopy(user_decks[range_i])
                                user_deck = self.copy_monster_from_deck(
                                    user_decks[range_i], deck_id, mine_or_other3
                                )
                                user_decks.pop(range_i)
                                tmp_deck.pop(rand_i)
                                for tmpdecktmp in range(len(tmp_deck) - rand_i):
                                    tmp_deck[tmpdecktmp + rand_i] -= 1
                            tmp2 = {}
                            tmp2["det"] = org_user_deck
                            tmp2["mine_or_other"] = org_user_deck["owner"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = org_user_deck["place_unique_id"]
                            if not self.validate_answer(
                                tmp2, monster_effect_text_monster0, "", duel
                            ):
                                del tmp_deck[0]
                            elif not self.check_not_effected(
                                user_deck,
                                effect_user,
                                effect_kind,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            ):
                                if "remove" not in cost_result:
                                    cost_result["remove"] = {}
                                if "deck" not in cost_result["remove"]:
                                    cost_result["remove"]["deck"] = []
                                place_unique_id = user_deck["place_unique_id"]
                                cost_result_tmp = {}
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["user"] = mine_or_other3
                                cost_result_tmp["user"] = self.duel.cost_user
                                cost_result_tmp["deck_id"] = deck_id
                                cost_result["remove"]["deck"].append(cost_result_tmp)
                                self.cost_result = cost_result
                                return_tmp = {}
                                return_tmp["x"] = 0
                                return_tmp["y"] = 0
                                return_tmp["place"] = "deck"
                                return_tmp["mine_or_other"] = user_deck["owner"]
                                return_tmp["deck_id"] = deck_id
                                return_tmp["org_det"] = org_user_deck
                                return_tmp["det"] = user_deck
                                return_value.append(return_tmp)
                    elif place_tmp[0] == "grave":
                        if tmp_deck is None:
                            if mine_or_other2 == 1:
                                tmp_deck = self.get_grave_with_effect(
                                    self.graves[deck_id]["mygrave"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                grave = self.graves[deck_id]["mygrave"]
                            elif mine_or_other2 == 2:
                                tmp_deck = self.get_grave_with_effect(
                                    self.graves[deck_id]["othergrave"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                grave = self.graves[deck_id]["othergrave"]
                            elif mine_or_other2 == 3:
                                tmp_deck = self.get_grave_with_effect(
                                    self.graves[deck_id]["commongrave"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                grave = self.graves[deck_id]["commongrave"]

                        user_graves = grave
                        if not tmp_deck:
                            return return_value
                        if cost != 1:
                            move_flag = False
                            if monster_effect_text["move_how"] == 0:
                                org_user_grave = copy.deepcopy(user_graves[tmp_deck[0]])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves[tmp_deck[0]], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_grave
                                tmp2["mine_or_other"] = org_user_grave["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_grave[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_grave,
                                    effect_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    del user_graves[tmp_deck[0]]
                                    del tmp_deck[0]
                                    for tmpdecktmp in range(len(tmp_deck)):
                                        tmp_deck[tmpdecktmp] -= 1
                                    move_flag = True
                            elif monster_effect_text["move_how"] == 1:
                                org_user_grave = copy.deepcopy(
                                    user_graves[tmp_deck[-1]]
                                )
                                user_grave = self.copy_monster_from_grave(
                                    user_graves[tmp_deck[-1]], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_grave
                                tmp2["mine_or_other"] = org_user_grave["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_grave[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_grave,
                                    effect_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    user_graves.pop(tmp_deck[-1])
                                    tmp_deck.pop()
                            else:
                                rand_i = random.randrange(len(tmp_deck))
                                range_i = tmp_deck[rand_i]

                                org_user_grave = copy.deepcopy(user_graves[range_i])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves[range_i], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_grave
                                tmp2["mine_or_other"] = org_user_grave["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "grave"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_grave[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_grave,
                                    effect_user,
                                    effect_kind,
                                    "grave",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    user_graves.pop(range_i)
                                    tmp_deck.pop(rand_i)
                                    for tmpdecktmp in range(len(tmp_deck) - rand_i):
                                        tmp_deck[tmpdecktmp + rand_i] -= 1
                                    move_flag = True
                            if move_flag is True:
                                if mine_or_other2 == 1:
                                    self.graves[deck_id]["mygrave"] = user_graves
                                elif mine_or_other2 == 2:
                                    self.graves[deck_id]["othergrave"] = user_graves
                                elif mine_or_other2 == 3:
                                    self.graves[deck_id]["commongrave"] = user_graves
                                user_grave["kind"] = effect_kind
                                user_grave["user"] = mine_or_other3
                                user_grave["user_det"] = effect_user
                                return_tmp = {}
                                return_tmp["x"] = 0
                                return_tmp["y"] = 0
                                return_tmp["mine_or_other"] = user_grave["owner"]
                                return_tmp["place"] = "grave"
                                return_tmp["deck_id"] = deck_id
                                return_tmp["org_det"] = org_user_grave
                                return_tmp["det"] = user_grave
                                return_value.append(return_tmp)
                        else:
                            cost_result = self.cost_result
                            if monster_effect_text["move_how"] == 0:
                                org_user_grave = copy.deepcopy(user_graves[tmp_deck[0]])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves[tmp_deck[0]], deck_id, mine_or_other3
                                )
                                del user_graves[tmp_deck[0]]
                                del tmp_deck[0]
                                for tmpdecktmp in range(len(tmp_deck)):
                                    tmp_deck[tmpdecktmp] -= 1
                            elif monster_effect_text["move_how"] == 1:
                                org_user_grave = copy.deepcopy(
                                    user_graves[tmp_deck[-1]]
                                )
                                user_grave = self.copy_monster_from_grave(
                                    user_graves[tmp_deck[-1]], deck_id, mine_or_other3
                                )
                                user_graves.pop(tmp_deck[-1])
                                tmp_deck.pop[-1]
                            else:
                                rand_i = random.randrange(len(tmp_deck))
                                range_i = tmp_deck[rand_i]
                                org_user_grave = copy.deepcopy(user_graves[range_i])
                                user_grave = self.copy_monster_from_grave(
                                    user_graves[range_i], deck_id, mine_or_other3
                                )
                                user_graves.pop(range_i)
                                tmp_deck.pop[rand_i]
                                for tmpdecktmp in range(len(tmp_deck) - rand_i):
                                    tmp_deck[tmpdecktmp + rand_i] -= 1
                            tmp2 = {}
                            tmp2["det"] = org_user_grave
                            tmp2["mine_or_other"] = org_user_grave["owner"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = org_user_grave["place_unique_id"]
                            if not self.validate_answer(
                                tmp2, monster_effect_text_monster0, "", duel
                            ):
                                del tmp_deck[0]
                            elif not self.check_not_effected(
                                user_grave,
                                effect_user,
                                effect_kind,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            ):
                                if "remove" not in cost_result:
                                    cost_result["remove"] = {}
                                if "grave" not in cost_result["remove"]:
                                    cost_result["remove"]["grave"] = []
                                place_unique_id = user_grave["place_unique_id"]
                                cost_result_tmp = {}
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["user"] = mine_or_other3
                                cost_result_tmp["user_det"] = self.duel.cost_user
                                cost_result_tmp["deck_id"] = deck_id
                                cost_result["remove"]["grave"].append(cost_result_tmp)
                                self.cost_result = cost_result
                                return_tmp = {}
                                return_tmp["x"] = 0
                                return_tmp["y"] = 0
                                return_tmp["mine_or_other"] = user_grave["owner"]
                                return_tmp["place"] = "grave"
                                return_tmp["deck_id"] = deck_id
                                return_tmp["org_det"] = org_user_grave
                                return_tmp["det"] = user_grave
                                return_value.append(return_tmp)
                    elif place_tmp[0] == "hand":
                        if tmp_deck is None:
                            if mine_or_other2 == 1:
                                tmp_deck = self.get_hand_with_effect(
                                    self.hands[deck_id]["myhand"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                hand = self.hands[deck_id]["myhand"]
                            elif mine_or_other2 == 2:
                                tmp_deck = self.get_hand_with_effect(
                                    self.hands[deck_id]["otherhand"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                hand = self.hands[deck_id]["otherhand"]
                            elif mine_or_other2 == 3:
                                tmp_deck = self.get_hand_with_effect(
                                    self.hands[deck_id]["commonhand"],
                                    monster_effect_det,
                                    effect_kind,
                                    exclude,
                                    effect_user,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                )
                                hand = self.hands[deck_id]["commonhand"]
                            user_hands = hand
                        if not tmp_deck:
                            return return_value
                        if cost != 1:
                            move_flag = False
                            if monster_effect_text["move_how"] == 0:
                                org_user_hand = copy.deepcopy(user_hands[tmp_deck[0]])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands[tmp_deck[0]], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_hand
                                tmp2["mine_or_other"] = org_user_hand["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_hand[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_hand,
                                    effect_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    del user_hands[tmp_deck[0]]
                                    del tmp_deck[0]
                                    for tmpdecktmp in range(len(tmp_deck)):
                                        tmp_deck[tmpdecktmp] -= 1
                                    move_flag = True
                            elif monster_effect_text["move_how"] == 1:
                                org_user_hand = copy.deepcopy(user_hands[tmp_deck[-1]])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands[tmp_deck[-1]], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_hand
                                tmp2["mine_or_other"] = org_user_hand["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_hand[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_hand,
                                    effect_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    user_hands.pop(tmp_deck[-1])
                                    tmp_deck.pop()
                                    move_flag = True
                            else:

                                rand_i = random.randrange(len(tmp_deck))
                                range_i = tmp_deck[rand_i]
                                org_user_hand = copy.deepcopy(user_hands[range_i])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands[range_i], deck_id, mine_or_other3
                                )
                                tmp2 = {}
                                tmp2["det"] = org_user_hand
                                tmp2["mine_or_other"] = org_user_hand["owner"]
                                tmp2["user"] = chain_user
                                tmp2["place"] = "hand"
                                tmp2["deck_id"] = deck_id
                                tmp2["x"] = 0
                                tmp2["y"] = 0
                                tmp2["place_unique_id"] = org_user_hand[
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_text_monster0, "", duel
                                ):
                                    del tmp_deck[0]
                                elif not self.check_not_effected(
                                    user_hand,
                                    effect_user,
                                    effect_kind,
                                    "hand",
                                    deck_id,
                                    0,
                                    0,
                                    mine_or_other3,
                                    cost,
                                ):
                                    user_hands.pop(range_i)
                                    tmp_deck.pop(rand_i)
                                    move_flag = True
                                    for tmpdecktmp in range(len(tmp_deck) - rand_i):
                                        tmp_deck[tmpdecktmp + rand_i] -= 1
                            if move_flag is True:
                                if mine_or_other2 == 1:
                                    self.hands[deck_id]["myhand"] = user_hands
                                elif mine_or_other2 == 2:
                                    self.hands[deck_id]["otherhand"] = user_hands
                                elif mine_or_other2 == 3:
                                    self.hands[deck_id]["commonhand"] = user_hands
                                user_hand["kind"] = effect_kind
                                user_hand["user"] = mine_or_other3
                                user_hand["user_det"] = effect_user
                                return_tmp = {}
                                return_tmp["x"] = 0
                                return_tmp["y"] = 0
                                return_tmp["place"] = "hand"
                                return_tmp["user"] = chain_user
                                return_tmp["mine_or_other"] = user_hand["owner"]
                                return_tmp["deck_id"] = deck_id
                                return_tmp["org_det"] = org_user_hand
                                return_tmp["det"] = user_hand
                                return_value.append(return_tmp)
                        else:
                            cost_result = self.cost_result
                            if monster_effect_text["move_how"] == 0:
                                org_user_hand = copy.deepcopy(user_hands[tmp_deck[0]])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands[tmp_deck[0]], deck_id, mine_or_other3
                                )
                                del user_hands[tmp_deck[0]]
                                del tmp_deck[0]
                                for tmpdecktmp in range(len(tmp_deck)):
                                    tmp_deck[tmpdecktmp] -= 1
                            elif monster_effect_text["move_how"] == 1:
                                org_user_hand = copy.deepcopy(user_hands[tmp_deck[-1]])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands[tmp_deck[-1]], deck_id, mine_or_other3
                                )
                                user_hands.pop(tmp_deck[-1])
                                tmp_deck.pop()
                            else:
                                rand_i = random.randrange(len(tmp_deck))
                                range_i = tmp_deck[rand_i]

                                org_user_hand = copy.deepcopy(user_hands[range_i])
                                user_hand = self.copy_monster_from_hand(
                                    user_hands[range_i], deck_id, mine_or_other3
                                )
                                user_hands.pop(range_i)
                                tmp_deck.pop(rand_i)
                                for tmpdecktmp in range(len(tmp_deck) - rand_i):
                                    tmp_deck[tmpdecktmp + rand_i] -= 1
                            tmp2 = {}
                            tmp2["det"] = org_user_hand
                            tmp2["mine_or_other"] = org_user_hand["owner"]
                            tmp2["user"] = chain_user
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = org_user_hand["place_unique_id"]
                            if not self.validate_answer(
                                tmp2, monster_effect_text_monster0, "", duel
                            ):
                                del tmp_deck[0]
                            if not self.check_not_effected(
                                user_hand,
                                effect_user,
                                effect_kind,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other3,
                                cost,
                            ):
                                if "remove" not in cost_result:
                                    cost_result["remove"] = {}
                                if "hand" not in cost_result["remove"]:
                                    cost_result["remove"]["hand"] = []
                                place_unique_id = user_hand["place_unique_id"]
                                cost_result_tmp = {}
                                cost_result_tmp["place_unique_id"] = place_unique_id
                                cost_result_tmp["user"] = mine_or_other3
                                cost_result_tmp["user_det"] = self.duel.cost_user
                                cost_result_tmp["deck_id"] = deck_id
                                cost_result["remove"]["hand"].append(cost_result_tmp)
                                self.cost_result = cost_result
                                return_tmp = {}
                                return_tmp["x"] = 0
                                return_tmp["y"] = 0
                                return_tmp["place"] = "hand"
                                return_tmp["mine_or_other"] = user_hand["owner"]
                                return_tmp["deck_id"] = deck_id
                                return_tmp["org_det"] = org_user_hand
                                return_tmp["det"] = self.copy_monster_from_hand(
                                    user_hand, deck_id, mine_or_other3
                                )
                                return_value.append(return_tmp)
                    elif place_tmp[0] == "field":
                        field_size = FieldSize.objects.get(id=1)
                        field = self.field
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for x in range(field_x):
                            for y in range(field_size.field_y):
                                flag_field_place = False
                                for place_tmp2 in place_array:
                                    and_or = place_tmp2["and_or"]
                                    det = place_tmp2["det"]
                                    splitted_det = det.split("_")
                                    kind = splitted_det[1]
                                    # jsonに入っているデータは相対的
                                    mine_or_other_relative = splitted_det[2]
                                    if (
                                        mine_or_other_relative == "1"
                                        and effect_user == 1
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == 2
                                    ):
                                        mine_or_other2 = 1
                                    elif (
                                        mine_or_other_relative == "1"
                                        and effect_user == 2
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == 1
                                    ):
                                        mine_or_other2 = 2
                                    else:
                                        mine_or_other2 = 3
                                    if self.field_free is False:
                                        kinds = field[x][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    else:
                                        kinds = field[0][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    tmp = kinds.split("_")
                                    if (
                                        str(kind) in tmp
                                        and mine_or_other_field == mine_or_other2
                                    ):
                                        flag_field_place = True
                                    else:
                                        if flag_field_place is False:
                                            flag_field_place = False
                                if flag_field_place is False:
                                    continue
                                if field[x][y]["det"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["org_det"] = field[x][y]["det"]
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = effect_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_det["monster"], exclude, duel
                                ):
                                    continue
                                if cost != 1:
                                    if field[x][y]["det"] is not None:
                                        det = field[x][y]["det"].copy()
                                        org_det = det
                                        field[x][y]["det"] = None
                                        self.effect += "field_move;"+str(x)+";"+str(y)+"|"
                                        self.effect2 += "field_move;"+str(x)+";"+str(y)+"|"
                                        det = self.copy_monster_from_field(
                                            det,
                                            field[x][y]["kind"],
                                            field[x][y]["mine_or_other"],
                                        )
                                        det["kind"] = effect_kind
                                        det["user"] = int(field[x][y]["mine_or_other"])
                                        det["user_det"] = effect_user
                                    else:
                                        field[x][y]["det"] = None
                                        det = None
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                    return_tmp["user"] = field[x][y]["mine_or_other"]
                                    return_tmp["place"] = "field"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = org_det
                                    return_tmp["det"] = det
                                    return_value.append(return_tmp)
                                else:
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result["remove"]["field"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    det = self.copy_monster_from_field(
                                        det,
                                        field[x][y]["kind"],
                                        field[x][y]["mine_or_other"],
                                    )
                                    return_tmp = {}
                                    return_tmp["x"] = x
                                    return_tmp["y"] = y
                                    return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                    return_tmp["user"] = field[x][y]["mine_or_other"]
                                    return_tmp["place"] = "field"
                                    return_tmp["deck_id"] = 0
                                    return_tmp["org_det"] = org_det
                                    return_tmp["det"] = det
                                    return_value.append(return_tmp)
                        if self.config.sort is True:
                            field = self.sortAllField(field)
                        self.field = field
                    elif place_tmp[0] == "under":
                        field_size = FieldSize.objects.get(id=1)
                        field = self.field
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for x in range(field_x):
                            for y in range(field_size.field_y):
                                flag_field_place = True
                                current_and_or = "and"
                                for place_tmp2 in place_array:
                                    and_or = place_tmp2["and_or"]
                                    det = place_tmp2["det"]
                                    splitted_det = det.split("_")
                                    kind = splitted_det[1]
                                    # jsonに入っているデータは相対的
                                    mine_or_other_relative = splitted_det[2]
                                    if (
                                        mine_or_other_relative == "1"
                                        and effect_user == 1
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == 2
                                    ):
                                        mine_or_other2 = 1
                                    elif (
                                        mine_or_other_relative == "1"
                                        and effect_user == 2
                                    ) or (
                                        mine_or_other_relative == "2"
                                        and effect_user == 1
                                    ):
                                        mine_or_other2 = 2
                                    else:
                                        mine_or_other2 = 3
                                    if self.field_free is False:
                                        kinds = field[x][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    else:
                                        kinds = field[0][y]["kind"]
                                        mine_or_other_field = field[x][y][
                                            "mine_or_other"
                                        ]
                                    tmp = kinds.split("_")
                                    if current_and_or == "and":
                                        if (
                                            str(kind) in tmp
                                            and mine_or_other_field == mine_or_other2
                                        ):
                                            if flag_field_place is True:
                                                flag_field_place = True
                                        else:
                                            flag_field_place = False
                                    elif current_and_or == "or":
                                        if (
                                            str(kind) in tmp
                                            and mine_or_other_field == mine_or_other2
                                        ):
                                            flag_field_place = True
                                        else:
                                            if flag_field_place is False:
                                                flag_field_place = False
                                    current_and_or = and_or
                                if flag_field_place is False:
                                    continue
                                if field[x][y]["det"] is None:
                                    continue
                                if field[x][y]["det"]["under"] is None:
                                    continue
                                if self.check_not_effected(
                                    field[x][y]["det"],
                                    effect_user,
                                    effect_kind,
                                    "field",
                                    0,
                                    x,
                                    y,
                                    field[x][y]["mine_or_other"],
                                    cost,
                                ):
                                    continue
                                tmp2 = {}
                                tmp2["org_det"] = field[x][y]["det"]
                                tmp2["det"] = field[x][y]["det"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = effect_user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["place_unique_id"] = field[x][y]["det"][
                                    "place_unique_id"
                                ]
                                if not self.validate_answer(
                                    tmp2, monster_effect_det["monster"], exclude, duel
                                ):
                                    continue
                                if cost != 1:
                                    if field[x][y]["det"] is not None:
                                        for under in field[x][y]["det"]["under"]:
                                            under = self.copy_monster_from_under(under)
                                            under["kind"] = effect_kind
                                            under["user"] = int(
                                                field[x][y]["mine_or_other"]
                                            )
                                            under["user_det"] = effect_user
                                            return_tmp = {}
                                            return_tmp["x"] = x
                                            return_tmp["y"] = y
                                            return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                            return_tmp["user"] = field[x][y]["mine_or_other"]
                                            return_tmp["place"] = "under"
                                            return_tmp["deck_id"] = 0
                                            return_tmp["org_det"] = under
                                            return_tmp["det"] = under
                                            return_value.append(return_tmp)
                                        del field[x][y]["det"]["under"]
                                        self.field = field
                                else:
                                    cost_result_tmp = {}
                                    cost_result_tmp["x"] = x
                                    cost_result_tmp["y"] = y
                                    cost_result_tmp["place_unique_id"] = place_unique_id
                                    cost_result["remove"]["under"].append(
                                        cost_result_tmp
                                    )
                                    self.cost_result = cost_result
                                    for under in field[x][y]["det"]["under"]:
                                        return_tmp = {}
                                        return_tmp["x"] = x
                                        return_tmp["y"] = y
                                        return_tmp["mine_or_other"] = field[x][y]["mine_or_other"]
                                        return_tmp["user"] = field[x][y]["mine_or_other"]
                                        return_tmp["place"] = "under"
                                        return_tmp["deck_id"] = 0
                                        return_tmp["org_det"] = under
                                        return_tmp["det"] = under
                                        return_value.append(return_tmp)
                                        
        return return_value

    def move_to_monster_eternal(self, move_tos, effect_kind, user, monster_effect):
        self.move_to_monster(move_tos, effect_kind, 2, user, monster_effect)

    def move_to_monster_cost(self, move_tos, cost_kind):
        self.move_to_monster(move_tos, cost_kind, 1)

    def move_to_under_monster_cost(self, move_tos, effect_kind):
        return self.move_to_under_monster(move_tos, effect_kind, 1)

    def move_to_under_monster(self, move_tos, effect_kind, cost=0):
        if not move_tos:
            return   
        duel = self.duel
        if cost == 0:
            chain_det = json.loads(duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_det = json.loads(monster_effect.monster_effect)
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
            cost_user = user
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost2 = cost_wrapper.cost
            monster_effect_det = json.loads(cost2.cost)

        i = 0
        flag_change_how = monster_effect_det["flag_change_how"]
        flag_change_val = monster_effect_det["flag_change_val"]
        variable_names = []
        if len(monster_effect_det["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect_det:
                if monster_effect_det["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect_det["monster_variable_change_name"])):
                variable_name = monster_effect_det["monster_variable_change_name"][
                    index
                ]
                if "monster_variable_change_initial" in monster_effect:
                    ini = monster_effect["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect:
                    add = monster_effect["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect_det["monster_variable_change_val"][index],
                        None,
                        False,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        if (
            "as_monster_condition_to" in monster_effect_det
            and monster_effect_det["as_monster_condition_to"] != ""
        ):
            as_monster_effect = monster_effect_det["as_monster_condition_to"]
            tmp = self.mess
            cost_tmp = self.cost
            timing_tmp = self.timing_mess
            if str(duel.chain - 1) not in tmp:
                tmp[str(duel.chain - 1)] = {}
            if as_monster_effect[0] == "~":
                if duel.in_cost is True:
                    place1 = cost_tmp[str(self.tmp_chain)][as_monster_effect]
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][as_monster_effect]
            elif as_monster_effect[0] == "%":
                place1 = timing_tmp[as_monster_effect]
            else:
                place1 = tmp[str(duel.chain - 1)][as_monster_effect]
            for place2 in place1:
                move_to = move_tos[-1]
                org_move_to = move_to["org_det"]
                move_to_org = move_to
                move_to = move_to["det"]
                if move_to is None:
                    continue
                move_to["eternal"] = []
                move_to["eternal"].append(change_val_eternal)
                if flag_change_how != "0":
                    if "flag" not in move_to:
                        move_to["flag"] = 0
                    if flag_change_how == "1":
                        move_to["flag"] += int(flag_change_val)
                    elif flag_change_how == "2":
                        move_to["flag"] -= int(flag_change_val)
                    elif flag_change_how == "3":
                        move_to["flag"] = int(flag_change_val)
                    elif flag_change_how == "4":
                        move_to["flag"] = int(flag_change_val) | move_to["flag"]
                    elif flag_change_how == "5":
                        move_to["flag"] -= (int(flag_change_val)) & move_to["flag"]
                i += 1
                if place2["place"] == "field":
                    x = int(place2["x"])
                    y = int(place2["y"])
                    field = self.field
                    if cost == 1:
                        cost_result = self.cost_result
                        if "under" not in cost_result:
                            cost_result["under"] = {}

                        if "field" not in cost_result["under"]:
                            cost_result["under"]["field"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["user_det"] = cost_user
                        cost_result_tmp["x"] = x
                        cost_result_tmp["y"] = y
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result["under"]["field"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        move_to_tmp = move_to.copy()
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id"]
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = field[x][y]["mine_or_other"]
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            check_cost[str(duel.chain - 1)]["trigger"] = []
                            check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        move_to = copy.deepcopy(move_to)
                        if "under" not in field[x][y]["det"]:
                            field[x][y]["det"]["under"] = []
                        field[x][y]["det"] = self.copy_monster_to_under(
                            move_to,
                            0,
                            x,
                            y,
                            field[x][y]["mine_or_other"],
                            variable_names,
                            field[x][y]["det"],
                        )
                        self.raise_trigger(
                            field[x][y]["det"],
                            move_to_org,
                            org_move_to,
                            "effect",
                            "field",
                            user,
                            field[x][y]["mine_or_other"],
                            None,
                            effect_kind,
                            x,
                            y,
                        )
                        self.field = field
        if (
            "place_to" in monster_effect_det
            and monster_effect_det["place_to"]["0"] != ""
        ):
            place_org = monster_effect_det["place_to"]["0"]
            tmp = self.mess
            if str(duel.chain - 1) not in tmp:
                tmp[str(duel.chain - 1)] = {}
            for move_to in move_tos:
                place = place_org
                # 行き先書きかえ
                tmp_dest = self.check_change_dest(
                    move_to["det"],
                    user,
                    move_to["place"],
                    move_to["deck_id"],
                    move_to["x"],
                    move_to["y"],
                    place,
                    move_to["mine_or_other"]
                )
                if tmp_dest:
                    place = tmp_dest
                org_move_to = move_to["org_det"]
                move_to_org = move_to
                move_to = move_to["det"]
                if move_to is None:
                    continue
                if change_val_eternal is not None:
                    if "eternal" not in move_to:
                        move_to["eternal"] = []
                    move_to["eternal"].append(change_val_eternal)
                if flag_change_how != "0":
                    if "flag" not in move_to:
                        move_to["flag"] = 0
                    if flag_change_how == "1":
                        move_to["flag"] += int(flag_change_val)
                    elif flag_change_how == "2":
                        move_to["flag"] -= int(flag_change_val)
                    elif flag_change_how == "3":
                        move_to["flag"] = int(flag_change_val)
                    elif flag_change_how == "4":
                        move_to["flag"] = int(flag_change_val) | move_to["flag"]
                    elif flag_change_how == "5":
                        move_to["flag"] -= (int(flag_change_val)) & move_to["flag"]
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if (place_tmp[2] == "1" and user == self.user) or (
                    place_tmp[2] == "2" and user != self.user
                ):
                    mine_or_other2 = 1
                elif (place_tmp[2] == "1" and user != self.user) or (
                    place_tmp[2] == "2" and user == self.user
                ):
                    mine_or_other2 = 2
                elif place_tmp[2] == "3":
                    mine_or_other2 = 3
                elif place_tmp[2] == "4" and 1 == self.user:
                    mine_or_other2 = move_to["owner"]
                    mine_or_other3 = move_to["owner"]
                elif place_tmp[2] == "4" and 1 != self.user:
                    mine_or_other3 = move_to["owner"]
                    if move_to["owner"] == 1:
                        mine_or_other2 = 2
                    elif move_to["owner"] == 2:
                        mine_or_other2 = 1

                if (place_tmp[2] == "1" and user == 1) or (
                    place_tmp[2] == "2" and user == 2
                ):
                    mine_or_other3 = 1
                elif (place_tmp[2] == "1" and user == 2) or (
                    place_tmp[2] == "2" and user == 1
                ):
                    mine_or_other3 = 2
                elif place_tmp[2] == "3":
                    mine_or_other3 = 3
                if self.user == 1:
                    mine_or_other4 = mine_or_other2
                else:
                    if mine_or_other2 == 1:
                        mine_or_other4 = 2
                    elif mine_or_other2 == 2:
                        mine_or_other4 = 1
                    else:
                        mine_or_other4 = 3
                if place_tmp[0] == "deck":
                    if mine_or_other2 == 1:
                        deck = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        deck = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        deck = self.decks[deck_id]["commondeck"]
                    user_decks = deck
                    move_to = copy.deepcopy(move_to)
                    move_to = self.copy_monster_to_deck(
                        move_to, deck_id, mine_or_other3, variable_names
                    )
                    move_to_tmp = copy.deepcopy(move_to)
                    if cost == 1:
                        cost_result = self.cost_result
                        if "under" not in cost_result:
                            cost_result["under"] = {}

                        if "deck" not in cost_result["under"]:
                            cost_result["under"]["deck"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result_tmp["user"] = mine_or_other4
                        cost_result_tmp["user_det"] = cost_user
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["how"] = monster_effect_det["move_how_to"]
                        cost_result["under"]["deck"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id_from"]
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            check_cost[str(duel.chain - 1)]["trigger"] = []
                            check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        self.raise_trigger(
                            move_to,
                            move_to_org,
                            org_move_to,
                            "effect",
                            "deck",
                            user,
                            mine_or_other4,
                            deck_id,
                            effect_kind,
                            None,
                            None,
                        )
                        if (
                            monster_effect_det["move_how_to"] == 0
                            or len(user_decks) == 0
                        ):
                            if "under" not in user_decks[0]:
                                user_decks[0]["under"] = []
                            user_decks[0]["under"].append(move_to)
                        elif monster_effect_det["move_how_to"] == 1:
                            if "under" not in user_decks[len(user_decks) - 1]:
                                user_decks[len(user_decks) - 1]["under"] = []
                            user_decks[len(user_decks) - 1]["under"].append(move_to)
                        else:
                            range_i = random.randrange(len(user_decks))
                            if "under" not in user_decks[range_i]:
                                user_decks[range_i]["under"] = []
                            user_decks[range_i]["under"].append(move_to)
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        elif mine_or_other2 == 3:
                            self.decks[deck_id]["commondeck"] = user_decks
                if place_tmp[0] == "grave":
                    if mine_or_other2 == 1:
                        grave = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        grave = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        grave = self.graves[deck_id]["commongrave"]
                    user_graves = grave
                    move_to_tmp = copy.deepcopy(move_to)
                    move_to = copy.deepcopy(move_to)
                    move_to = self.copy_monster_to_grave(
                        move_to, deck_id, mine_or_other3, variable_names
                    )
                    if cost == 1:
                        cost_result = self.cost_result
                        if "under" not in cost_result:
                            cost_result["under"] = {}

                        if "grave" not in cost_result["under"]:
                            cost_result["under"]["grave"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result_tmp["user"] = mine_or_other4
                        cost_result_tmp["user_det"] = user
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["how"] = monster_effect_det["move_how_to"]
                        cost_result_tmp["kind"] = effect_kind
                        cost_result["under"]["grave"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id_from"]
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["mine_or_other"] = mine_or_other3
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            check_cost[str(duel.chain - 1)]["trigger"] = []
                            check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        self.raise_trigger(
                            move_to,
                            move_to_org,
                            org_move_to,
                            "effect",
                            "grave",
                            user,
                            mine_or_other4,
                            deck_id,
                            effect_kind,
                            None,
                            None,
                        )
                        if (
                            monster_effect_det["move_how_to"] == 0
                            or len(user_graves) == 0
                        ):
                            if "under" not in user_graves[0]:
                                user_graves[0]["under"] = []
                            user_graves[0]["under"].append(move_to)
                        elif monster_effect_det["move_how_to"] == 1:
                            if "under" not in user_graves[len(user_graves) - 1]:
                                user_graves[len(user_graves) - 1]["under"] = []
                            user_graves[len(user_graves) - 1]["under"].append(move_to)
                        else:
                            range_i = random.randrange(len(user_graves))
                            if "under" not in user_graves[range_i]:
                                user_graves[range_i]["under"] = []
                            user_graves[range_i]["under"].append(move_to)
                        if mine_or_other2 == 1:
                            self.graves[deck_id]["mygrave"] = user_graves
                        elif mine_or_other2 == 2:
                            self.graves[deck_id]["othergrave"] = user_graves
                        elif mine_or_other2 == 3:
                            self.graves[deck_id]["commongrave"] = user_graves
                if place_tmp[0] == "hand":
                    if mine_or_other2 == 1:
                        hand = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        hand = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        hand = self.hands[deck_id]["commonhand"]
                    user_hands = hand
                    move_to_tmp = copy.deepcopy(move_to)
                    move_to = copy.deepcopy(move_to)
                    move_to = self.copy_monster_to_hand(
                        move_to, deck_id, mine_or_other3, variable_names
                    )
                    if cost == 1:
                        if (
                            org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id_from"]
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            check_cost[str(duel.chain - 1)]["trigger"] = []
                            check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        cost_result = self.cost_result
                        if "under" not in cost_result:
                            cost_result["under"] = {}

                        if "hand" not in cost_result["under"]:
                            cost_result["under"]["hand"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result_tmp["user"] = mine_or_other4
                        cost_result_tmp["user_det"] = user
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["how"] = monster_effect_det["move_how_to"]
                        cost_result["under"]["hand"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    if cost == 0:
                        if (
                            monster_effect_det["move_how_to"] == 0
                            or len(user_hands) == 0
                        ):
                            if "under" not in user_hands[0]:
                                user_hands[0]["under"] = []
                            user_hands[0]["under"].append(move_to)
                        elif monster_effect_det["move_how_to"] == 1:
                            if "under" not in user_hands[len(user_hands) - 1]:
                                user_hands[len(user_hands) - 1]["under"] = []
                            user_hands[len(user_hands) - 1]["under"].append(move_to)
                        else:
                            range_i = random.randrange(len(user_hands))
                            if "under" not in user_hands[range_i]:
                                user_hands[range_i]["under"] = []
                            user_hands[range_i]["under"].append(move_to)
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        elif mine_or_other2 == 3:
                            self.hands[deck_id]["commonhand"] = user_hands
                        self.raise_trigger(
                            move_to,
                            move_to_org,
                            org_move_to,
                            "effect",
                            "hand",
                            user,
                            mine_or_other4,
                            deck_id,
                            effect_kind,
                            None,
                            None,
                        )
                if place_tmp[0] == "field":
                    if "field_x_to" in monster_effect_det:
                        field = self.field
                        x = int(monster_effect_det["field_x_to"])
                        y = int(monster_effect_det["field_y_to"])
                        move_to_tmp = move_to.copy()
                        if cost == 1:
                            if (
                                org_move_to["place_unique_id"]
                                == tmp[str(duel.chain - 1)]["trigger"][0][
                                    "place_unique_id"
                                ]
                            ):
                                check_cost = self.cost
                                tmp2 = {}
                                if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                    tmp2["from_x"] = org_trigger["from_x"]
                                    tmp2["from_y"] = org_trigger["from_y"]
                                    tmp2["det_from"] = org_trigger["det_from"]
                                    tmp2["place_unique_id_from"] = org_trigger[
                                        "place_unique_id_from"
                                    ]
                                    tmp2["place_from"] = org_trigger["place_from"]
                                    tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                                else:
                                    tmp2["from_x"] = move_to_org["x"]
                                    tmp2["from_y"] = move_to_org["y"]
                                    tmp2["det_from"] = move_to_org["det"]
                                    tmp2["place_unique_id_from"] = move_to_org["det"][
                                        "place_unique_id"
                                    ]
                                    tmp2["place_from"] = move_to_org["place"]
                                    tmp2["deck_id_from"] = move_to_org["deck_id_from"]
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["det"] = move_to
                                tmp2["det"]["place_unique_id"] = move_to_tmp[
                                    "place_unique_id"
                                ]
                                tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = field[x][y]["mine_or_other"]
                                tmp2["user_det"] = user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                check_cost[str(duel.chain - 1)]["trigger"] = []
                                check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                                tmp[str(duel.chain - 1)]["trigger"] = []
                                tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                                self.cost = check_cost
                                self.mess = tmp
                            cost_result = self.cost_result
                            if "under" not in cost_result:
                                cost_result["under"] = {}

                            if "field" not in cost_result["under"]:
                                cost_result["under"]["field"] = []
                            if "field_x_to" in monster_effect_det:
                                field = self.field
                            x = int(monster_effect_det["field_x_to"])
                            y = int(monster_effect_det["field_y_to"])
                            cost_result_tmp = {}
                            cost_result_tmp["x"] = x
                            cost_result_tmp["y"] = y
                            cost_result_tmp["kind"] = effect_kind
                            cost_result_tmp["move_from"] = json.dumps(move_to_org)
                            cost_result_tmp["det"] = json.dumps(move_to)
                            cost_result["under"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                        else:
                            move_to = copy.deepcopy(move_to)
                            if "under" not in field[x][y]["det"]:
                                field[x][y]["det"]["under"] = []
                            field[x][y]["det"]["under"].append(move_to)
                            field[x][y]["det"] = self.copy_monster_to_field(
                                move_to,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                variable_names,
                            )
                            self.raise_trigger(
                                field[x][y]["det"],
                                move_to_org,
                                org_move_to,
                                "effect",
                                "field",
                                user,
                                field[x][y]["mine_or_other"],
                                None,
                                effect_kind,
                                x,
                                y,
                            )
                            self.field = field

    def move_to_over_monster(self, move_tos, effect_kind, cost=0):
        duel = self.duel
        if cost == 0:
            chain_det = json.loads(duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_det = json.loads(monster_effect.monster_effect)
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
            cost_user = user
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost2 = cost_wrapper.cost
            monster_effect_det = json.loads(cost2.cost)

        i = 0
        flag_change_how = monster_effect_det["flag_change_how"]
        flag_change_val = monster_effect_det["flag_change_val"]
        variable_names = []
        if len(monster_effect_det["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect_det:
                if monster_effect_det["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect_det[
                "monster_variable_change_life"
            ][0]
            change_val_eternal["monster_variable_change_life_length"] = monster_effect_det[
                "monster_variable_change_life_length"
            ][0]
            change_val_eternal["effect_kind"] = monster_effect_det[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect_det["monster_variable_change_name"])):
                variable_name = monster_effect_det["monster_variable_change_name"][
                    index
                ]
                if "monster_variable_change_initial" in monster_effect_det:
                    ini = monster_effect_det["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect_det:
                    add = monster_effect_det["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect_det["monster_variable_change_val"][index],
                        None,
                        False,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        if (
            "as_monster_condition_to" in monster_effect_det
            and monster_effect_det["as_monster_condition_to"] != ""
        ):
            as_monster_effect = monster_effect_det["as_monster_condition_to"]
            tmp = self.mess
            cost_tmp = self.cost
            timing_tmp = self.timing_mess
            if str(duel.chain - 1) not in tmp:
                tmp[str(duel.chain - 1)] = {}
            if as_monster_effect[0] == "~":
                if duel.in_cost is True:
                    place1 = cost_tmp[str(self.tmp_chain)][as_monster_effect]
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][as_monster_effect]
            elif as_monster_effect[0] == "%":
                place1 = timing_tmp[as_monster_effect]
            else:
                place1 = tmp[str(duel.chain - 1)][as_monster_effect]
            for place2 in place1:
                move_to = move_tos[i]
                org_move_to = move_to["org_det"]
                move_to_org = move_to
                move_to = move_to["det"]
                if move_to is None:
                    continue
                move_to["eternal"] = []
                move_to["eternal"].append(change_val_eternal)
                if flag_change_how != "0":
                    if "flag" not in move_to:
                        move_to["flag"] = 0
                    if flag_change_how == "1":
                        move_to["flag"] += int(flag_change_val)
                    elif flag_change_how == "2":
                        move_to["flag"] -= int(flag_change_val)
                    elif flag_change_how == "3":
                        move_to["flag"] = int(flag_change_val)
                    elif flag_change_how == "4":
                        move_to["flag"] = int(flag_change_val) | move_to["flag"]
                    elif flag_change_how == "5":
                        move_to["flag"] -= (int(flag_change_val)) & move_to["flag"]
                i += 1
                if place2["place"] == "field":
                    x = int(place2["x"])
                    y = int(place2["y"])
                    field = self.field
                    if cost == 1:
                        cost_result = self.cost_result
                        if "under" not in cost_result:
                            cost_result["under"] = {}

                        if "field" not in cost_result["under"]:
                            cost_result["under"]["field"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["user_det"] = cost_user
                        cost_result_tmp["x"] = x
                        cost_result_tmp["y"] = y
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result["under"]["field"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        move_to_tmp = move_to.copy()
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id"]
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = field[x][y]["mine_or_other"]
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            check_cost[str(duel.chain - 1)]["trigger"] = []
                            check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        if change_val_eternal is not None:
                            move_to["eternal"] = []
                            move_to["eternal"].append(change_val_eternal)
                        move_to = self.copy_monster_to_field(
                            move_to, x, y, field[x][y]["mine_or_other"], variable_names
                        )

                        move_to["under"] = self.get_all_under(field[x][y]["det"])

                        field[x][y]["det"] = move_to
                        self.raise_trigger(
                            field[x][y]["det"],
                            move_to_org,
                            org_move_to,
                            "effect",
                            "field",
                            user,
                            field[x][y]["mine_or_other"],
                            None,
                            effect_kind,
                            x,
                            y,
                        )
                        self.field = field
                        if (
                                "as_monster_to" in monster_effect_det
                                and monster_effect_det["as_monster_to"] != ""
                        ):
                            tmp = self.mess
                            tmp2 = {}
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = field[x][y]["mine_or_other"]
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            if (
                                    monster_effect_det["as_monster_to"]
                                    not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.mess = tmp
        if (
            "place_to" in monster_effect_det
            and monster_effect_det["place_to"]["0"] != ""
        ):
            place_org = monster_effect_det["place_to"]["0"]
            tmp = self.mess
            if str(duel.chain - 1) not in tmp:
                tmp[str(duel.chain - 1)] = {}
            for move_to in move_tos:
                place = place_org
                # 行き先書きかえ
                tmp_dest = self.check_change_dest(
                    move_to["det"],
                    user,
                    move_to["place"],
                    move_to["deck_id"],
                    move_to["x"],
                    move_to["y"],
                    place,
                    move_to["mine_or_other"]
                )
                if tmp_dest is True:
                    place = tmp_dest
                org_move_to = move_to["org_det"]
                move_to_org = move_to
                move_to = move_to["det"]
                if move_to is None:
                    continue
                if change_val_eternal is not None:
                    if "eternal" not in move_to:
                        move_to["eternal"] = []
                    move_to["eternal"].append(change_val_eternal)
                if flag_change_how != "0":
                    if "flag" not in move_to:
                        move_to["flag"] = 0
                    if flag_change_how == "1":
                        move_to["flag"] += int(flag_change_val)
                    elif flag_change_how == "2":
                        move_to["flag"] -= int(flag_change_val)
                    elif flag_change_how == "3":
                        move_to["flag"] = int(flag_change_val)
                    elif flag_change_how == "4":
                        move_to["flag"] = int(flag_change_val) | move_to["flag"]
                    elif flag_change_how == "5":
                        move_to["flag"] -= (int(flag_change_val)) & move_to["flag"]
                place_tmp = place.split("_")
                if place_tmp[0] == "field":
                    if "field_x_to" in monster_effect_det:
                        field = self.field
                        x = int(monster_effect_det["field_x_to"])
                        y = int(monster_effect_det["field_y_to"])
                        move_to_tmp = move_to.copy()
                        if cost == 1:
                            if (
                                org_move_to["place_unique_id"]
                                == tmp[str(duel.chain - 1)]["trigger"][0][
                                    "place_unique_id"
                                ]
                            ):
                                check_cost = self.cost
                                tmp2 = {}
                                if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                    tmp2["from_x"] = org_trigger["from_x"]
                                    tmp2["from_y"] = org_trigger["from_y"]
                                    tmp2["det_from"] = org_trigger["det_from"]
                                    tmp2["place_unique_id_from"] = org_trigger[
                                        "place_unique_id_from"
                                    ]
                                    tmp2["place_from"] = org_trigger["place_from"]
                                    tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                                else:
                                    tmp2["from_x"] = move_to_org["x"]
                                    tmp2["from_y"] = move_to_org["y"]
                                    tmp2["det_from"] = move_to_org["det"]
                                    tmp2["place_unique_id_from"] = move_to_org["det"][
                                        "place_unique_id"
                                    ]
                                    tmp2["place_from"] = move_to_org["place"]
                                    tmp2["deck_id_from"] = move_to_org["deck_id_from"]
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["det"] = move_to
                                tmp2["det"]["place_unique_id"] = move_to_tmp[
                                    "place_unique_id"
                                ]
                                tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = field[x][y]["mine_or_other"]
                                tmp2["user_det"] = user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                check_cost[str(duel.chain - 1)]["trigger"] = []
                                check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                                tmp[str(duel.chain - 1)]["trigger"] = []
                                tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                                self.cost = check_cost
                                self.mess = tmp
                            cost_result = self.cost_result
                            if "under" not in cost_result:
                                cost_result["under"] = {}

                            if "field" not in cost_result["under"]:
                                cost_result["under"]["field"] = []
                            if "field_x_to" in monster_effect_det:
                                field = self.field
                            x = int(monster_effect_det["field_x_to"])
                            y = int(monster_effect_det["field_y_to"])
                            cost_result_tmp = {}
                            cost_result_tmp["x"] = x
                            cost_result_tmp["y"] = y
                            cost_result_tmp["kind"] = effect_kind
                            cost_result_tmp["move_from"] = json.dumps(move_to_org)
                            cost_result_tmp["det"] = json.dumps(move_to)
                            cost_result["under"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                        else:
                            if change_val_eternal is not None:
                                move_to["eternal"] = []
                                move_to["eternal"].append(change_val_eternal)
                            move_to = self.copy_monster_to_field(
                                move_to, x, y, field[x][y]["mine_or_other"], variable_names
                            )
                            move_to["under"] = self.get_all_under(field[x][y]["det"])
                            field[x][y]["det"] = move_to
                            self.raise_trigger(
                                field[x][y]["det"],
                                move_to_org,
                                org_move_to,
                                "effect",
                                "field",
                                user,
                                field[x][y]["mine_or_other"],
                                None,
                                effect_kind,
                                x,
                                y,
                            )
                            self.field = field
                            if (
                                    "as_monster_to" in monster_effect_det
                                    and monster_effect_det["as_monster_to"] != ""
                            ):
                                tmp = self.mess
                                tmp2 = {}
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["det"] = move_to
                                tmp2["det"]["place_unique_id"] = move_to_tmp[
                                    "place_unique_id"
                                ]
                                tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = field[x][y]["mine_or_other"]
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                if (
                                        monster_effect_det["as_monster_to"]
                                        not in tmp[str(duel.chain - 1)]
                                ):
                                    tmp[str(duel.chain - 1)][
                                        monster_effect_det["as_monster_to"]
                                    ] = []
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ].append(tmp2)
                                self.mess = tmp

    def move_to_monster(
        self, move_tos, effect_kind, cost=0, user=None, monster_effect=None
    ):
        duel = self.duel
        if cost == 0:
            chain_det = json.loads(duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain - 1)]
            monster_effect_wrapper = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect = monster_effect_wrapper.monster_effect
            monster_effect_det = json.loads(monster_effect.monster_effect)
        elif cost == 2:
            monster_effect = monster_effect.monster_effect
            monster_effect_det = json.loads(monster_effect.monster_effect)
        else:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(self.tmp_chain)]
            cost_det = duel.cost_det
            cost_wrapper = CostWrapper.objects.get(id=cost_det)
            cost2 = cost_wrapper.cost
            monster_effect_det = json.loads(cost2.cost)
        i = 0
        flag_change_how = monster_effect_det["flag_change_how"]
        flag_change_val = monster_effect_det["flag_change_val"]
        variable_names = []
        if len(monster_effect_det["monster_variable_change_name"]) != 0:
            change_val_eternal = {}
            if "persist" in monster_effect_det:
                if monster_effect_det["persist"][0] is True:
                    change_val_eternal["persist"] = True
            change_val_eternal["variables"] = {}
            change_val_eternal["monster_variable_change_life"] = monster_effect_det[
                "monster_variable_change_life"
            ][0]
            change_val_eternal[
                "monster_variable_change_life_length"
            ] = monster_effect_det["monster_variable_change_life_length"][0]
            change_val_eternal["effect_kind"] = monster_effect_det[
                "monster_variable_change_effect_kind"
            ][0]
            for index in range(len(monster_effect_det["monster_variable_change_name"])):
                variable_name = monster_effect_det["monster_variable_change_name"][
                    index
                ]
                if "monster_variable_change_initial" in monster_effect_det:
                    ini = monster_effect_det["monster_variable_change_initial"][index]
                else:
                    ini = False
                if "monster_variable_change_add" in monster_effect_det:
                    add = monster_effect_det["monster_variable_change_add"][index]
                else:
                    add = 0
                change_val_eternal["variables"][variable_name] = {}
                change_val_eternal["variables"][variable_name]["value"] = str(
                    self.calculate_boland(
                        monster_effect_det["monster_variable_change_val"][index],
                        None,
                        False,
                    )
                )
                change_val_eternal["variables"][variable_name]["ini"] = ini
                change_val_eternal["variables"][variable_name]["add"] = add
        else:
            change_val_eternal = None
        if (
            "as_monster_condition_to" in monster_effect_det
            and monster_effect_det["as_monster_condition_to"] != ""
        ):
            as_monster_effect = monster_effect_det["as_monster_condition_to"]
            tmp = self.mess
            cost_tmp = self.cost
            timing_tmp = self.timing_mess
            if str(duel.chain - 1) not in tmp:
                tmp[str(duel.chain - 1)] = {}
            if as_monster_effect[0] == "~":
                if duel.in_cost is True:
                    place1 = cost_tmp[str(self.tmp_chain)][as_monster_effect]
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][as_monster_effect]
            elif as_monster_effect[0] == "%":
                place1 = timing_tmp[as_monster_effect]
            else:
                place1 = tmp[str(duel.chain - 1)][as_monster_effect]
            for place2 in place1:
                if len(move_tos) <= i:
                    continue
                move_to = move_tos[i]
                move_to_org = copy.deepcopy(move_to)
                org_move_to = move_to["org_det"]
                move_to = move_to["det"]
                if move_to is None:
                    continue
                i += 1
                if place2["place"] == "field":
                    x = int(place2["x"])
                    y = int(place2["y"])
                    field = self.field
                    if cost == 1:
                        move_to = self.copy_monster_to_field(
                            move_to, x, y, field[x][y]["mine_or_other"], variable_names
                        )
                        move_to = self.move_to_flag(
                            flag_change_how, move_to, flag_change_val
                        )
                        cost_result = self.cost_result
                        if "add" not in cost_result:
                            cost_result["add"] = {}

                        if "field" not in cost_result["add"]:
                            cost_result["add"]["field"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["user_det"] = user
                        cost_result_tmp["user"] = user
                        cost_result_tmp["x"] = x
                        cost_result_tmp["y"] = y
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["org_det"] = json.dumps(org_move_to)
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result["add"]["field"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        move_to = self.copy_monster_to_field(
                            move_to, x, y, field[x][y]["mine_or_other"], variable_names
                        )
                        move_to = self.move_to_flag(
                            flag_change_how, move_to, flag_change_val
                        )
                        move_to_tmp = move_to.copy()
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id"]
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = field[x][y]["mine_or_other"]
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            check_cost[str(duel.chain - 1)]["~trigger"] = []
                            check_cost[str(duel.chain - 1)]["~trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        if (
                            "as_monster_to" in monster_effect_det
                            and monster_effect_det["as_monster_to"] != ""
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = field[x][y]["mine_or_other"]
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            if (
                                monster_effect_det["as_monster_to"]
                                not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        move_to = copy.deepcopy(move_to)
                        if change_val_eternal is not None:
                            move_to["eternal"] = []
                            move_to["eternal"].append(change_val_eternal)
                        field[x][y]["det"] = move_to
                        self.effect += "field_move_to;"+str(x)+";"+str(y)+";"+field[x][y]["det"]["img"]+"|"
                        self.effect2 += "field_move_to;"+str(x)+";"+str(y)+";"+field[x][y]["det"]["img"]+"|"
                        self.raise_trigger(
                            field[x][y]["det"],
                            move_to_org,
                            org_move_to,
                            "effect",
                            "field",
                            field[x][y]["mine_or_other"],
                            user,
                            None,
                            effect_kind,
                            x,
                            y,
                        )
                        self.field = field
        if (
            "place_to" in monster_effect_det
            and monster_effect_det["place_to"]["0"] != ""
        ):
            place_org = monster_effect_det["place_to"]["0"]
            tmp = self.mess
            if str(duel.chain - 1) not in tmp:
                tmp[str(duel.chain - 1)] = {}
            for move_to in move_tos:
                place = place_org
                # 行き先書きかえ
                tmp_dest = self.check_change_dest(
                    move_to["det"],
                    user,
                    move_to["place"],
                    move_to["deck_id"],
                    move_to["x"],
                    move_to["y"],
                    place,
                    move_to["mine_or_other"]
                )
                if tmp_dest:
                    place = tmp_dest[0]["det"]
                move_to_org = move_to
                org_move_to = move_to["org_det"]
                move_to = move_to["det"]
                if move_to is None:
                    continue
                if change_val_eternal is not None:
                    move_to["eternal"] = []
                    move_to["eternal"].append(change_val_eternal)
                if flag_change_how != "0":
                    if "flag" not in move_to:
                        move_to["flag"] = 0
                    if flag_change_how == "1":
                        move_to["flag"] += int(flag_change_val)
                    elif flag_change_how == "2":
                        move_to["flag"] -= int(flag_change_val)
                    elif flag_change_how == "3":
                        move_to["flag"] = int(flag_change_val)
                    elif flag_change_how == "4":
                        move_to["flag"] = int(flag_change_val) | move_to["flag"]
                    elif flag_change_how == "5":
                        move_to["flag"] -= (int(flag_change_val)) & move_to["flag"]
                place_tmp = place.split("_")
                deck_id = int(place_tmp[1])
                if place_tmp[0] != "field" and  move_to["token"] is True:
                    self.null_relation(
                        move_to,
                        move_to,
                        None,
                        "field",
                        0,
                        0,
                        0,
                        0,
                        chain_user,
                        "effect",
                        )
                    continue
                if (place_tmp[2] == "1" and user == self.user) or (
                    place_tmp[2] == "2" and user != self.user
                ):
                    mine_or_other2 = 1
                elif (place_tmp[2] == "1" and user != self.user) or (
                    place_tmp[2] == "2" and user == self.user
                ):
                    mine_or_other2 = 2
                elif place_tmp[2] == "3":
                    mine_or_other2 = 3
                elif place_tmp[2] == "4" and 1 == self.user:
                    mine_or_other2 = move_to["owner"]
                    mine_or_other3 = move_to["owner"]
                elif place_tmp[2] == "4" and 2 == self.user:
                    mine_or_other3 = move_to["owner"]
                    if move_to["owner"] == 1:
                        mine_or_other2 = 2
                    elif move_to["owner"] == 2:
                        mine_or_other2 = 1

                if (place_tmp[2] == "1" and user == 1) or (
                    place_tmp[2] == "2" and user == 2
                ):
                    mine_or_other3 = 1
                elif (place_tmp[2] == "1" and user == 2) or (
                    place_tmp[2] == "2" and user == 1
                ):
                    mine_or_other3 = 2
                elif (place_tmp[2] == "3"):
                    mine_or_other3 = 3
                if self.user == 1:
                    mine_or_other4 = mine_or_other2
                else:
                    if mine_or_other2 == 1:
                        mine_or_other4 = 2
                    elif mine_or_other2 == 2:
                        mine_or_other4 = 1
                    else:
                        mine_or_other4 = 3
                if place_tmp[0] == "deck":
                    if mine_or_other2 == 1:
                        deck = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        deck = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        deck = self.decks[deck_id]["commondeck"]
                    user_decks = deck
                    move_to = copy.deepcopy(move_to)
                    move_to = self.copy_monster_to_deck(
                        move_to, deck_id, mine_or_other3, variable_names
                    )
                    if change_val_eternal is not None:
                        move_to["eternal"] = []
                        move_to["eternal"].append(change_val_eternal)
                    move_to_tmp = copy.deepcopy(move_to)
                    move_to = self.move_to_flag(
                        flag_change_how, move_to, flag_change_val
                    )
                    if change_val_eternal is not None:
                        move_to["eternal"] = []
                        move_to["eternal"].append(change_val_eternal)
                    if cost == 1:
                        cost_result = self.cost_result
                        if "add" not in cost_result:
                            cost_result["add"] = {}

                        if "deck" not in cost_result["add"]:
                            cost_result["add"]["deck"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["org_det"] = json.dumps(org_move_to)
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result_tmp["user"] = mine_or_other4
                        cost_result_tmp["user_det"] = user
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["how"] = monster_effect_det["move_how_to"]
                        cost_result["add"]["deck"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id"]
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            check_cost[str(duel.chain - 1)]["~trigger"] = []
                            check_cost[str(duel.chain - 1)]["~trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        if (
                            "as_monster_to" in monster_effect_det
                            and monster_effect_det["as_monster_to"] != ""
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            if (
                                monster_effect_det["as_monster_to"]
                                not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        self.raise_trigger(
                            move_to,
                            move_to_org,
                            org_move_to,
                            "effect",
                            "deck",
                            mine_or_other4,
                            user,
                            deck_id,
                            effect_kind,
                            None,
                            None,
                        )
                        if (
                            monster_effect_det["move_how_to"] == 0
                            or len(user_decks) == 0
                        ):
                            user_decks.insert(0, move_to)
                        elif monster_effect_det["move_how_to"] == 1:
                            user_decks.append(move_to)
                        else:
                            range_i = random.randrange(len(user_decks))
                            user_decks.insert(range_i, move_to)
                        if mine_or_other2 == 1:
                            self.decks[deck_id]["mydeck"] = user_decks
                        elif mine_or_other2 == 2:
                            self.decks[deck_id]["otherdeck"] = user_decks
                        elif mine_or_other2 == 3:
                            self.decks[deck_id]["commondeck"] = user_decks
                if place_tmp[0] == "grave":
                    if mine_or_other2 == 1:
                        grave = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        grave = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        grave = self.graves[deck_id]["commongrave"]
                    user_graves = grave
                    move_to = copy.deepcopy(move_to)
                    move_to = self.copy_monster_to_grave(
                        move_to, deck_id, mine_or_other3, variable_names
                    )
                    move_to_tmp = copy.deepcopy(move_to)
                    move_to = self.move_to_flag(
                        flag_change_how, move_to, flag_change_val
                    )
                    if change_val_eternal is not None:
                        move_to["eternal"] = []
                        move_to["eternal"].append(change_val_eternal)
                    if cost == 1:
                        cost_result = self.cost_result
                        if "add" not in cost_result:
                            cost_result["add"] = {}

                        if "grave" not in cost_result["add"]:
                            cost_result["add"]["grave"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["org_det"] = json.dumps(org_move_to)
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result_tmp["user"] = mine_or_other4
                        cost_result_tmp["user_det"] = user
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["how"] = monster_effect_det["move_how_to"]
                        cost_result_tmp["kind"] = effect_kind
                        cost_result["add"]["grave"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    else:
                        if (
                            "trigger" in tmp[str(duel.chain - 1)]
                            and org_move_to["place_unique_id"]
                            == tmp[str(duel.chain - 1)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id"]
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            check_cost[str(duel.chain - 1)]["~trigger"] = []
                            check_cost[str(duel.chain - 1)]["~trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        if (
                            "as_monster_to" in monster_effect_det
                            and monster_effect_det["as_monster_to"] != ""
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            if (
                                monster_effect_det["as_monster_to"]
                                not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        self.raise_trigger(
                            move_to,
                            move_to_org,
                            org_move_to,
                            "effect",
                            "grave",
                            mine_or_other4,
                            user,
                            deck_id,
                            effect_kind,
                            None,
                            None,
                        )
                        if (
                            monster_effect_det["move_how_to"] == 0
                            or len(user_graves) == 0
                        ):
                            user_graves.insert(0, move_to)
                        elif monster_effect_det["move_how_to"] == 1:
                            user_graves.append(move_to)
                        else:
                            range_i = random.randrange(len(user_graves))
                            user_graves.insert(range_i, move_to)
                        if mine_or_other2 == 1:
                            self.graves[deck_id]["mygrave"] = user_graves
                        elif mine_or_other2 == 2:
                            self.graves[deck_id]["othergrave"] = user_graves
                        elif mine_or_other2 == 3:
                            self.graves[deck_id]["commongrave"] = user_graves
                if place_tmp[0] == "hand":
                    if mine_or_other2 == 1:
                        hand = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        hand = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        hand = self.hands[deck_id]["commonhand"]
                    user_hands = hand
                    move_to = copy.deepcopy(move_to)
                    move_to = self.copy_monster_to_hand(
                        move_to, deck_id, mine_or_other3, variable_names
                    )
                    move_to_tmp = copy.deepcopy(move_to)
                    move_to = self.move_to_flag(
                        flag_change_how, move_to, flag_change_val
                    )
                    if change_val_eternal is not None:
                        move_to["eternal"] = []
                        move_to["eternal"].append(change_val_eternal)
                    if cost == 1:
                        if (
                            org_move_to["place_unique_id"]
                            == tmp[str(duel.chain)]["trigger"][0]["place_unique_id"]
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                            if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                tmp2["from_x"] = org_trigger["from_x"]
                                tmp2["from_y"] = org_trigger["from_y"]
                                tmp2["det_from"] = org_trigger["det_from"]
                                tmp2["place_unique_id_from"] = org_trigger[
                                    "place_unique_id_from"
                                ]
                                tmp2["place_from"] = org_trigger["place_from"]
                                tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                            else:
                                tmp2["from_x"] = move_to_org["x"]
                                tmp2["from_y"] = move_to_org["y"]
                                tmp2["det_from"] = move_to_org["det"]
                                tmp2["place_unique_id_from"] = move_to_org["det"][
                                    "place_unique_id"
                                ]
                                tmp2["place_from"] = move_to_org["place"]
                                tmp2["deck_id_from"] = move_to_org["deck_id"]
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["mine_or_other"] = move_to["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            check_cost[str(duel.chain - 1)]["~trigger"] = []
                            check_cost[str(duel.chain - 1)]["~trigger"].append(tmp2)
                            tmp[str(duel.chain - 1)]["trigger"] = []
                            tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        if (
                            "as_monster_to" in monster_effect_det
                            and monster_effect_det["as_monster_to"] != ""
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            if (
                                monster_effect_det["as_monster_to"]
                                not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                        cost_result = self.cost_result
                        if "add" not in cost_result:
                            cost_result["add"] = {}

                        if "hand" not in cost_result["add"]:
                            cost_result["add"]["hand"] = []
                        cost_result_tmp = {}
                        cost_result_tmp["org_det"] = json.dumps(org_move_to)
                        cost_result_tmp["move_from"] = json.dumps(move_to_org)
                        cost_result_tmp["det"] = json.dumps(move_to)
                        cost_result_tmp["user"] = mine_or_other4
                        cost_result_tmp["user_det"] = user
                        cost_result_tmp["kind"] = effect_kind
                        cost_result_tmp["deck_id"] = deck_id
                        cost_result_tmp["how"] = monster_effect_det["move_how_to"]
                        cost_result["add"]["hand"].append(cost_result_tmp)
                        self.cost_result = cost_result
                    if cost != 1:
                        if (
                            "as_monster_to" in monster_effect_det
                            and monster_effect_det["as_monster_to"] != ""
                        ):
                            tmp2 = {}
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["mine_or_other"] = move_to_tmp["owner"]
                            tmp2["user"] = mine_or_other4
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            if (
                                monster_effect_det["as_monster_to"]
                                not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.mess = tmp
                        if (
                            monster_effect_det["move_how_to"] == 0
                            or len(user_hands) == 0
                        ):
                            user_hands.insert(0, move_to)
                        elif monster_effect_det["move_how_to"] == 1:
                            user_hands.append(move_to)
                        else:
                            range_i = random.randrange(len(user_hands))
                            user_hands.insert(range_i, move_to)
                        if mine_or_other2 == 1:
                            self.hands[deck_id]["myhand"] = user_hands
                        elif mine_or_other2 == 2:
                            self.hands[deck_id]["otherhand"] = user_hands
                        elif mine_or_other2 == 3:
                            self.hands[deck_id]["commonhand"] = user_hands
                        self.raise_trigger(
                            move_to,
                            move_to_org,
                            org_move_to,
                            "effect",
                            "hand",
                            mine_or_other4,
                            user,
                            deck_id,
                            effect_kind,
                            None,
                            None,
                        )
                if place_tmp[0] == "field":
                    if "field_x_to" in monster_effect_det:
                        field = self.field
                        x = int(monster_effect_det["field_x_to"])
                        y = int(monster_effect_det["field_y_to"])
                        move_to = copy.deepcopy(move_to)
                        if change_val_eternal is not None:
                            move_to["eternal"] = []
                            move_to["eternal"].append(change_val_eternal)
                        move_to = self.copy_monster_to_field(
                            move_to,
                            x,
                            y,
                            field[x][y]["mine_or_other"],
                            variable_names,
                        )
                        move_to = self.move_to_flag(
                            flag_change_how, move_to, flag_change_val
                        )
                        move_to_tmp = move_to.copy()
                        if cost == 1:
                            if (
                                org_move_to["place_unique_id"]
                                == tmp[str(self.tmp_chain)]["~trigger"][0][
                                    "place_unique_id"
                                ]
                            ):
                                check_cost = self.cost
                                tmp2 = {}
                                org_trigger = tmp[str(duel.chain - 1)]["trigger"][0]
                                if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                    tmp2["from_x"] = org_trigger["from_x"]
                                    tmp2["from_y"] = org_trigger["from_y"]
                                    tmp2["det_from"] = org_trigger["det_from"]
                                    tmp2["place_unique_id_from"] = org_trigger[
                                        "place_unique_id_from"
                                    ]
                                    tmp2["place_from"] = org_trigger["place_from"]
                                    tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                                else:
                                    tmp2["from_x"] = move_to_org["x"]
                                    tmp2["from_y"] = move_to_org["y"]
                                    tmp2["det_from"] = move_to_org["det"]
                                    tmp2["place_unique_id_from"] = move_to_org["det"][
                                        "place_unique_id"
                                    ]
                                    tmp2["place_from"] = move_to_org["place"]
                                    tmp2["deck_id_from"] = move_to_org["deck_id"]
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["det"] = move_to
                                tmp2["det"]["place_unique_id"] = move_to_tmp[
                                    "place_unique_id"
                                ]
                                tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = field[x][y]["mine_or_other"]
                                tmp2["user_det"] = user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                check_cost[str(duel.chain - 1)]["~trigger"] = []
                                check_cost[str(duel.chain - 1)]["~trigger"].append(tmp2)
                                tmp[str(duel.chain - 1)]["trigger"] = []
                                tmp[str(duel.chain - 1)]["trigger"].append(tmp2)
                                self.cost = check_cost
                                self.mess = tmp
                        if (
                            "as_monster_to" in monster_effect_det
                            and monster_effect_det["as_monster_to"] != ""
                        ):
                            check_cost = self.cost
                            tmp2 = {}
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["det"] = move_to
                            tmp2["det"]["place_unique_id"] = move_to_tmp[
                                "place_unique_id"
                            ]
                            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                            tmp2["user"] = field[x][y]["mine_or_other"]
                            tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                            tmp2["place"] = "field"
                            tmp2["deck_id"] = 0
                            if (
                                monster_effect_det["as_monster_to"]
                                not in tmp[str(duel.chain - 1)]
                            ):
                                tmp[str(duel.chain - 1)][
                                    monster_effect_det["as_monster_to"]
                                ] = []
                            tmp[str(duel.chain - 1)][
                                monster_effect_det["as_monster_to"]
                            ].append(tmp2)
                            self.cost = check_cost
                            self.mess = tmp
                            cost_result = self.cost_result
                            if "add" not in cost_result:
                                cost_result["add"] = {}

                            if "field" not in cost_result["add"]:
                                cost_result["add"]["field"] = []
                            if "field_x_to" in monster_effect_det:
                                field = self.field
                            x = int(monster_effect_det["field_x_to"])
                            y = int(monster_effect_det["field_y_to"])
                            cost_result_tmp = {}
                            cost_result_tmp["x"] = x
                            cost_result_tmp["y"] = y
                            cost_result_tmp["kind"] = effect_kind
                            cost_result_tmp["org_det"] = json.dumps(org_move_to)
                            cost_result_tmp["move_from"] = json.dumps(move_to_org)
                            cost_result_tmp["det"] = json.dumps(move_to)
                            cost_result["add"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                        else:
                            field[x][y]["det"] = move_to
                            self.raise_trigger(
                                field[x][y]["det"],
                                move_to_org,
                                org_move_to,
                                "effect",
                                "field",
                                field[x][y]["mine_or_other"],
                                user,
                                None,
                                effect_kind,
                                x,
                                y,
                            )
                            self.field = field
                    else:

                        self.move_to_field(
                            place_tmp,
                            move_to,
                            move_to_org,
                            org_move_to,
                            cost,
                            variable_names,
                            effect_kind,
                            monster_effect_det,
                        )

    def move_to_field(
        self,
        place_tmp,
        move_to,
        move_to_org,
        org_move_to,
        cost,
        variable_names,
        effect_kind,
        effect_det,
    ):
        duel = self.duel
        field = self.field
        deck_id = place_tmp[1]
        if cost == 1:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[self.tmp_chain]
        elif cost == 0:
            chain_user = json.loads(duel.chain_user)
            user = chain_user[str(duel.chain-1)]
        else:
            user = self.user
        mess = self.mess
        if (place_tmp[2] == "1" and user == 1) or (place_tmp[2] == "2" and user == 2):
            mine_or_other = 1
        elif (place_tmp[2] == "1" and user == 2) or (place_tmp[2] == "2" and user == 1):
            mine_or_other = 2
        elif (int(place_tmp[2])) == 4:
            mine_or_other = move_to["owner"]
        else:
            mine_or_other = 3
        for x in range(len(field)):
            for y in range(len(field[x])):
                if self.field_free is False:
                    kind = field[x][y]["kind"]
                else:
                    kind = field[0][y]["kind"]
                mine_or_other_field = field[x][y]["mine_or_other"]
                if kind.find(deck_id) > -1 and mine_or_other == mine_or_other_field:
                    if "det" in field[x][y] and field[x][y]["det"] is None:
                        if cost == 1:
                            cost_result = self.cost_result
                            if "add" not in cost_result:
                                cost_result["add"] = {}

                            if "field" not in cost_result["add"]:
                                cost_result["add"]["field"] = []
                            cost_result_tmp = {}
                            cost_result_tmp["x"] = x
                            cost_result_tmp["y"] = y
                            cost_result_tmp["user"] = field[x][y]["mine_or_other"]
                            cost_result_tmp["user_det"] = user
                            cost_result_tmp["org_det"] = json.dumps(org_move_to)
                            cost_result_tmp["move_from"] = json.dumps(move_to_org)
                            cost_result_tmp["det"] = json.dumps(move_to)
                            cost_result_tmp["kind"] = effect_kind
                            cost_result["add"]["field"].append(cost_result_tmp)
                            self.cost_result = cost_result
                            return
                        else:
                            move_to = self.copy_monster_to_field(
                                move_to,
                                x,
                                y,
                                field[x][y]["mine_or_other"],
                                variable_names,
                            )
                            field[x][y]["det"] = move_to
                            self.effect += "field_move_to;"+str(x)+";"+str(y)+";"+field[x][y]["det"]["img"]+"|"
                            self.effect2 += "field_move_to;"+str(x)+";"+str(y)+";"+field[x][y]["det"]["img"]+"|"
                            self.field = field
                            move_to_tmp = move_to.copy()
                            self.raise_trigger(
                                field[x][y]["det"],
                                move_to_org,
                                org_move_to,
                                "effect",
                                "field",
                                field[x][y]["mine_or_other"],
                                user,
                                None,
                                effect_kind,
                                x,
                                y,
                                
                            )
                            if (
                                "trigger" in mess[str(duel.chain - 1)]
                                and org_move_to["place_unique_id"]
                                == mess[str(duel.chain - 1)]["trigger"][0][
                                    "place_unique_id"
                                ]
                            ):
                                check_cost = self.cost
                                tmp2 = {}
                                org_trigger = mess[str(duel.chain - 1)]["trigger"][0]
                                if "det_from" in org_trigger and org_trigger["det_from"] is not None:
                                    tmp2["from_x"] = org_trigger["from_x"]
                                    tmp2["from_y"] = org_trigger["from_y"]
                                    tmp2["det_from"] = org_trigger["det_from"]
                                    tmp2["place_unique_id_from"] = org_trigger[
                                        "place_unique_id_from"
                                    ]
                                    tmp2["place_from"] = org_trigger["place_from"]
                                    tmp2["deck_id_from"] = org_trigger["deck_id_from"]
                                else:
                                    tmp2["from_x"] = move_to_org["x"]
                                    tmp2["from_y"] = move_to_org["y"]
                                    tmp2["det_from"] = move_to_org["det"]
                                    tmp2["place_unique_id_from"] = move_to_org["det"][
                                        "place_unique_id"
                                    ]
                                    tmp2["place_from"] = move_to_org["place"]
                                    tmp2["deck_id_from"] = move_to_org["deck_id"]
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["det"] = move_to
                                tmp2["det"]["place_unique_id"] = move_to_tmp[
                                    "place_unique_id"
                                ]
                                tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = field[x][y]["mine_or_other"]
                                tmp2["user_det"] = user
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                if str(duel.chain - 1)  not in check_cost:
                                    check_cost[str(duel.chain - 1)] = {}
                                check_cost[str(duel.chain - 1)]["trigger"] = []
                                check_cost[str(duel.chain - 1)]["trigger"].append(tmp2)
                                mess[str(duel.chain - 1)]["trigger"] = []
                                mess[str(duel.chain - 1)]["trigger"].append(tmp2)
                                self.cost = check_cost
                                self.mess = mess
                            if (
                                "as_monster_to" in effect_det
                                and effect_det["as_monster_to"] != ""
                            ):
                                check_cost = self.cost
                                tmp2 = {}
                                tmp2["x"] = x
                                tmp2["y"] = y
                                tmp2["det"] = move_to
                                tmp2["det"]["place_unique_id"] = move_to_tmp[
                                    "place_unique_id"
                                ]
                                tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                tmp2["user"] = field[x][y]["mine_or_other"]
                                tmp2["place_unique_id"] = move_to_tmp["place_unique_id"]
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                if (
                                    effect_det["as_monster_to"]
                                    not in mess[str(duel.chain - 1)]
                                ):
                                    mess[str(duel.chain - 1)][
                                        effect_det["as_monster_to"]
                                    ] = []
                                mess[str(duel.chain - 1)][
                                    effect_det["as_monster_to"]
                                ].append(tmp2)
                                self.cost = check_cost
                                self.mess = mess
                            return

    def watch_field(self, field):
        for x in range(len(field)):
            for y in range(len(field[x])):
                if field[x][y]["det"] is None:
                    field[x][y]["hide"] = False
                    continue
                if int(self.check_change_val(
                            field[x][y]["det"],
                            field[x][y]["mine_or_other"],
                            "field",
                            0,
                            x,
                            y,
                            "show",
                            field[x][y]["mine_or_other"],
                            int(field[x][y]["det"]["variables"]["show"]["value"])
                    )) == 1:
                    field[x][y]["det"] = None
                    field[x][y]["hide"] = True
        return field

    def modify_field_info(self, field, user, other_user, priority, mode=0):
        duel  = self.duel
        field_triggers = []
        flag_trigger = False
        force_num = 0
        for x in range(len(field)):
            for y in range(len(field[x])):
                if int(field[x][y]["mine_or_other"]) == 1:

                    mine_or_other = 1
                elif field[x][y]["mine_or_other"] == 2:
                    mine_or_other = 2
                else:
                    mine_or_other = 0
                if field[x][y]["det"] is None:
                    field[x][y]["hide"] = False
                    continue
                if int(field[x][y]["mine_or_other"]) == other_user:
                    if int(self.check_change_val(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        "field",
                        0,
                        x,
                        y,
                        "show",
                        field[x][y]["mine_or_other"],
                        int(field[x][y]["det"]["variables"]["show"]["value"])
                    )) == 1:
                        field[x][y]["det"] = None
                        field[x][y]["hide"] = True
                if (field[x][y])["det"] is not None:
                    tmp_return = self.check_field_trigger(
                        field[x][y]["det"],
                        x,
                        y,
                        user,
                        other_user,
                        mine_or_other,
                        priority,
                        mode,
                    )
                    result_triggers = tmp_return[0]
                    force_num += tmp_return[1]
                    if mode == 1 and result_triggers is True:
                        flag_trigger = True
                    elif mode == 1 and result_triggers is not False:
                        flag_trigger = True
                        field_triggers.append(result_triggers)
                    add_variables = self.config.add_variables_show.split("_")
                    for add_variable in add_variables:
                        add_variable2 = add_variable.split("-")
                        minus = 0
                        if len(add_variable2) > 1:
                            minus_variable = add_variable2[1]
                            minus = int(self.check_change_val(
                                field[x][y]["det"],
                                field[x][y]["mine_or_other"],
                                "field",
                                0,
                                x,
                                y,
                                minus_variable,
                                field[x][y]["mine_or_other"],
                                0
                            ))
                        add_variable = add_variable2[0]
                        if add_variable in field[x][y]["det"]["variables"]:
                            if "add_variable" not in field[x][y]["det"]:
                                field[x][y]["det"]["add_variable"] ={}
                            if( not field[x][y]["det"]["variables"][add_variable]["value"].isnumeric()):
                                tmp_value = 0
                            else:
                                tmp_value = int(field[x][y]["det"]["variables"][add_variable]["value"])

                            field[x][y]["det"]["add_variable"][add_variable] = int(self.check_change_val(
                                field[x][y]["det"],
                                field[x][y]["mine_or_other"],
                                "field",
                                0,
                                x,
                                y,
                                add_variable,
                                field[x][y]["mine_or_other"],
                                tmp_value
                            )) - minus
                    field[x][y]["det"]["trigger"] = result_triggers
        if mode == 1 and flag_trigger is False :
            return [False,force_num]
        elif mode == 1 and len(field_triggers) == 0:
            return [True,force_num]
        elif mode == 1:
            field_triggers.sort(key=lambda x: (x["priority"],x["storategy_priority"],x["strategy_value"]), reverse=True)
            if duel.trigger_waiting == "":
                trigger_waiting = []
            else:
                trigger_waiting = json.loads(duel.trigger_waiting)
            return [True,force_num]

        return [field,force_num]

    def check_hand_eternal(self, hand_info, count, user, other_user, v_e):
        result_hand_eternal = []
        for i in range(count):
            if hand_info[i]["eternal"] is False:
                continue
            result_hand_eternal += self.check_hand_eternal_det(
                hand_info[i], i, user, other_user, v_e
            )
        return result_hand_eternal

    def check_hand_eternal_det(self, hand_info, hand_number, user, other_user, v_e):
        result_hand_eternal = []

        if "myhand" in hand_info:
            if user == 1:
                mine_or_other = 1
            else:
                mine_or_other = 2
            for i in range(hand_info["myhandnum"]):
                result_hand_eternal += self.check_hand_eternal_det_det(
                    hand_info["myhand"][i],
                    hand_number,
                    user,
                    other_user,
                    mine_or_other,
                    hand_number + 1,
                    i,
                    v_e,
                )
        if "otherhand" in hand_info:
            if user == 1:
                mine_or_other = 2
            else:
                mine_or_other = 1
            for i in range(hand_info["otherhandnum"]):
                result_hand_eternal += self.check_hand_eternal_det_det(
                    hand_info["otherhand"][i],
                    hand_number,
                    user,
                    other_user,
                    mine_or_other,
                    hand_number + 1,
                    i,
                    v_e,
                )
        if "commonhand" in hand_info:
            for i in range(hand_info["commonhandnum"]):
                result_hand_eternal += self.check_hand_eternal_det_det(
                    hand_info["commonhand"][i],
                    hand_number,
                    user,
                    other_user,
                    3,
                    hand_number + 1,
                    i,
                    v_e,
                )
        return result_hand_eternal

    def check_hand_eternal_det_det(
        self, monster, hand_number, user, other_user, mine_or_other, deck_id, index, v_e
    ):
        return_eternal = []
        id = self.get_monster_id(
            monster, "hand", user, hand_number, 0, 0, mine_or_other
        )
        monster_det = Monster.objects.get(id=id)
        eternals = monster_det.eternal_effect.all()
        place_unique_id = monster["place_unique_id"]
        for eternal in eternals:
            tmp = {}
            tmp["eternal"] = copy.deepcopy(eternal)
            tmp["monster"] = monster
            tmp["effect_val"] = eternal.eternal_effect_val
            tmp["kind"] = eternal.eternal_kind
            tmp["priority"] = eternal.priority
            tmp["user"] = mine_or_other
            if "already" in monster:
                tmp["already"] = monster["already"]
            else:
                tmp["already"] = 0
            tmp["place"] = "hand"
            tmp["place_unique_id"] = place_unique_id
            tmp["deck_id"] = deck_id
            tmp["x"] = 0
            tmp["y"] = 0
            tmp["index"] = index
            tmp["mine_or_other"] = mine_or_other
            return_eternal.append(tmp)
        for val_eternal in v_e:
            eternal_name = val_eternal.eternal_variable
            val_equation = val_eternal.eternal_variable_equation
            tmp2 = monster["variables"]
            val = 0
            if eternal_name in tmp2:
                eternal_name = self.check_swap_val(
                    monster, mine_or_other, "hand", deck_id, 0, 0, eternal_name, 1
                )
                eternal_name2 = self.check_swap_init_val(
                    monster, mine_or_other, "hand", deck_id, 0, 0, eternal_name, 1
                )
                val += int(tmp2[eternal_name2]["value"])
            val = self.check_change_val(
                monster, mine_or_other, "hand", deck_id, 0, 0, eternal_name, 1,val
            )
            if val_equation == 0:
                if val == val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "hand"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 1:
                if val <= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "hand"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 2:
                if val >= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "hand"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 3:
                if val != val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "hand"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)

        return return_eternal

    def check_grave_eternal(self, grave_info, count, user, other_user, v_e):
        result_grave_eternal = []
        for i in range(count):
            if grave_info[i]["eternal"] is False:
                continue
            result_grave_eternal += self.check_grave_eternal_det(
                grave_info[i], i, user, other_user, v_e
            )
        return result_grave_eternal

    def check_grave_eternal_det(self, grave_info, grave_number, user, other_user, v_e):
        result_grave_eternal = []
        if grave_info["eternal"] is False:
            return []
        if "mygrave" in grave_info:
            if user == 1:
                mine_or_other = 1
            else:
                mine_or_other = 2
            for i in range(grave_info["mygravenum"]):
                result_grave_eternal += self.check_grave_eternal_det_det(
                    grave_info["mygrave"][i],
                    grave_number,
                    user,
                    other_user,
                    mine_or_other,
                    grave_number + 1,
                    i,
                    v_e,
                )
        if "othergrave" in grave_info:
            if user == 2:
                mine_or_other = 2
            else:
                mine_or_other = 1
            for i in range(grave_info["othergravenum"]):
                result_grave_eternal += self.check_grave_eternal_det_det(
                    grave_info["othergrave"][i],
                    grave_number,
                    user,
                    other_user,
                    mine_or_other,
                    grave_number + 1,
                    i,
                    v_e,
                )
        if "commongrave" in grave_info:
            for i in range(grave_info["commongravenum"]):
                result_grave_eternal += self.check_grave_eternal_det_det(
                    grave_info["commongrave"][i],
                    grave_number,
                    user,
                    other_user,
                    3,
                    grave_number + 1,
                    i,
                    v_e,
                )
        return result_grave_eternal

    def check_grave_eternal_det_det(
        self, monster, grave_number, user, other_user, mine_or_other, deck_id, index, v_e
    ):
        return_eternal = []
        id = self.get_monster_id(
            monster, "grave", user, grave_number, 0, 0, mine_or_other
        )
        monster_det = Monster.objects.get(id=id)
        eternals = monster_det.eternal_effect.all()
        place_unique_id = monster["place_unique_id"]
        for eternal in eternals:
            tmp = {}
            tmp["eternal"] = copy.deepcopy(eternal)
            tmp["monster"] = monster
            tmp["effect_val"] = eternal.eternal_effect_val
            tmp["kind"] = eternal.eternal_kind
            tmp["priority"] = eternal.priority
            tmp["user"] = mine_or_other
            if "already" in monster:
                tmp["already"] = monster["already"]
            else:
                tmp["already"] = 0
            tmp["place"] = "grave"
            tmp["deck_id"] = deck_id
            tmp["x"] = 0
            tmp["y"] = 0
            tmp["index"] = index
            tmp["place_unique_id"] = place_unique_id
            tmp["mine_or_other"] = mine_or_other
        for val_eternal in v_e:
            eternal_name = val_eternal.eternal_variable
            val_equation = val_eternal.eternal_variable_equation
            tmp2 = monster["variables"]
            val = 0
            if eternal_name in tmp2:
                eternal_name = self.check_swap_val(
                    monster, mine_or_other, "grave", deck_id, 0, 0, eternal_name, 1
                )
                eternal_name2 = self.check_swap_init_val(
                    monster, mine_or_other, "grave", deck_id, 0, 0, eternal_name, 1
                )
                val += int(tmp2[eternal_name2]["value"])
            val = self.check_change_val(
                monster, mine_or_other, "grave", deck_id, 0, 0, eternal_name, 1,val
            )
            if val_equation == 0:
                if val == val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "grave"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 1:
                if val <= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "grave"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 2:
                if val >= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "grave"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 3:
                if val != val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "grave"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)

        return return_eternal

    def check_field_eternal(self, field, user, other_user, v_e):
        result_field_eternal = []
        for x in range(len(field)):
            for y in range(len(field[x])):
                if field[x][y]["det"] is None:
                    continue
                if (field[x][y])["det"] is not None:
                    result_field_eternal += self.check_field_eternal_det(
                        field[x][y]["det"],
                        x,
                        y,
                        user,
                        other_user,
                        int(field[x][y]["mine_or_other"]),
                        v_e,
                    )
        return result_field_eternal

    def check_deck_eternal(self, deck_info, count, user, other_user, v_e):
        result_deck_eternal = []
        for i in range(count):
            if deck_info[i]["eternal"] is False:
                continue
            result_deck_eternal += self.check_deck_eternal_det(
                deck_info[i], i, user, other_user, v_e
            )
        return result_deck_eternal

    def check_deck_eternal_det(self, deck_info, deck_number, user, other_user, v_e):
        result_deck_eternal = []
        if "mydeck" in deck_info:
            if user == 1:
                mine_or_other = 1
            else:
                mine_or_other = 2
            for i in range(deck_info["mydecknum"]):
                result_deck_eternal += self.check_deck_eternal_det_det(
                    deck_info["mydeck"][i],
                    deck_number,
                    user,
                    other_user,
                    mine_or_other,
                    deck_number + 1,
                    i,
                    v_e,
                )
        if "otherdeck" in deck_info:
            if user == 1:
                mine_or_other = 2
            else:
                mine_or_other = 1
            for i in range(deck_info["otherdecknum"]):
                result_deck_eternal += self.check_deck_eternal_det_det(
                    deck_info["otherdeck"][i],
                    deck_number,
                    user,
                    other_user,
                    mine_or_other,
                    deck_number + 1,
                    i,
                    v_e,
                )
        if "commondeck" in deck_info:
            for i in range(deck_info["commondecknum"]):
                result_deck_eternal += self.check_deck_eternal_det_det(
                    deck_info["commondeck"][i],
                    deck_number,
                    user,
                    other_user,
                    3,
                    deck_number + 1,
                    i,
                    v_e,
                )
        return result_deck_eternal

    def get_monster_id_easy(self, monster):
        if monster is None:
            return 0
        if "eternal" not in monster:
            return monster["id"]
        for i in reversed(range(len(monster["eternal"]))):
            if monster["eternal"][i] is None:
                continue
            if "id" in monster["eternal"][i]:
                return monster["eternal"][i]["id"]
        return monster["id"]

    def get_monster_id(self, monster, place, user, deck_id, x, y, mine_or_other):
        if monster is None:
            return 0
        if "eternal" not in monster:
            return monster["id"]
        for i in range(len(monster["eternal"])):
            if monster["eternal"][i] is None:
                continue
            if "id" in monster["eternal"][i]:
                if not self.check_eternal_invalid(
                    monster,
                    user,
                    monster["eternal"][i]["effect_kind"],
                    place,
                    deck_id,
                    x,
                    y,
                    mine_or_other,
                ):
                    if "id" in monster["eternal"][i]:
                        return monster["eternal"][i]["id"]
                else:
                    del monster["eternal"][i]
        return monster["id"]

    def check_deck_eternal_det_det(
        self, monster, deck_number, user, other_user, mine_or_other, deck_id, index, v_e
    ):
        return_eternal = []
        id = self.get_monster_id(
            monster, "deck", user, deck_number, 0, 0, mine_or_other
        )
        monster_det = Monster.objects.get(id=id)
        eternals = monster_det.eternal_effect.all()
        place_unique_id = monster["place_unique_id"]
        for eternal in eternals:
            tmps = json.loads(eternal.eternal_monster)
            tmps = tmps["monster"]
            tmp = {}
            tmp["eternal"] = copy.deepcopy(eternal)
            tmp["monster"] = monster
            tmp["effect_val"] = eternal.eternal_effect_val
            tmp["kind"] = eternal.eternal_kind
            tmp["priority"] = eternal.priority
            tmp["user"] = mine_or_other
            if "already" in monster:
                tmp["already"] = monster["already"]
            else:
                tmp["already"] = 0
            tmp["place"] = "deck"
            tmp["deck_id"] = deck_id
            tmp["x"] = 0
            tmp["y"] = 0
            tmp["place_unique_id"] = place_unique_id
            tmp["index"] = index
            tmp["mine_or_other"] = mine_or_other
            return_eternal.append(tmp)
        for val_eternal in v_e:
            eternal_name = val_eternal.eternal_variable
            val_equation = val_eternal.eternal_variable_equation
            tmp2 = monster["variables"]
            val = 0
            if eternal_name in tmp2:
                eternal_name = self.check_swap_val(
                    monster, mine_or_other, "deck", deck_id, 0, 0, eternal_name, 1
                )
                eternal_name2 = self.check_swap_init_val(
                    monster, mine_or_other, "deck", deck_id, 0, 0, eternal_name, 1
                )
                val += int(tmp2[eternal_name2]["value"])
            val = self.check_change_val(
                monster, mine_or_other, "deck", deck_id, 0, 0, eternal_name, 1,val
            )
            if val_equation == 0:
                if val == val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "deck"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 1:
                if val <= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "deck"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 2:
                if val >= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "deck"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)
            elif val_equation == 3:
                if val != val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["kind"] = eternal.eternal_kind
                    tmp["priority"] = eternal.priority
                    tmp["user"] = mine_or_other
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    tmp["place"] = "deck"
                    tmp["deck_id"] = deck_id
                    tmp["x"] = 0
                    tmp["y"] = 0
                    tmp["place_unique_id"] = place_unique_id
                    tmp["index"] = index
                    tmp["mine_or_other"] = mine_or_other
                    return_eternal.append(tmp)

        return return_eternal

    def modify_deck_info(self, deck_info, count, user, other_user, priority, mode=0,mode2=0):
        force_num = 0
        return_value = False
        for i in range(count):
            flag = self.modify_deck_info_det(
                deck_info[i], i, user, other_user, priority, mode,mode2
            )
            if mode == 1 :
                if flag == True:
                    return_value = True
                force_num += flag[1]
            elif mode == 0: 
                deck_info = flag[0]
                force_num += flag[1]
        if mode == 1:
            return [False,force_num]
        return [deck_info,force_num]

    def modify_deck_info_det(
        self, deck_info, deck_number, user, other_user, priority, mode=0,mode2 = 0
    ):
        force_num = 0
        return_value = False
        if deck_info["invoke"] is False:
            if mode == 1:
                return [False,0]
            else:
                return [deck_info,0]
        if "mydeck" in deck_info and (user == self.user or mode2 == 0):
            if self.user == 1:
                mine_or_other = 1
            else:
                mine_or_other = 2
            for i in range(deck_info["mydecknum"]):
                tmp = self.check_deck_trigger(
                    deck_info["mydeck"][i],
                    deck_number,
                    user,
                    other_user,
                    mine_or_other,
                    deck_number + 1,
                    priority,
                    mode,
                )
                if mode == 1:
                    if tmp[0] is True:
                        return_value =  True
                        force_num += tmp[1]
                elif mode == 0:
                    deck_info["mydeck"][i] = tmp[0]
                    force_num += tmp[1]
        if "otherdeck" in deck_info and (other_user == self.user or mode2 == 0):
            if self.user == 1:
                mine_or_other = 2
            else:
                mine_or_other = 1
            for i in range(deck_info["otherdecknum"]):
                tmp = self.check_deck_trigger(
                    deck_info["otherdeck"][i],
                    deck_number,
                    user,
                    other_user,
                    mine_or_other,
                    deck_number + 1,
                    priority,
                    mode,
                )
                if mode == 1 :
                    if tmp[0] is True:
                        return_value =  True
                        force_num += tmp[1]
                elif mode == 0:
                    deck_info["otherdeck"][i] = tmp[0]
                    force_num += tmp[1]

        if "commondeck" in deck_info:
            for i in range(deck_info["commondecknum"]):
                tmp = self.check_deck_trigger(
                    deck_info["commondeck"][i],
                    deck_number,
                    user,
                    other_user,
                    "0",
                    deck_number + 1,
                    priority,
                    mode,
                )
                if mode == 1:
                    if tmp[0] is True:
                        return_value =  True
                        force_num += tmp[1]
                elif mode == 0:
                    deck_info["commondeck"][i] = tmp[0]
                    force_num += tmp[1]
        if mode == 1:
            return False

        return [deck_info,force_num]

    def modify_grave_info(self, grave_info, count, user, other_user, priority, mode=0,mode2 = 0):
        force_num = 0
        return_value = False
        for i in range(count):
            tmp = self.modify_grave_info_det(
                grave_info[i], i, user, other_user, priority, mode,mode2
            )
            if mode == 1:
                if tmp[0] is True:
                    return_value = True
                force_num += tmp[1]
            else:
                grave_info[i] = tmp[0]
                force_num += tmp[1]
        if mode == 1:
            return [return_value,force_num]
        return [grave_info,force_num]
    
    def modify_hand_info(self, hand_info, count, user, other_user, priority, mode=0,mode2 = 0):
        force_num = 0
        return_value = False
        for i in range(count):
            tmp = self.modify_hand_info_det(
                hand_info[i], i, user, other_user, priority, mode,mode2
            )
            if mode == 1:
                if tmp[0] is True:
                    return_value = True
                force_num += tmp[1]

            else:
                hand_info[i] = tmp[0]
                force_num += tmp[1]
        if mode == 1:
            return [return_value,force_num]
        else:
            return [hand_info,force_num]
    def modify_grave_info_det(
            self, grave_info, grave_number, user, other_user, priority, mode=0,mode2=0
    ):
        return_value = False
        force_num = 0
        if grave_info["invoke"] is False:
            if mode == 1:
                return [False,0]
            else:
                return [grave_info,0]
        if "mygrave" in grave_info and (user == self.user or mode2 == 0):
            if self.user == 1:
                mine_or_other = 1
            else:
                mine_or_other = 2

            for i in range(grave_info["mygravenum"]):
                tmp = self.check_grave_trigger(
                    grave_info["mygrave"][i],
                    grave_number,
                    user,
                    other_user,
                    mine_or_other,
                    grave_number + 1,
                    priority,
                    mode,
                    )
                if mode == 1: 
                    if tmp[0] is True:
                        return_value = True
                        force_num += tmp[1]

                else:
                    grave_info["mygrave"][i] = tmp[0]
                    force_num += tmp[1]
        if "othergrave" in grave_info and (mode2 == 0 or other_user == self.user):
            if self.user == 1:
                mine_or_other = 2
            else:
                mine_or_other = 1
            for i in range(grave_info["othergravenum"]):
                tmp = self.check_grave_trigger(
                    grave_info["othergrave"][i],
                    grave_number,
                    other_user,
                    user,
                    mine_or_other,
                    grave_number + 1,
                    priority,
                    mode,
                    )
                if mode == 1 :
                    if tmp[0] is True:
                        return_value = True
                        force_num += tmp[1]
                else:
                    grave_info["othergrave"][i] = tmp[0]
                    force_num = tmp[1]
        if "commongrave" in grave_info:
            for i in range(grave_info["commongravenum"]):
                tmp = self.check_grave_trigger(
                    grave_info["commongrave"][i],
                    grave_number,
                    user,
                    other_user,
                    "0",
                    grave_number + 1,
                    priority,
                    mode,
                    )
                if mode == 1 :
                    if tmp[0] is True:
                        return_value = True
                        force_num += tmp[1]
                else:
                    grave_info["commongrave"][i] = tmp[0]
                    force_num += tmp[1]
        if mode == 1:
            return [return_value,force_num]
        return [grave_info,force_num]
    def modify_hand_info_det(
        self, hand_info, hand_number, user, other_user, priority, mode=0,mode2=0
    ):
        force_num = 0
        return_value = False
        if hand_info["invoke"] is False:
            if mode == 1:
                return [False,0]
            else:
                return [hand_info,0]
        if "myhand" in hand_info and (user == self.user or mode2 == 0):
            if self.user == 1:
                mine_or_other = 1
            else:
                mine_or_other = 2

            for i in range(hand_info["myhandnum"]):
                tmp = self.check_hand_trigger(
                    hand_info["myhand"][i],
                    hand_number,
                    user,
                    other_user,
                    mine_or_other,
                    hand_number + 1,
                    priority,
                    mode,
                )
                if mode == 1 :
                    if tmp[0] is True:
                        return_value =  True
                        force_num += tmp[1]
                else:
                    hand_info["myhand"][i] = tmp[0]
                    force_num += tmp[1]
        if "otherhand" in hand_info and (mode2 == 0 or other_user == self.user):
            if self.user == 1:
                mine_or_other = 2
            else:
                mine_or_other = 1
            for i in range(hand_info["otherhandnum"]):
                if hand_info["otherhand"][i]["card_unique_id"] == -1 and self.user == user:
                    continue
                tmp = self.check_hand_trigger(
                    hand_info["otherhand"][i],
                    hand_number,
                    user,
                    other_user,
                    mine_or_other,
                    hand_number + 1,
                    priority,
                    mode,
                )
                if mode == 1 :
                    if tmp[0] is True:
                        return_value =  True
                        force_num += tmp[1]
                else:
                    hand_info["otherhand"][i] = tmp[0]
                    force_num += tmp[1]
        if "commonhand" in hand_info:
            for i in range(hand_info["commonhandnum"]):
                tmp = self.check_hand_trigger(
                    hand_info["commonhand"][i],
                    hand_number,
                    user,
                    other_user,
                    "0",
                    hand_number + 1,
                    priority,
                    mode,
                )
                if mode == 1: 
                    if tmp[0] is True:
                        return_value =  True
                        force_num += tmp[1]
                else:
                    hand_info["commonhand"][i] = tmp[0]
                    force_num += tmp[1]
        if mode == 1:
            return  [return_value,force_num]
        return [hand_info,force_num]

    def check_field_eternal_det(
        self, monster, x, y, user, other_user, mine_or_other, v_e
    ):
        id = self.get_monster_id(monster, "field", user, 0, x, y, mine_or_other)
        monster_det = Monster.objects.get(id=id)
        field = self.field
        eternals = monster_det.eternal_effect.all()
        return_eternal = []
        place_unique_id = monster["place_unique_id"]
        for val_eternal in v_e:
            eternal = val_eternal
            eternal_name = val_eternal.eternal_variable
            val_equation = val_eternal.eternal_variable_equation
            tmp2 = monster["variables"]
            val = 0
            if eternal_name in tmp2:
                eternal_name = self.check_swap_val(
                    monster, mine_or_other, "field", 0, x, y, eternal_name, 1
                )
                eternal_name2 = self.check_swap_init_val(
                    monster, mine_or_other, "field", 0, x, y, eternal_name, 1
                )
                val += int(tmp2[eternal_name2]["value"])
            val = self.check_change_val(
                monster, mine_or_other, "field", 0, x, y, eternal_name, 1,val
            )
            if val_equation == 0:
                if val == val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["priority"] = val_eternal.priority
                    tmp["place"] = "field"
                    tmp["user"] = mine_or_other
                    tmp["mine_or_other"] = mine_or_other
                    tmp["x"] = x
                    tmp["y"] = y
                    tmp["place_unique_id"] = place_unique_id
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    if self.check_eternal_invalid(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        eternal.eternal_kind,
                        "field",
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                    ):
                        continue
                    return_eternal.append(tmp)
            elif val_equation == 1:
                if val <= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["priority"] = val_eternal.priority
                    tmp["place"] = "field"
                    tmp["user"] = mine_or_other
                    tmp["mine_or_other"] = mine_or_other
                    tmp["x"] = x
                    tmp["y"] = y
                    tmp["place_unique_id"] = place_unique_id
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    if self.check_eternal_invalid(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        eternal.eternal_kind,
                        "field",
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                    ):
                        continue
                    return_eternal.append(tmp)
            elif val_equation == 2:
                if val >= val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["priority"] = val_eternal.priority
                    tmp["place"] = "field"
                    tmp["user"] = mine_or_other
                    tmp["mine_or_other"] = mine_or_other
                    tmp["x"] = x
                    tmp["y"] = y
                    tmp["place_unique_id"] = place_unique_id
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    if self.check_eternal_invalid(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        eternal.eternal_kind,
                        "field",
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                    ):
                        continue
                    return_eternal.append(tmp)
            elif val_equation == 3:
                if val != val_eternal.eternal_variable_val:
                    tmp = {}
                    tmp["eternal"] = copy.deepcopy(val_eternal)
                    tmp["monster"] = monster
                    tmp["effect_val"] = val_eternal.eternal_effect_val
                    tmp["priority"] = val_eternal.priority
                    tmp["place"] = "field"
                    tmp["user"] = mine_or_other
                    tmp["mine_or_other"] = mine_or_other
                    tmp["x"] = x
                    tmp["y"] = y
                    tmp["place_unique_id"] = place_unique_id
                    if "already" in monster:
                        tmp["already"] = monster["already"]
                    else:
                        tmp["already"] = 0
                    if self.check_eternal_invalid(
                        field[x][y]["det"],
                        field[x][y]["mine_or_other"],
                        eternal.eternal_kind,
                        "field",
                        0,
                        x,
                        y,
                        field[x][y]["mine_or_other"],
                    ):
                        continue
                    return_eternal.append(tmp)
        for eternal in eternals:
            tmps = json.loads(eternal.eternal_monster)
            tmps = tmps["monster"]
            tmp = {}
            tmp["eternal"] = copy.deepcopy(eternal)
            tmp["monster"] = monster
            tmp["effect_val"] = eternal.eternal_effect_val
            tmp["priority"] = eternal.priority
            tmp["kind"] = eternal.eternal_kind
            tmp["place"] = "field"
            tmp["user"] = mine_or_other
            tmp["deck_id"] = 0
            tmp["x"] = x
            tmp["y"] = y
            tmp["place_unique_id"] = place_unique_id
            if "already" in monster:
                tmp["already"] = monster["already"]
            else:
                tmp["already"] = 0
            if self.check_eternal_invalid(
                field[x][y]["det"],
                field[x][y]["mine_or_other"],
                eternal.eternal_kind,
                "field",
                0,
                x,
                y,
                field[x][y]["mine_or_other"],
            ):
                continue
            return_eternal.append(tmp)
        return return_eternal

    def check_field_trigger(
        self, monster, x, y, user, other_user, mine_or_other, priority, mode=0
    ):
        force_num = 0
        duel = self.duel
        trigger_force = json.loads(duel.trigger_force)
        flag = False
        id = self.get_monster_id(monster, "field", user, 0, x, y, mine_or_other)
        monster_det = Monster.objects.get(id=id)
        triggers = monster_det.trigger.filter(priority=priority).all()
        triggers = triggers.filter(trigger_timing=False)
        if duel.is_ai is False:
            triggers = triggers.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            triggers = triggers.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        if duel.is_ai is True:
            if mine_or_other == 1:
                triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
            else:
                triggers = triggers.filter(Q(enemy_own = 1) | Q(enemy_own = 2))
        else:
            triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
        triggers = triggers.order_by("-storategy_priority")
        return_trigger = []
        phase = duel.phase
        turn = duel.user_turn
        place_unique_id = monster["place_unique_id"]
        tmp = None
        for trigger in triggers:
            if self.check_launch_trigger(
                trigger,
                phase,
                turn,
                user,
                other_user,
                mine_or_other,
                "field",
                place_unique_id,
                0,
                x,
                y,
            ):
                if mode == 1:
                    if trigger.force == 0 and (duel.is_ai is False or user == 1) :
                        pass
                        
                    else:
                        if trigger.force is True:
                            force_num += 1
                        if trigger.strategy != "":
                            if trigger.strategy in monster["variables"]:
                                tmp_variable = monster["variables"][trigger.strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, "field", 0, x, y, trigger.strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        monster_copy = copy.deepcopy(monster)
                        monster_copy["trigger"] = None
                        tmp = {}
                        tmp["monster"] = monster_copy
                        tmp["move_from"] = None
                        tmp["trigger"] = trigger.id
                        tmp["priority"] = trigger.priority
                        tmp["storategy_priority"] = trigger.storategy_priority
                        tmp["mine_or_other"] = mine_or_other
                        tmp["user"] = user
                        tmp["place"] = "field"
                        tmp["deck_id"] = 0
                        tmp["place_from"] = ""
                        tmp["deck_id_from"] = ""
                        tmp["x"] = x
                        tmp["y"] = y
                        tmp["from_x"] = 0
                        tmp["from_y"] = 0
                        tmp["strategy_value"] = value
                        trigger_force.append(tmp)
                        flag = True
                else:
                    tmp = {}
                    tmp["id"] = trigger.id
                    tmp["name"] = trigger.trigger_sentence
                    if trigger.force is True:
                        force_num += 1
                    return_trigger.append(tmp)
        duel.trigger_force = json.dumps(trigger_force)
        if mode == 1:
            return [flag,force_num]

        return [return_trigger,force_num]

    def check_deck_trigger(
        self,
        monster,
        deck_number,
        user,
        other_user,
        mine_or_other,
        deck_id,
        priority,
        mode=0,
    ):
        flag = False
        force_num = 0
        duel = self.duel
        return_trigger = []
        id = self.get_monster_id(
            monster, "deck", user, deck_number, 0, 0, mine_or_other
        )
        monster_det = Monster.objects.get(id=id)
        triggers = monster_det.trigger.filter(priority=priority).all()
        triggers = triggers.filter(trigger_timing=False)
        trigger_force = json.loads(duel.trigger_force)
        if duel.is_ai is False:
            triggers = triggers.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            triggers = triggers.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        if duel.is_ai is True:
            if user == 1:
                triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
            else:
                triggers = triggers.filter(Q(enemy_own = 1) | Q(enemy_own = 2))
        else:
            triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
        phase = duel.phase
        turn = duel.user_turn
        place_unique_id = monster["place_unique_id"]
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        for trigger in triggers:
            if self.check_launch_trigger(
                trigger,
                phase,
                turn,
                user,
                other_user,
                mine_or_other,
                "deck",
                place_unique_id,
                deck_id,
            ):
                if mode == 1:
                    if trigger.force == 1 or (duel.is_ai is True and user == 2):
                        force_num+=1
                        if trigger.strategy != "":
                            if trigger.strategy in monster["variables"]:
                               tmp_variable = monster["variables"][trigger.strategy]
                               if not tmp_variable["value"].isnumeric():
                                   tmp_variable["value"] = 0
                            else:
                               tmp_variable = {}
                               tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, "deck", deck_id, 0, 0, trigger.strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                            '''
                        self.invoke_trigger        (
                    trigger,
                    "deck",
                    monster,
                    mine_or_other,
                    user,
                    deck_id,
                    0,
                    0,
                )
                        '''
                        tmp = {}
                        tmp["monster"] = monster
                        tmp["move_from"] = None
                        tmp["trigger"] = trigger.id
                        tmp["priority"] = trigger.priority
                        tmp["storategy_priority"] = trigger.storategy_priority
                        tmp["mine_or_other"] = mine_or_other
                        tmp["user"] = user
                        tmp["place"] = "deck"
                        tmp["deck_id"] = deck_id
                        tmp["place_from"] = ""
                        tmp["deck_id_from"] = ""
                        tmp["x"] = 0
                        tmp["y"] = 0
                        tmp["from_x"] = 0
                        tmp["from_y"] = 0
                        tmp["strategy_value"] = 0
                        trigger_force.append(tmp)

                    flag = True
                tmp = {}
                tmp["id"] = trigger.id
                tmp["name"] = trigger.trigger_sentence
                return_trigger.append(tmp)

        duel.trigger_force = json.dumps(trigger_force)
        if mode == 1:
            return [flag,force_num]
        monster["trigger"] = return_trigger
        return [monster,force_num]

    def check_grave_trigger(
            self,
            monster,
            grave_number,
            user,
            other_user,
            mine_or_other,
            deck_id,
            priority,
            mode=0,
    ):
        duel = self.duel
        trigger_force = json.loads(duel.trigger_force)
        flag = False
        force_num = 0
        return_trigger = []
        id = self.get_monster_id(
            monster, "grave", user, grave_number, 0, 0, mine_or_other
        )
        monster_det = Monster.objects.get(id=id)
        triggers = monster_det.trigger.filter(priority=priority).all()
        triggers = triggers.filter(trigger_timing=False)
        if duel.is_ai is False:
            triggers = triggers.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            triggers = triggers.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        if duel.is_ai is True:
            if user == 1:
                triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
            else:
                triggers = triggers.filter(Q(enemy_own = 1) | Q(enemy_own = 2))
        else:
            triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
        phase = duel.phase
        turn = duel.user_turn
        place_unique_id = monster["place_unique_id"]
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        for trigger in triggers:
            if self.check_launch_trigger(
                    trigger,
                    phase,
                    turn,
                    user,
                    other_user,
                    mine_or_other,
                    "grave",
                    place_unique_id,
                    deck_id,
            ):
                if mode == 1:
                    if trigger.force == 1 or (duel.is_ai is True and user == 2):
                        force_num+=1
                        if trigger.strategy != "":
                            if trigger.strategy in monster["variables"]:
                                tmp_variable = monster["variables"][trigger.strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, "grave", deck_id, 0, 0, trigger.strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                            '''
                        self.invoke_trigger        (
                    trigger,
                    "deck",
                    monster,
                    mine_or_other,
                    user,
                    deck_id,
                    0,
                    0,
                )
                        '''
                        tmp = {}
                        tmp["monster"] = monster
                        tmp["move_from"] = None
                        tmp["trigger"] = trigger.id
                        tmp["priority"] = trigger.priority
                        tmp["storategy_priority"] = trigger.storategy_priority
                        tmp["mine_or_other"] = mine_or_other
                        tmp["user"] = user
                        tmp["place"] = "grave"
                        tmp["deck_id"] = deck_id
                        tmp["place_from"] = ""
                        tmp["deck_id_from"] = ""
                        tmp["x"] = 0
                        tmp["y"] = 0
                        tmp["from_x"] = 0
                        tmp["from_y"] = 0
                        tmp["strategy_value"] = 0
                        trigger_force.append(tmp)
                    flag = True

                tmp = {}
                tmp["id"] = trigger.id
                tmp["name"] = trigger.trigger_sentence
                if trigger.force is True:
                    force_num += 1
                return_trigger.append(tmp)

        duel.trigger_force = json.dumps(trigger_force)
        if mode == 1:
            return [flag,force_num]
        monster["trigger"] = return_trigger
        return [monster,force_num]
    def check_hand_trigger(
        self,
        monster,
        hand_number,
        user,
        other_user,
        mine_or_other,
        deck_id,
        priority,
        mode=0,
    ):
        force_num = 0
        duel = self.duel
        return_trigger = []
        id = self.get_monster_id(
            monster, "hand", user, hand_number, 0, 0, mine_or_other
        )
        monster_det = Monster.objects.get(id=id)
        triggers = monster_det.trigger.filter(priority=priority).all()
        triggers = triggers.filter(trigger_timing=False)
        trigger_force = json.loads(duel.trigger_force)
        if duel.is_ai is False:
            triggers = triggers.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            triggers = triggers.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        if duel.is_ai is True:
            if (user == 1 ):
                triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))
            else:
                triggers = triggers.filter(Q(enemy_own = 1) | Q(enemy_own = 2))
        else:
            triggers = triggers.filter(Q(enemy_own = 0) | Q(enemy_own = 1))

        phase = duel.phase
        turn = duel.user_turn
        place_unique_id = monster["place_unique_id"]
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        flag = False
        for trigger in triggers:
            if self.check_launch_trigger(
                trigger,
                phase,
                turn,
                user,
                other_user,
                mine_or_other,
                "hand",
                place_unique_id,
                deck_id,
            ):
                if mode == 1:
                    if trigger.force == 1 or (duel.is_ai is True and user == 2):
                        force_num += 1
                        if trigger.strategy != "":
                            if trigger.strategy in monster["variables"]:
                               tmp_variable = monster["variables"][trigger.strategy]
                               if not tmp_variable["value"].isnumeric():
                                   tmp_variable["value"] = 0
                            else:
                               tmp_variable = {}
                               tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, "hand", deck_id, 0, 0, trigger.strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                            '''
                        self.invoke_trigger        (
                    trigger,
                    "hand",
                    monster,
                    mine_or_other,
                    user,
                    deck_id,
                    0,
                    0,
                )
                        '''
                        tmp = {}
                        tmp["monster"] = monster
                        tmp["move_from"] = None
                        tmp["trigger"] = trigger.id
                        tmp["priority"] = trigger.priority
                        tmp["storategy_priority"] = trigger.storategy_priority
                        tmp["mine_or_other"] = mine_or_other
                        tmp["user"] = user
                        tmp["place"] = "hand"
                        tmp["deck_id"] = deck_id
                        tmp["place_from"] = ""
                        tmp["deck_id_from"] = ""
                        tmp["x"] = 0
                        tmp["y"] = 0
                        tmp["from_x"] = 0
                        tmp["from_y"] = 0
                        tmp["strategy_value"] = value if trigger.strategy_up_or_down == 0 else -value
                        trigger_force.append(tmp)
                    flag = True
                tmp = {}
                tmp["id"] = trigger.id
                tmp["name"] = trigger.trigger_sentence
                if trigger.force is True:
                    force_num+=1
                return_trigger.append(tmp)

        duel.trigger_force = json.dumps(trigger_force)
        if mode == 1:
            return [flag,force_num]
        monster["trigger"] = return_trigger
        return [monster,force_num]

    def check_launch_trigger_for_copy2(
        self,
        trigger,
        phase,
        turn,
        user,
        other_user,
        mine_or_other,
        place="",
        place_unique_id="",
        deck_id=0,
        x=0,
        y=0,
        timing=False,
        move_from=None,
        place_from=None,
        deck_id_from=0,
        from_x=0,
        from_y=0,
        org_monster=None,
        place_unique_id_exist=None,
    ):
        duel = self.duel
        chain = duel.chain
        mine_or_other = int(mine_or_other)
        if trigger is None:
            return None
        effect_kind = trigger.trigger_kind
        if place != "":
            monster = self.get_monster(
                place, place_unique_id, mine_or_other, user, deck_id, x, y
            )
            if monster is not None:
                if self.check_no_invoke(
                    monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
                ):
                    return False
            else:
                if self.check_no_invoke(
                    org_monster, user, effect_kind, place, deck_id, x, y, user, 0
                ):
                    return False

        else:
            monster = None
        effect_kind = trigger.trigger_kind
        if not self.check_ignore_chain_func(
            monster, user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if trigger.chain_kind == "0":
                if chain < trigger.chain:
                    return None
            elif trigger.chain_kind == "1":
                if chain > trigger.chain:
                    return None
            elif trigger.chain_kind == "2":
                if chain != trigger.chain:
                    return None

        effect_kind = trigger.trigger_kind
        if not self.check_ignore_chain_user_only_func(
            monster, user, effect_kind, place, deck_id, x, y, user, 1
        ):
            if trigger.chain_mine_or_other != 0 and duel.chain > 0:
                chain_user_ary = json.loads(self.duel.chain_user)
                chain_user = chain_user_ary[str(duel.chain - 1)]
                chain_user2 = chain_user
                if user == 2:
                    if chain_user == 1:
                        chain_user2 = 2
                    if chain_user == 2:
                        chain_user2 = 1
                if trigger.chain_mine_or_other != chain_user2:
                    return False
        if not self.check_ignore_chain_kind_func(
            monster, user, effect_kind, place, deck_id, x, y, user, 1
        ):
            if trigger.can_chain_kind != "":
                can_chain_kinds = trigger.can_chain_kind.split("_")
                chain_det_ary = json.loads(self.duel.chain_det_trigger)
                chain_det = chain_det_ary[str(self.duel.chain - 1)]
                trigger_before = Trigger.objects.get(id=chain_det)
                chain_kind = trigger_before.trigger_kind
                chain_kinds = chain_kind.split("_")
                if not self.check_effect_kind(can_chain_kinds, chain_kinds):
                    return False
        if not self.check_ignore_same_chain_func(
            monster, user, effect_kind, place, deck_id, x, y, user, 1
        ):
            if trigger.canbetwice is False:
                if self.duel.chain_det_trigger != "":
                    if trigger.id in json.loads(self.duel.chain_det_trigger).values():
                        return False
        if not self.check_ignore_same_monster_chain_func(
            monster, user, effect_kind, place, deck_id, x, y, user, 1
        ):
            if trigger.monstercanbetwice is False:
                if self.duel.chain_det != "":
                    messes = json.loads(self.duel.mess)
                    for mess in messes.values():
                        if (
                            "trigger" in mess
                            and mess["trigger"][0]["place_unique_id"] == place_unique_id
                        ):
                            return False
        if not self.check_ignore_same_monster_exist_chain_func(
            monster, user, effect_kind, place, deck_id, x, y, user, 1
        ):
            if trigger.existcanbetwice is False:
                if self.duel.chain_det != "":
                    messes = json.loads(self.duel.mess)
                    for mess in messes.values():
                        if (
                            "trigger_exist" in mess
                            and mess["trigger_exist"][0]["place_unique_id"]
                            == place_unique_id_exist
                        ):
                            return False
        if duel.phase not in trigger.phase.all():
            return None
        if self.check_trigger_condition(trigger, user, monster):
            return True
        else:
            return False

        return False

    def check_launch_trigger_ignore_chain_and_timing(
            self,
            trigger,
            phase,
            turn,
            user,
            other_user,
            mine_or_other,
            place="",
            place_unique_id="",
            deck_id=0,
            ignore_timing=None,
            x=0,
            y=0,
            timing=False,
            move_from=None,
            place_from=None,
            deck_id_from=0,
            from_x=0,
            from_y=0,
            org_monster=None,
            place_unique_id_exist=None):
        return self.check_launch_trigger(
            trigger,
            phase,
            turn,
            user,
            other_user,
            mine_or_other,
            place,
            place_unique_id,
            deck_id,
            x,
            y,
            timing,
            move_from,
            place_from,
            deck_id_from,
            from_x,
            from_y,
            org_monster,
            place_unique_id_exist,
            1,
            ignore_timing)

    def check_launch_trigger(
        self,
        trigger,
        phase,
        turn,
        user,
        other_user,
        mine_or_other,
        place="",
        place_unique_id="",
        deck_id=0,
        x=0,
        y=0,
        timing=False,
        move_from=None,
        place_from=None,
        deck_id_from=0,
        from_x=0,
        from_y=0,
        org_monster=None,
        place_unique_id_exist=None,
        ignore_chain = 0,
        ignore_timing = None,
        fusion = 0
    ):
        duel = self.duel
        if(trigger.once_per_duel):
            if not self.check_once_per_duel(trigger,user):
                return False
        if(trigger.once_per_turn):
            if not self.check_once_per_turn(trigger,user):
                return False
        if(trigger.once_per_turn_group):
            if not self.check_once_per_turn_group(trigger,user):
                return False
        chain = duel.chain
        virtual_chain = duel.virtual_chain
        mine_or_other = int(mine_or_other)
        effect_kind = trigger.trigger_kind
        if trigger is None:
            return None
        monster = None
        if place != "":
            monster = self.get_monster(
                place, place_unique_id, mine_or_other, user, deck_id, x, y
            )
        if monster is None and trigger.none_exist is True:
            monster = {}
            monster["det"] = None
        elif place != "":
            if monster is None  and trigger.none_exist is False:
                return False
            if not self.check_ignore_no_invoke_func(
                monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
            ):
                if move_from is not None:
                    if self.check_no_invoke(
                        move_from["det"],
                        user,
                        effect_kind,
                        place_from,
                        deck_id_from,
                        from_x,
                        from_y,
                        user,
                        1,
                    ):
                        return False
                if monster is not None:
                    if(trigger.once_per_turn_monster):
                        if not self.check_once_per_turn_monster(trigger,user,monster):
                            return False
                    if(trigger.once_per_turn_monster_group):
                        if not self.check_once_per_turn_monster_group(trigger,user,monster):
                            return False
                    if self.check_no_invoke(
                        monster["det"], user, effect_kind, place, deck_id, x, y, mine_or_other, 0
                    ):
                        return False
                else:
                    if(trigger.once_per_turn_monster):
                        if not self.check_once_per_turn_monster(trigger,user,org_monster):
                            return False
                    if(trigger.once_per_turn_monster_group):
                        if not self.check_once_per_turn_monster_group(trigger,user,org_monster):
                            return False
                    if self.check_no_invoke(
                        org_monster, user, effect_kind, place, deck_id, x, y, user, 0
                    ):
                        return False

        else:
            if self.check_no_invoke(
                None,
                user,
                effect_kind,
                "",
                0,
                0,
                0,
            ):
                return False
            monster = {}
            monster["det"] = None


        chain = duel.chain
        if not self.check_ignore_turn_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if trigger.turn != 0:
                if trigger.turn == 1:
                    if user != duel.user_turn:
                        return False
                elif trigger.turn == 2:
                    if user == duel.user_turn:
                        return False
        if trigger.no_chain is True: 
            if duel.chain > 0:
                return None
        if ignore_chain == 0 and not self.check_ignore_chain_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if int(trigger.chain_kind) == 0:
                if duel.virtual_chain < trigger.chain:
                    return None
            elif int(trigger.chain_kind) == 1:
                if duel.virtual_chain > trigger.chain:
                    return None
            elif int(trigger.chain_kind) == 2:
                if duel.virtual_chain != trigger.chain:
                    return None
        if not self.check_ignore_chain_user_only_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if trigger.chain_mine_or_other != 0 and duel.chain > 0:
                chain_user_ary = json.loads(self.duel.chain_user)
                chain_user = chain_user_ary[str(duel.chain - 1)]
                chain_user2 = chain_user
                if user == 2:
                    if chain_user == 1:
                        chain_user2 = 2
                    elif chain_user == 2:
                        chain_user2 = 1
                if trigger.chain_mine_or_other != chain_user2:
                    return False
        if not self.check_ignore_chain_kind_func(
            monster["det"], user, effect_kind, place, deck_id, y, user, 0
        ):
            if trigger.can_chain_kind != "" and duel.chain > 0:
                can_chain_kinds = trigger.can_chain_kind
                chain_det_ary = json.loads(self.duel.chain_det_trigger)
                chain_det = chain_det_ary[str(self.duel.chain - 1)]
                trigger_before = Trigger.objects.get(id=chain_det)
                chain_kind = trigger_before.trigger_kind
                if not self.check_effect_kind(can_chain_kinds, chain_kind):
                    return False
        if not self.check_ignore_same_chain_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if trigger.canbetwice is False:
                if self.duel.chain_det_trigger != "":
                    if trigger.id in json.loads(self.duel.chain_det_trigger).values():
                        return False
        if not self.check_ignore_same_monster_chain_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if trigger.monstercanbetwice is False:
                if self.duel.chain_det != "":
                    messes = json.loads(self.duel.mess)
                    for mess in messes.values():
                        if (
                            "trigger" in mess
                            and mess["trigger"][0]["place_unique_id"] == place_unique_id
                        ):
                            return False
        if not self.check_ignore_same_monster_exist_chain_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        ):
            if trigger.existcanbetwice is False:
                if self.duel.chain_det != "":
                    messes = json.loads(self.duel.mess)
                    for mess in messes.values():
                        if (
                            "trigger_exist" in mess
                            and mess["trigger_exist"][0]["place_unique_id"]
                            == place_unique_id_exist
                        ):
                            return False
        ignore_phases = self.check_ignore_phase_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        )
        if duel.phase not in ignore_phases:
            if duel.phase not in trigger.phase.all():
                return None
        """
        if not self.check_ignore_mine_or_other_func(monster,user,effect_kind,place,deck_id,x,y,user,0):
            if trigger.mine_or_other == 2:
                if  mine_or_other2 != 2:
                    return False;
            elif trigger.mine_or_other == 1:
                if  mine_or_other2 != 1:
                    return False;
        """
        if self.check_trigger_monster(trigger, user, monster,move_from) is False:
            return False
        ignore_timings = self.check_ignore_timing_func(
            monster["det"], user, effect_kind, place, deck_id, x, y, user, 0
        )
        if ignore_timing:
            for ignore_timing_det in ignore_timing:
                ignore_timing_det = Timing_det = Timing.objects.filter(id=ignore_timing_det).first()
                ignore_timings.append(ignore_timing_det)
        if trigger.trigger_timing is True and timing is False:
            return False
        if duel.timing is not None:
            if duel.timing not in ignore_timings:
                if duel.timing not in trigger.timing.all():
                    return False
        elif trigger.none_timing is False:
            return False
        if duel.timing2 is not None:
            if duel.timing2 not in ignore_timings:
                if duel.timing2 not in trigger.timing2.all():
                    return False
        elif trigger.none_timing2 is False:
            return False
        if duel.timing3 is not None:
            if duel.timing3 not in ignore_timings:
                if duel.timing3 not in trigger.timing3.all():
                    return False
        elif trigger.none_timing3 is False:
            return False
        if self.check_trigger_condition(trigger, user, monster):
            if fusion == 1 :
                return self.check_fusion(trigger,user,monster)
            elif duel.is_ai == False:
                return True
            elif user ==1:
                return True
            else:
                return self.check_fusion(trigger,user,monster)
        else:
            return False

        return False

    def check_fusion(self,trigger,user,monster):
        if trigger.fusion_flag is False:
            return True
        if self.get_fusion_monster(trigger.fusion_monster, user, trigger,1,0):
            return True
    def check_fusion_monster(self,fusion_monster,trigger,user,effect_flag = 0,strategy = "",strategy_up_or_down = ""):
        if trigger.instead_condition:
            instead_condition = json.loads(trigger.instead_condition)
            if self.check_monster_effect_condition(
                    instead_condition, 0, 2):
                instead = True
            else:
                instead = False
        else:
            instead = True
        trigger_fusion1 = json.loads(trigger.fusion1)
        if(trigger.instead1 and instead):
            instead1 = json.loads(trigger.instead1)
            instead_exclude1 = instead1["exclude"]
            min_equation_number1_instead = instead_fusion1["monster"][0]["min_equation_number"]
            max_equation_number1_instead = instead1["monster"][0]["max_equation_number"]
        else:
            min_equation_number1_instead = 0
            max_equation_number1_instead = 10000
            instead1 = None
            instead_exclude1 = None
        exclude1 = trigger_fusion1["exclude"]
        min_equation_number1 = 0
        min_equation_number2 = 0
        min_equation_number3 = 0
        max_equation_number1 = 0
        max_equation_number2 = 0
        max_equation_number3 = 0
        min_equation_number1 = trigger_fusion1["monster"][0]["min_equation_number"]
        max_equation_number1 = trigger_fusion1["monster"][0]["max_equation_number"]
        if(trigger.fusion2):
            trigger_fusion2 = json.loads(trigger.fusion2)
            exclude2 = trigger_fusion2["exclude"]
            min_equation_number2 = trigger_fusion2["monster"][0]["min_equation_number"]
            max_equation_number2 = trigger_fusion2["monster"][0]["max_equation_number"]

        else:
            trigger_fusion2 = None
        if(trigger.instead2 and instead):
            instead2 = json.loads(trigger.instead2)
            instead_exclude2 = instead2["exclude"]
            min_equation_number2_instead = instead2["monster"][0]["min_equation_number"]
            max_equation_number2_instead = instead2["monster"][0]["max_equation_number"]
        else:
            instead2 = None
            instead_exclude2 = None
            min_equation_number2_instead = 0
            max_equation_number2_instead = 10000
        if(trigger.fusion3):
            trigger_fusion3 = json.loads(trigger.fusion3)
            exclude3 = trigger_fusion3["exclude"]
            min_equation_number3 = trigger_fusion3["monster"][0]["min_equation_number"]
            max_equation_number3 = trigger_fusion3["monster"][0]["max_equation_number"]

        else:
            trigger_fusion3 = None
            min_equation_number3_instead = 0
            max_equation_number3_instead = 10000
        if(trigger.instead3 and instead):
            instead3 = json.loads(trigger.instead3)
            min_equation_number3_instead = instead3["monster"][0]["min_equation_number"]
            max_equation_number3_instead = instead3["monster"][0]["max_equation_number"]
            instead_exclude3 = instead3["exclude"]
        else:
            min_equation_number3_instead = 0
            max_equation_number3_instead = 10000
            instead3 = None
            instead_exclude3 = None
        monster_id = self.get_monster_id(
            fusion_monster["det"], fusion_monster["place"], fusion_monster["det"]["owner"],fusion_monster["deck_id"],fusion_monster["x"], fusion_monster["y"], fusion_monster["mine_or_other"])
        fusions = Fusion.objects.filter(monster__id=monster_id).all()
        if fusions is None:
            return False
        return_fusion = []
        for fusion in fusions:
            fusion1 = json.loads(fusion.fusion1)
            exclude2_1 = fusion1["exclude"]

            min_equation_number1 = max(min_equation_number1,fusion1["monster"][0]["min_equation_number"])
            max_equation_number1 = min(max_equation_number1,fusion1["monster"][0]["max_equation_number"])
            if(fusion.fusion2):
                fusion2 = json.loads(fusion.fusion2)
                exclude2_2 = fusion2["exclude"]

                min_equation_number2 = max(min_equation_number2,fusion2["monster"][0]["min_equation_number"])
                max_equation_number2 = min(max_equation_number2,fusion2["monster"][0]["max_equation_number"])
            else:
                fusion2 = None
                exclude2_2 = None
            if(fusion.fusion3):
                fusion3 = json.loads(fusion.fusion3)
                exclude2_3 = fusion3["exclude"]

                min_equation_number3 = max(min_equation_number3,fusion3["monster"][0]["min_equation_number"])
                max_equation_number3 = min(max_equation_number3,fusion3["monster"][0]["max_equation_number"])
            else:
                fusion3 = None
                exclude2_3 = None
            if not fusion1 or not trigger_fusion1:
                fusion_monster1 =[]
            else:
                fusion_monster1 = self.check_fusion_monster_det(trigger_fusion1,fusion1,instead1,
                        fusion_monster,user,
                        exclude1 = exclude1,
                        instead_exclude = instead_exclude1,
                        exclude2 = exclude2_1,effect_flag = effect_flag)
                if fusion_monster1 is False:
                    continue
            if int(min_equation_number1) > int(max_equation_number1):
                    continue
            if int(min_equation_number2) > int(max_equation_number2):
                    continue
            if int(min_equation_number3) > int(max_equation_number3):
                    continue
            if fusion_monster1 is False:
                    continue
            if not fusion2 or not trigger_fusion2:
                fusion_monster2 = []
            else: 
                fusion_monster2 = self.check_fusion_monster_det(trigger_fusion2,fusion2,instead2,
                        fusion_monster,user,
                        exclude1 = exclude2,
                        instead_exclude = instead_exclude2,
                        exclude2 = exclude2_2,effect_flag = effect_flag)
                if fusion_monster2 is False:
                    continue
            if not fusion3 or not trigger_fusion3:
                fusion_monster3 = []
            else:
                fusion_monster3 = self.check_fusion_monster_det(trigger_fusion3,fusion3,instead3,
                        fusion_monster,user,
                        exclude1 = exclude3,
                        instead_exclude = instead_exclude3,
                        exclude2 = exclude2_3,effect_flag = effect_flag)
                if fusion_monster3 is False:
                    continue
            if self.fusion_cross_check(fusion_monster1,fusion_monster2,fusion_monster3,min_equation_number1,min_equation_number2,min_equation_number3,0,min_equation_number1_instead,min_equation_number2_instead,min_equation_number3_instead,max_equation_number1_instead,max_equation_number2_instead,max_equation_number3_instead):
                ary = {}
                ary["id"] = fusion.id
                ary["sentence"] = fusion.fusion_sentence
                return_fusion.append(ary)
        return return_fusion
    def     fusion_cross_check(self,fusion_monster1,fusion_monster2,fusion_monster3,min_equation_number1,min_equation_number2,min_equation_number3,mode=0,min_equation_number1_instead = 0,min_equation_number2_instead = 0,min_equation_number3_instead = 0,max_equation_number1_instead = 0,max_equation_number2_instead = 0,max_equation_number3_instead = 0):
            min_equation_number1 = int(min_equation_number1)
            min_equation_number2 = int(min_equation_number2)
            min_equation_number3 = int(min_equation_number3)
            ary_1 = []
            ary_2 = []
            ary_3 = []
            if fusion_monster1  != [] and fusion_monster1["monster"] != []:
                max_equation_number1 = fusion_monster1["max"]
                fusion_monster1 = fusion_monster1["monster"]
                flag1 = False
            else:
                max_equation_number1 = 100000
                fusion_monster1 = []
                flag1 = True
            if fusion_monster2  != [] and fusion_monster2["monster"] != []:
                max_equation_number2 = fusion_monster2["max"]
                fusion_monster2 = fusion_monster2["monster"]
                flag2 = False
            else:
                max_equation_number2 = 100000
                fusion_monster2 = []
                flag2 = True
            
            if fusion_monster3  != [] and fusion_monster3["monster"] != []:
                max_equation_number3 = fusion_monster3["max"]
                fusion_monster3 = fusion_monster3["monster"]
                flag3 = False
            else:
                max_equation_number3 = 100000
                fusion_monster3 = []
                flag3 = True
            tmp_fusion_monster1 = []
            tmp_fusion_monster2 = []
            tmp_fusion_monster3 = []
            instead_val1 = 0
            instead_val2 = 0
            instead_val3 = 0
            for  monster1 in fusion_monster1 :
                if monster1["instead"] == 1 and instead_val1 >= int(max_equation_number1_instead):
                    continue
                elif monster1["instead"] == 1 :
                    instead_val1 += 1
                tmp_fusion_monster1.append(monster1)
                if len(tmp_fusion_monster1) >= min_equation_number1:
                    flag1 = True
                    break
            for  monster2 in fusion_monster2 :
                if monster2["instead"] == 1 and instead_val2 >= int(max_equation_number2_instead):
                    continue
                elif monster2["instead"] == 1:
                    instead_val2 += 1
                if monster2 in tmp_fusion_monster1:
                    continue
                tmp_fusion_monster2.append(monster2)
                if len(tmp_fusion_monster2) >= min_equation_number2:
                    flag2 = True
                    break
            for  monster3 in fusion_monster3 :
                if monster3["instead"] == 1 and instead_val3 >= int(max_equation_number3_instead):
                    continue
                elif monster3["instead"] == 1:
                    instead_val3 += 1
                if monster3 in tmp_fusion_monster1:
                    continue
                if monster3 in tmp_fusion_monster2:
                    continue
                tmp_fusion_monster2.append(monster2)
                tmp_fusion_monster3.append(monster3)
                if len(tmp_fusion_monster3) >= min_equation_number3:
                    flag3 =True
                    break
            if flag1 is False or flag2 is False or flag3 is False:
               return False
            return [tmp_fusion_monster1,tmp_fusion_monster2,tmp_fusion_monster3]
    def is_last(self,length,ary):
        if length == 0:
            return True
        if(ary[0] == length - len(ary)):
            return True
        return False
    def next_ary(self,ary,length):
        k = 0
        for i in reversed(range(len(ary))):
            if ary[i] + k == length: 
                continue
            else:
                j = i
                while j < len(ary):
                    ary[j] +=1
                    j+=1
                return  ary
            k+=1
        return ary




    def check_fusion_material(self,monsters,trigger_fusion_condition,fusion_condition,instead):
        duel = self.duel
        user = self.user
        if(fusion_condition is not None):
            exclude = fusion_condition["exclude"]
            min_equation_number = int(fusion_condition["monster"][0]["min_equation_number"])
            max_equation_number = int(fusion_condition["monster"][0]["max_equation_number"])
            if fusion_condition["monster"][0]["as_monster_condition"] == "trigger":
                    trigger = fusion_monster
                    trigger_flag = False
            place1 = fusion_condition["monster"][0]["monster"]["place"]
        else:
            min_equation_number = -1
            max_equation_number = 10000
        if(trigger_fusion_condition is not None):
            exclude2 = trigger_fusion_condition["exclude"]
            min_equation_number2 = int(trigger_fusion_condition["monster"][0]["min_equation_number"])
            max_equation_number2 = int(trigger_fusion_condition["monster"][0]["max_equation_number"])
            if trigger_fusion_condition["monster"][0]["as_monster_condition"] == "trigger":
                    trigger = trigger_fusion_monster
                    trigger_flag = False
            place2 = trigger_fusion_condition["monster"][0]["monster"]["place"]
        else:
            min_equation_number2 = -1
            max_equation_number2 = 10000
        if min_equation_number < min_equation_number2:
            min_equation_number = min_equation_number2
        if max_equation_number > max_equation_number2:
            max_equation_number = max_equation_number2
        if len(monsters) < min_equation_number or len(monsters) > max_equation_number:
            return False
        instead_val = 0
        for monster in monsters:
            if not self.validate_place(fusion_condition,monster,user) or  not self.validate_answer( monster, fusion_condition["monster"][0]["monster"], exclude, duel
                ):
                return False
            if not self.validate_place(trigger_fusion_condition,monster,user) or not self.validate_answer(
                    monster, trigger_fusion_condition["monster"][0]["monster"], exclude2, duel
                    ):
                if instead and self.validate_place(instead,monster,user) and self.validate_answer( monster, instead["monster"][0]["monster"], exclude2, duel
                        ):
                    instead_val += 1
                else:
                    return False
        if instead:
            min_equation_number_instead = int(instead["monster"][0]["min_equation_number"])
            max_equation_number_instead = int(instead["monster"][0]["max_equation_number"])
            if instead_val < min_equation_number_instead:
                return False
            if instead_val > max_equation_number_instead:
                return False

        return True

    def check_fusion_monster_det(self,trigger_fusion_condition,fusion_condition,instead_condition,fusion_monster,user,already_monsters = [],mode = 0,exclude1 = "",exclude2="",instead_exclude = "",effect_kind = None,effect_flag = 0,strategy = "",strategy_up_or_down = 0):
        duel = self.duel
        trigger_flag = True
        return_monster = []
        trigger = None
        place1 = None
        place2 = None
        instead_place = None
        if effect_flag == 1:
            minus_chain =  -1
        else:
            minus_chain = 0 
        if(fusion_condition is not None):
            min_equation_number = int(fusion_condition["monster"][0]["min_equation_number"])
            max_equation_number = int(fusion_condition["monster"][0]["max_equation_number"])
            if fusion_condition["monster"][0]["as_monster_condition"] == "trigger":
                    trigger = fusion_monster
                    trigger_flag = False
            place1 = fusion_condition["monster"][0]["monster"]["place"]
            monster_effect_det2 = fusion_condition
        else:
            min_equation_number = -1
            max_equation_number = 10000
        if(trigger_fusion_condition is not None):
            min_equation_number2 = int(trigger_fusion_condition["monster"][0]["min_equation_number"])
            max_equation_number2 = int(trigger_fusion_condition["monster"][0]["max_equation_number"])
            if trigger_fusion_condition["monster"][0]["as_monster_condition"] == "trigger":
                    trigger = trigger_fusion_monster
                    trigger_flag = False
            place2 = trigger_fusion_condition["monster"][0]["monster"]["place"]
        else:
            min_equation_number2 = -1
            max_equation_number2 = 10000
        if min_equation_number < min_equation_number2:
            min_equation_number = min_equation_number2
        if max_equation_number > max_equation_number2:
            max_equation_number = max_equation_number2
        place3 = []
        if place1 and place2:
            for place_tmp in place1:
                if place_tmp in place2:
                    place3.append(place_tmp)
        elif place1:
            place3 = place1
        elif place2:
            place3 = place2
        else:
            place3 = []
        if instead_condition:
            instead_place_tmp = instead_condition["monster"][0]["monster"]["place"]
            instead_place = []
            max_equation_number_instead = int(instead_condition["monster"][0]["max_equation_number"])
            if place1 and instead_place_tmp:
                for place_tmp in place1:
                    if place_tmp in instead_place_tmp:
                        instead_place.append(place_tmp)
            elif place1:
                instead_place = place1
            elif place2:
                instead_place = instead_place_tmp
            else:
                instead_place = []
                    
        field_tmp = []
        if trigger_fusion_condition is not None:
            trigger_fusion_condition = trigger_fusion_condition["monster"][0]
        if fusion_condition is not None:
            fusion_condition = fusion_condition["monster"][0]
        monster_effect_det2 = trigger_fusion_condition
        instead_val = 0
        if instead_condition:
            for place in instead_place:
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                tmp_deck = None
                if place_tmp[0] == "deck":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain+minus_chain )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3

                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        deck_name = self.decks[deck_id]["deck_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "grave":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain+minus_chain  )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_deck = self.get_grave_with_effect(
                                self.decks[grave_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["commongrave"]
                        deck_name = self.graves[deck_id]["grave_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "hand":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain+minus_chain   )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.decks[hand_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                instead_exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["commonhand"]
                        deck_name = self.hands[deck_id]["hand_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "field":
                    field = self.field
                    tmp_deck = False
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    effect_user = user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            if strategy != "": 
                                if strategy in field[x][y]["det"]["variables"]:
                                    tmp_variable = field[x][y]["det"]["variables"][strategy]
                                    if not tmp_variable["value"].isnumeric():
                                         tmp_variable["value"] = 0
                                else:
                                    tmp_variable = {}
                                    tmp_variable["value"] = 0
                                value = self.check_change_val(
                        field[x][y]["det"], user, "field", 0, x, y, strategy, mine_or_other, int(tmp_variable["value"])
                    )
                            else: 
                                value = 0
                            fusion_monster = {}
                            fusion_monster["det"] = field[x][y]["det"]
                            fusion_monster["instead"] = 1
                            fusion_monster["mine_or_other"] = field[x][y]["mine_or_other"]
                            fusion_monster["user"] = user
                            fusion_monster["place"] = "field"
                            fusion_monster["deck_id"] = 0
                            fusion_monster["x"] = x
                            fusion_monster["y"] = y
                            fusion_monster["strategy_value"] = value
                            fusion_monster["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.validate_answer(
                                fusion_monster, fusion_condition["monster"], instead_exclude, duel
                                ):
                                if self.validate_answer(
                                    fusion_monster, instead_condition["monster"][0]["monster"], instead_exclude, duel
                                    ):
                                    if fusion_monster not in already_monsters:
                                        if fusion_monster == trigger:
                                            trigger_flag = True
                                        return_monster.append(fusion_monster)
                                        instead_val += 1
                if not tmp_deck:
                    continue
                for tmp_fusion_monster in tmp_deck:
                        if strategy != "": 
                            tmptmpdeck = org_deck[tmp_fjusion_monster]
                            if strategy in tmptmpdeck["variables"]:
                                tmp_variable = tmptmpdeck["variables"][strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                tmptmpdeck, user, place_tmp[0], deck_id, 0, 0, strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        fusion_monster = {}
                        fusion_monster["det"] = user_decks[tmp_fusion_monster]
                        fusion_monster["mine_or_other"] = mine_or_other
                        fusion_monster["user"] = user
                        fusion_monster["place"] = place_tmp[0]
                        fusion_monster["deck_id"] = deck_id
                        fusion_monster["deck_name"] = deck_name
                        fusion_monster["x"] = 0
                        fusion_monster["instead"] = 1
                        fusion_monster["y"] = 0
                        fusion_monster["strategy_value"] = value
                        fusion_monster["place_unique_id"] = user_decks[tmp_fusion_monster][
                            "place_unique_id"
                        ]
                        if self.validate_answer(
                            fusion_monster, fusion_condition["monster"], exclude1, duel
                            ):
                            if self.validate_answer(
                                fusion_monster, instead_condition["monster"][0]["monster"], instead_exclude, duel
                                ):
                               if fusion_monster == trigger:
                                   trigger_flag = True
                               return_monster.append(fusion_monster)
                               instead_val += 1
        for place in place3:
                
                place_tmp = place["det"].split("_")
                deck_id = int(place_tmp[1])
                tmp_deck = None
                if place_tmp[0] == "deck":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain+minus_chain )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["mydeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["otherdeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["otherdeck"]
                        else:
                            tmp_deck = self.get_deck_with_effect(
                                self.decks[deck_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "deck",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.decks[deck_id]["commondeck"]
                        deck_name = self.decks[deck_id]["deck_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "grave":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain+minus_chain  )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["mygrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_grave_with_effect(
                                self.graves[deck_id]["othergrave"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["othergrave"]
                        else:
                            tmp_deck = self.get_grave_with_effect(
                                self.decks[grave_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "grave",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.graves[deck_id]["commongrave"]
                        deck_name = self.graves[deck_id]["grave_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "hand":
                    chain_user2 = json.loads(duel.chain_user)
                    effect_user = chain_user2[str(duel.chain+minus_chain   )]
                    if tmp_deck is None:
                        if (place_tmp[2] == "1" and effect_user == 1) or (
                            place_tmp[2] == "2" and effect_user != 1
                        ):
                            mine_or_other = 1
                        elif (place_tmp[2] == "1" and effect_user != 1) or (
                            place_tmp[2] == "2" and effect_user == 1
                        ):
                            mine_or_other = 2
                        else:
                            mine_or_other = 3
                        if (place_tmp[2] == "1" and effect_user == self.user) or (
                            place_tmp[2] == "2" and effect_user != self.user
                        ):
                            mine_or_other2 = 1
                        elif (place_tmp[2] == "1" and effect_user != self.user) or (
                            place_tmp[2] == "2" and effect_user == self.user
                        ):
                            mine_or_other2 = 2
                        else:
                            mine_or_other2 = 3
                        if mine_or_other2 == 1:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["myhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            tmp_deck = self.get_hand_with_effect(
                                self.hands[deck_id]["otherhand"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["otherhand"]
                        else:
                            tmp_deck = self.get_hand_with_effect(
                                self.decks[hand_id]["commondeck"],
                                monster_effect_det2,
                                effect_kind,
                                exclude,
                                effect_user,
                                "hand",
                                deck_id,
                                0,
                                0,
                                mine_or_other,
                                0,
                            )
                            org_deck = self.hands[deck_id]["commonhand"]
                        deck_name = self.hands[deck_id]["hand_name"]
                        user_decks = org_deck
                elif place_tmp[0] == "field":
                    field = self.field
                    tmp_deck = False
                    field_tmp.append(place_tmp[1])
                    if place["and_or"] == "and":
                        continue
                    else:
                        field_tmp2 = field_tmp
                        field_tmp = []
                    effect_user = user
                    if (place_tmp[2] == "1" and effect_user == 1) or (
                        place_tmp[2] == "2" and effect_user == 2
                    ):
                        mine_or_other2 = 1
                    elif (place_tmp[2] == "1" and effect_user == 2) or (
                        place_tmp[2] == "2" and effect_user == 1
                    ):
                        mine_or_other2 = 2
                    else:
                        mine_or_other2 = 3
                    for x in range(len(field)):
                        for y in range(len(field[x])):
                            exclude = ""
                            field_kind_flag = True
                            if self.field_free is False:
                                kind = field[x][y]["kind"]
                            else:
                                kind = field[0][y]["kind"]
                            if kind != "":
                                tmp = kind.split("_")
                                for kind in field_tmp2:
                                    if kind not in tmp:
                                        field_kind_flag = False
                                        break

                            if field_kind_flag is False:
                                continue
                            if field[x][y]["mine_or_other"] != mine_or_other2:
                                continue
                            if field[x][y]["det"] is None:
                                continue
                            if strategy != "": 
                                if strategy in field[x][y]["det"]["variables"]:
                                    tmp_variable = field[x][y]["det"]["variables"][strategy]
                                    if not tmp_variable["value"].isnumeric():
                                         tmp_variable["value"] = 0
                                else:
                                    tmp_variable = {}
                                    tmp_variable["value"] = 0
                                value = self.check_change_val(
                        field[x][y]["det"], user, "field", 0, x, y, strategy, mine_or_other, int(tmp_variable["value"])
                    )
                            else: 
                                value = 0
                            fusion_monster = {}
                            fusion_monster["det"] = field[x][y]["det"]
                            fusion_monster["mine_or_other"] = field[x][y]["mine_or_other"]
                            fusion_monster["user"] = user
                            fusion_monster["instead"] = 0
                            fusion_monster["place"] = "field"
                            fusion_monster["deck_id"] = 0
                            fusion_monster["x"] = x
                            fusion_monster["y"] = y
                            fusion_monster["strategy_value"] = value
                            fusion_monster["place_unique_id"] = field[x][y]["det"][
                                "place_unique_id"
                            ]
                            if self.validate_answer(
                                fusion_monster, fusion_condition["monster"], exclude, duel
                                ):
                                if self.validate_answer(
                                    fusion_monster, trigger_fusion_condition["monster"], exclude2, duel
                                    ):
                                    if fusion_monster not in already_monsters:
                                        if fusion_monster == trigger:
                                            trigger_flag = True
                                        return_monster.append(fusion_monster)
                if not tmp_deck:
                    continue
                for tmp_fusion_monster in tmp_deck:
                        if strategy != "": 
                            tmptmpdeck = org_deck[tmp_fjusion_monster]
                            if strategy in tmptmpdeck["variables"]:
                                tmp_variable = tmptmpdeck["variables"][strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                tmptmpdeck, user, place_tmp[0], deck_id, 0, 0, strategy, mine_or_other, int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        fusion_monster = {}
                        fusion_monster["det"] = user_decks[tmp_fusion_monster]
                        fusion_monster["mine_or_other"] = mine_or_other
                        fusion_monster["instead"] = 0
                        fusion_monster["user"] = user
                        fusion_monster["place"] = place_tmp[0]
                        fusion_monster["deck_id"] = deck_id
                        fusion_monster["deck_name"] = deck_name
                        fusion_monster["x"] = 0
                        fusion_monster["y"] = 0
                        fusion_monster["strategy_value"] = value
                        fusion_monster["place_unique_id"] = user_decks[tmp_fusion_monster][
                            "place_unique_id"
                        ]
                        if self.validate_answer(
                            fusion_monster, fusion_condition["monster"], exclude, duel
                            ):
                            if self.validate_answer(
                                fusion_monster, trigger_fusion_condition["monster"], exclude2, duel
                                ):
                               if fusion_monster == trigger:
                                   trigger_flag = True
                               return_monster.append(fusion_monster)

        if instead_condition:
            instead_val_negative = min(0,max_equation_number_instead  - instead_val)
        else:
            instead_val_negative = 0
        if len(return_monster) + instead_val_negative < int(min_equation_number):             
            return False
        if trigger_flag is False:
            return False
        else:
            ret = {}
            ret["monster"] = return_monster
            ret["min"] = min_equation_number
            ret["max"] = max_equation_number
            return ret
    def get_monster(self, place, place_unique_id, mine_or_other, user, deck_id, x, y):
        tmp2 = {}
        flag = True
        if place == "field":
            field = self.field
            if field[x][y]["det"] is None:
                flag = False
            elif field[x][y]["det"]["place_unique_id"] != place_unique_id:
                flag  = False
            if self.config.sort is False and flag is False:
                return None
            elif self.config.sort is True and flag is False:
                flag2 = False
                for x_range in range(20):
                    if field[x_range][y]["det"] is None:
                        continue
            return True
        else:
            return False

        return False

    def get_monster(self, place, place_unique_id, mine_or_other, user, deck_id, x, y):
        tmp2 = {}
        flag = True
        if place == "field":
            field = self.field
            if field[x][y]["det"] is None:
                flag = False
            elif field[x][y]["det"]["place_unique_id"] != place_unique_id:
                flag  = False
            if self.config.sort is False and flag is False:
                return None
            elif self.config.sort is True and flag is False:
                flag2 = False
                for x_range in range(20):
                    if field[x_range][y]["det"] is None:
                        continue
                    elif field[x_range][y]["det"]["place_unique_id"] == place_unique_id:
                       x = x_range
                       flag2 = True
                       break
                if flag2 is False:
                    return None
                    
            monster = field[x][y]["det"]
            tmp2["det"] = monster
            tmp2["place_unique_id"] = monster["place_unique_id"]
            tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
            tmp2["user"] = user
            tmp2["place"] = place
            tmp2["x"] = x
            tmp2["y"] = y
            if self.field_free is False:
                kind = field[x][y]["kind"]
            else:
                kind = field[0][y]["kind"]
            tmp2["deck_id"] = kind
            monster = tmp2
            return monster

        mine_or_other = int(mine_or_other)
        if (mine_or_other == 1 and self.user == 1) or (
            mine_or_other == 2 and self.user != 1
        ):
            mine_or_other2 = 1
        elif (mine_or_other == 2 and 1 == self.user) or (
            mine_or_other == 1 and 2 == self.user
        ):
            mine_or_other2 = 2
        else:
            mine_or_other2 = 3
        mine_or_other = user

        if place == "deck":
            if mine_or_other2 == 1:
                deck = self.decks[deck_id]["mydeck"]
            elif mine_or_other2 == 2:
                deck = self.decks[deck_id]["otherdeck"]
            elif mine_or_other2 == 3:
                deck = self.decks[deck_id]["commondeck"]
            user_decks = deck
            for user_deck in user_decks:
                if place_unique_id == user_deck["place_unique_id"]:
                    monster = user_deck
                    tmp2["det"] = monster
                    tmp2["place_unique_id"] = monster["place_unique_id"]
                    tmp2["mine_or_other"] = monster["owner"]
                    tmp2["user"] = user
                    tmp2["place"] = place
                    tmp2["deck_id"] = deck_id
                    tmp2["x"] = 0
                    tmp2["y"] = 0
                    monster = tmp2
                    return monster
        if place == "grave":
            if mine_or_other2 == 1:
                grave = self.graves[deck_id]["mygrave"]
            elif mine_or_other2 == 2:
                grave = self.graves[deck_id]["othergrave"]
            elif mine_or_other2 == 3:
                grave = self.graves[deck_id]["commongrave"]
            user_graves = grave
            for user_grave in user_graves:
                if place_unique_id == user_grave["place_unique_id"]:
                    monster = user_grave
                    tmp2["det"] = monster
                    tmp2["place_unique_id"] = monster["place_unique_id"]
                    tmp2["mine_or_other"] = monster["owner"]
                    tmp2["user"] = user
                    tmp2["place"] = place
                    tmp2["deck_id"] = deck_id
                    tmp2["x"] = 0
                    tmp2["y"] = 0
                    monster = tmp2
                    return monster
        if place == "hand":
            if mine_or_other2 == 1:
                hand = self.hands[deck_id]["myhand"]
            elif mine_or_other2 == 2:
                hand = self.hands[deck_id]["otherhand"]
            elif mine_or_other2 == 3:
                hand = self.hands[deck_id]["commonhand"]
            user_hands = hand
            for user_hand in user_hands:
                if place_unique_id == user_hand["place_unique_id"]:
                    monster = user_hand
                    tmp2["det"] = monster
                    tmp2["place_unique_id"] = monster["place_unique_id"]
                    tmp2["mine_or_other"] = monster["owner"]
                    tmp2["user"] = user
                    tmp2["place"] = place
                    tmp2["deck_id"] = deck_id
                    tmp2["x"] = 0
                    tmp2["y"] = 0
                    monster = tmp2
                    return monster

    def validate_answer(
        self,
        monster2,
        effect_det,
        exclude,
        duel,
        choose=0,
        cost_flag=0,
        effect_kind="",
        user=1,
    ):
        monster = monster2["det"]
        cost = self.cost
        mess = self.mess
        if (choose == 1 or choose == 3) and effect_kind != "":
            if self.check_no_choose(
                monster2["det"],
                user,
                effect_kind,
                monster2["place"],
                monster2["deck_id"],
                monster2["x"],
                monster2["y"],
                monster2["mine_or_other"],
                cost_flag,
            ):
                return False
        if str(self.tmp_chain) in cost:
            cost = cost[str(self.tmp_chain)]
        else:
            cost = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []

        timing_mess = self.timing_mess
        if effect_det == "":
            return True
        flag = effect_det["flag"]
        if "under" in effect_det:
            if not self.check_under(effect_det["under"], monster, monster2):
                return False
        if flag:
            flag_det = int(flag["flag_det"])
            if flag["operator"] == "=":
                if monster["flag"] != int(flag_det):
                    return False
            elif flag["operator"] == "&":
                if monster["flag"] & int(flag_det) == 0:
                    return False
            elif flag["operator"] == "^":
                if monster["flag"] & int(flag_det) != 0:
                    return False
        if exclude != "":
            excludes = exclude.split(",")
            for exclude_det in excludes:
                if exclude_det[0] == "~":
                    if exclude_det in cost:
                        for cost_det in cost[exclude_det]:
                            if (
                                monster["place_unique_id"]
                                == cost_det["det"]["place_unique_id"]
                            ):
                                return False
                if exclude_det[0] == "%":
                    if exclude_det in timing_mess:
                        for timing_det in timing_mess[exclude_det]:
                            if (
                                monster["place_unique_id"]
                                == timing_det["det"]["place_unique_id"]
                            ):
                                return False
                if exclude_det in mess:
                    for mess_det in mess[exclude_det]:
                        if (
                            monster["place_unique_id"]
                            == mess_det["det"]["place_unique_id"]
                        ):
                            return False
        if "place_from" in effect_det and effect_det["place_from"] is not None:
            tmp_flag = False
            for place_from in effect_det["place_from"]:
                place_from_det = place_from["place"].split("_")
                if place_from_det[0] == "":
                    tmp_flag = True
                elif place_from_det[0] == "field":
                    if "from2" not in monster or monster["from2"] != "field":
                        continue
                    if int(place_from_det[1]) == int(monster["from_field_kind"]):
                        tmp_flag = True
                elif place_from_det[0] == monster["from"]:
                    if int(place_from_det[1]) == int(monster["from_deck_id"]):
                        tmp_flag = True
            if tmp_flag is False:
                return False
        if "turn_count" in effect_det and effect_det["turn_count"] != "":
            if self.calculate_boland(effect_det["turn_count"]) != monster["turncount"]:
                return False
        current_and_or = "and"
        monster_name_kind = effect_det["monster_name_kind"]
        name_flag = True
        monster_names = self.check_change_name(
            monster,
            monster2["mine_or_other"],
            monster2["place"],
            monster2["deck_id"],
            monster2["x"],
            monster2["y"],
            monster2["mine_or_other"],
        )
        name_flag2 = True
        for name_kind in monster_name_kind:
            if name_kind["monster_name"] != "":
                name_flag = False
                for monster_name in monster_names:
                    if name_kind["operator"] == "=":
                        if monster_name == self.get_name(
                            name_kind["monster_name"], 0, monster
                        ):
                            name_flag = True
                            break
                    elif name_kind["operator"] == "!=":
                        if monster_name != self.get_name(
                            name_kind["monster_name"], 0, monster
                        ):
                            name_flag = True
                            break

                    elif name_kind["operator"] == "like":
                        if (
                            monster_name.find(
                                self.get_name(name_kind["monster_name"], 0, monster)
                            )
                            != -1
                        ):
                            name_flag = True
                            break
                    elif name_kind["operator"] == "notlike":
                        if (
                            monster_name.find(
                                self.get_name(name_kind["monster_name"], 0, monster)
                            )
                            == -1
                        ):
                           name_flag = True
                           break
                if current_and_or == "or":
                    if name_flag is True:
                        name_flag2 = True
                if current_and_or == "and":
                    if name_flag is False:
                        name_flag2 = False
                current_and_or = name_kind["and_or"]

        if name_flag2 is False:
            return False
        monster_condition_val = effect_det["monster_condition"]
        for cond_det in monster_condition_val:
            cond_flag = True
            current_and_or = "and"

            for cond_val in cond_det:
                if not cond_val:
                    continue
                name = self.check_swap_val(
                    monster,
                    monster2["mine_or_other"],
                    monster2["place"],
                    monster2["deck_id"],
                    monster2["x"],
                    monster2["y"],
                    cond_val["name"],
                    monster2["mine_or_other"],
                )
                name2 = self.check_swap_init_val(
                    monster,
                    monster2["mine_or_other"],
                    monster2["place"],
                    monster2["deck_id"],
                    monster2["x"],
                    monster2["y"],
                    cond_val["name"],
                    monster2["mine_or_other"],
                )
                tmp = monster["variables"][name2]
                tmp_flag = True
                if not cond_val["num"].isnumeric() and not self.special_val(cond_val["num"][0]):
                    value = self.check_change_val(
                        monster,
                        monster2["mine_or_other"],
                        monster2["place"],
                        monster2["deck_id"],
                        monster2["x"],
                        monster2["y"],
                        name,
                        monster2["mine_or_other"],
                        tmp["value"]
                    )
                    if value.isnumeric():
                        if cond_val["operator"] == "!=":
                            if value == cond_val["num"]:
                                tmp_flag = False
                            else:
                                tmp_flag = True
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag
                            else:
                                cond_flag = False
                        else:
                            if cond_flag is True:
                                cond_flag = True
                            else:
                                cond_flag = tmp_flag
                        current_and_or = cond_val["and_or"]
                        continue
                    else:
                        if cond_val["operator"] == "=":
                            if value == cond_val["num"]:
                                tmp_flag = True
                            else:
                                tmp_flag = False
                        elif cond_val["operator"] == "!=":
                            if value == cond_val["num"]:
                                tmp_flag = False
                            else:
                                tmp_flag = True
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag
                            else:
                                cond_flag = False
                        else:
                            if cond_flag is True:
                                cond_flag = True
                            else:
                                cond_flag = tmp_flag
                        current_and_or = cond_val["and_or"]
                        continue
                if not tmp["value"].isnumeric():
                    value = self.check_change_val(
                        monster,
                        monster2["mine_or_other"],
                        monster2["place"],
                        monster2["deck_id"],
                        monster2["x"],
                        monster2["y"],
                        name,
                        monster2["mine_or_other"],
                        tmp["value"]
                    )
                    if cond_val["operator"] == "!=":
                        if cond_val["num"] == value:
                            tmp_flag = False
                        else:
                            tmp_flag = True
                    elif cond_val["operator"] == "":
                        values = value.split("_")
                        if cond_val["num"] in values:
                            tmp_flag = True
                        else:
                            tmp_flag = False
                    elif cond_val["operator"] != "=" :
                        tmp_flag = False
                    else:
                        if cond_val["num"] == value:
                            tmp_flag = True
                        else:
                            tmp_flag = False
                    if current_and_or == "and":
                        if cond_flag is True:
                            cond_flag = tmp_flag
                        else:
                            cond_flag = False
                    else:
                        if cond_flag is False:
                            cond_flag = tmp_flag
                        else:
                            cond_flag = True
                    current_and_or = cond_val["and_or"]
                    continue
                if cond_val["init"] == 0:
                    value = int(tmp["value"])

                    value = self.check_change_val(
                        monster,
                        monster2["mine_or_other"],
                        monster2["place"],
                        monster2["deck_id"],
                        monster2["x"],
                        monster2["y"],
                        name,
                        monster2["mine_or_other"],
                        value
                    )
                elif cond_val["init"] == 1:
                    value = tmp["i_val"]
                elif cond_val["init"] == 2:
                    value = tmp["i_i_val"]
                if self.is_float(value):
                    value = float(value)
                if tmp["minus"] is False and int(value) < 0:
                    value = 0
                if cond_val["operator"] == "=" : 
                    if int(value) != int(
                        self.calculate_boland(cond_val["num"], monster2, False)
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "":
                        cond_ary = cond_val["num"].split("_")
                        if str(int(value)) not in cond_ary:
                            tmp_flag = False
                elif cond_val["operator"] == "!==":
                        cond_ary = cond_val["num"].split("_")
                        if str(int(value)) in cond_ary:
                            tmp_flag = False
                elif cond_val["operator"] == "<=":
                    if int(value) > self.calculate_boland(
                        cond_val["num"], monster2, False
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == ">=":
                    if int(value) < self.calculate_boland(
                        cond_val["num"], monster2, False
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "!=":
                    if int(value) == self.calculate_boland(
                        cond_val["num"], monster2, False
                    ):
                        tmp_flag = False
                if current_and_or == "and":
                    if cond_flag is True:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = False

                else:
                    if cond_flag is False:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = True
                current_and_or = cond_val["and_or"]
                if current_and_or == "":
                    current_and_or = "and"
            if cond_flag is False:
                return False
        relations = effect_det["relation"]
        relation_kinds = effect_det["relation_kind"]
        if "relation_id" in effect_det:
            relate_monster = effect_det["relation_id"]
        else:
            relate_monster = []
            for tmp_for in relations:
                relate_monster.append(-1)
        if "relation_valid" in effect_det:
            relate_valid = effect_det["relation_valid"]
        else:
            relate_valid = []
            for tmp_for in relations:
                relate_valid.append("")

        relation_tos = effect_det["relation_to"]
        i = 0
        custom_monster_condition = effect_det["custom_monster_condition"]
        for cond_det in custom_monster_condition:
            cond_flag = True
            current_and_or = "and"
            tmp_flag = True
            for cond_val in cond_det:
                name = self.check_swap_val(
                    monster,
                    monster2["mine_or_other"],
                    monster2["place"],
                    monster2["deck_id"],
                    monster2["x"],
                    monster2["y"],
                    cond_val["name"],
                    monster["mine_or_other"],
                )
                value = self.check_change_val(
                    monster,
                    monster2["mine_or_other"],
                    monster2["place"],
                    monster2["deck_id"],
                    monster2["x"],
                    monster2["y"],
                    name,
                    monster["mine_or_other"],
                )
                value = float(value)
                if cond_val["operator"] == "=" or cond_val["operator"] == "":
                    if str(value) != str(self.calculate_boland(cond_val["num"], monster2, False,mode=1)):
                        tmp_flag = False
                elif cond_val["operator"] == "<=":
                    if int(value) > self.calculate_boland(
                        cond_val["num"], monster2, False,mode=1
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == ">=":
                    if int(value) < self.calculate_boland(
                        cond_val["num"], monster2, False,mode=1
                    ):
                        tmp_flag = False
                elif cond_val["operator"] == "!=":
                    if int(value) == self.calculate_boland(
                        cond_val["num"], monster2, False,mode=1
                    ):
                        tmp_flag = False
                if current_and_or == "and":
                    if cond_flag is True:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = False

                else:
                    if cond_flag is False:
                        cond_flag = tmp_flag
                    else:
                        cond_flag = True
                current_and_or = cond_val["and_or"]
                tmp_flag = True
            if cond_flag is False:
                return False
        i = -1
        if (
            "effect_valid" in effect_det
            and effect_det["effect_valid"] != ""
            and effect_det["effect_valid"] is not None
        ):
            if self.check_eternal_invalid(
                monster,
                monster2["mine_or_other"],
                str(effect_det["effect_valid"]),
                monster2["place"],
                monster2["deck_id"],
                monster2["x"],
                monster2["y"],
                monster2["mine_or_other"],
            ):
                return False
        if "monster_effect" in effect_det and (
            effect_det["monster_effect"] != 0
            and effect_det["monster_effect"] != "0"
            and effect_det["monster_effect"] != ""
            and effect_det["monster_effect"] is not None
        ):
            id = self.get_monster_id(
                monster,
                monster2["place"],
                monster["owner"],
                monster2["deck_id"],
                monster2["x"],
                monster2["y"],
                monster2["mine_or_other"],
            )
            monster_effect_monster_ary = str(effect_det["monster_effect"]).split("_")
            monster_effect_flag = False
            for monster_effect_monster in monster_effect_monster_ary:
                if monster_effect_monster[0] == "!":
                    if id == int(monster_effect_monster[1:]):
                        return False
                    else:
                        monster_effect_flag = True
                elif id == int(monster_effect_monster):
                    monster_effect_flag = True
                    break
            if monster_effect_flag is False:
                return False
        if (
            "monster_effect_kind" in effect_det
            and effect_det["monster_effect_kind"] != 0
        ):
            if self.check_eternal_invalid(
                monster,
                monster2["mine_or_other"],
                effect_det["monster_effect_kind"],
                monster2["place"],
                monster2["deck_id"],
                monster2["x"],
                monster2["y"],
                monster["mine_or_other"],
            ):
                return False
        for relation in relations:
            i += 1
            # relationが-2は存在しないことを示す
            if relation == "-2":
                if "rel" not in monster:
                    continue
                if relation_kinds[i] not in monster["rel"]:
                    continue
                for rel_monster in monster["rel"][relation_kinds[i]]:
                    if int(rel_monster["to"]) == int(relation_tos[i]):
                        return False
            else:
                if "rel" not in monster:
                    return False
                if relation_kinds[i] not in monster["rel"]:
                    return False
                rel_flag = False
                for rel_monster in monster["rel"][relation_kinds[i]]:
                    if relate_valid[i] != "":
                        rel_monster_det = rel_monster["monster"]
                        monster2 = self.get_monster(
                            rel_monster_det["place"],
                            rel_monster_det["place_unique_id"],
                            rel_monster_det["mine_or_other"],
                            rel_monster_det["user"],
                            rel_monster_det["deck_id"],
                            rel_monster_det["x"],
                            rel_monster_det["y"],
                        )
                        if self.check_eternal_invalid(
                                monster2["det"],
                                monster2["user"],
                                relate_valid[i],
                                monster2["place"],
                                monster2["deck_id"],
                                monster2["x"],
                                monster2["y"],
                                monster2["mine_or_other"],
                        ):
                            continue
                    if int(rel_monster["to"]) == int(relation_tos[i]):
                        if (
                            relate_monster[i] == ""
                            or relate_monster[i] == -1
                            or int(relate_monster[i])
                            == self.get_monster_id_easy(rel_monster["monster"]["det"])
                        ):
                            # -1はすべての種類に対応
                            if relation == "-1" or relation == "":
                                rel_flag = True
                                break
                            else:
                                if relation == rel_monster["name"]:
                                    rel_flag = True
                                    break
                if rel_flag is False:
                    return False
        return True

    def check_trigger_timing_sql(
        self,
        trigger_timing_table,
        owner,
        chain_user,
        from_mine_or_other,
        to_mine_or_other,
    ):
        relative_chain_user = []
        relative_from_mine_or_other = []
        relative_to_mine_or_other = []
        for type in range(6):
            if type == 0:
                user = owner
            elif type == 3:
                user = from_mine_or_other
            elif type == 4:
                user = to_mine_or_other
            elif type == 1:
                user = chain_user
            elif type == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            relative_from_mine_or_other.append(from_mine_or_other)
            if user == 2 and from_mine_or_other == 2:
                relative_from_mine_or_other[type] = 1
            elif user == 2 and from_mine_or_other == 1:
                relative_from_mine_or_other[type] = 2
            relative_to_mine_or_other.append(to_mine_or_other)
            if user == 2 and to_mine_or_other == 2:
                relative_to_mine_or_other[type] = 1
            elif user == 2 and to_mine_or_other == 1:
                relative_to_mine_or_other[type] = 2
            relative_chain_user.append(chain_user)
            if user == 2 and chain_user == 2:
                relative_chain_user[type] = 1
            elif user == 2 and chain_user == 1:
                relative_chain_user[type] = 2
        return_value = trigger_timing_table.filter(
            (
                (
                    (
                        Q(from_mine_or_other=relative_from_mine_or_other[0])
                        | Q(from_mine_or_other=0)
                    )
                    & (
                        Q(to_mine_or_other=relative_to_mine_or_other[0])
                        | Q(to_mine_or_other=0)
                    )
                    & Q(who=0)
                )
            )
            | (
                (
                    (
                        Q(from_mine_or_other=relative_from_mine_or_other[1])
                        | Q(from_mine_or_other=0)
                    )
                    & (
                        Q(to_mine_or_other=relative_to_mine_or_other[1])
                        | Q(to_mine_or_other=0)
                    )
                    & Q(who=1)
                )
            )
            | (
                (
                    (
                        Q(from_mine_or_other=relative_from_mine_or_other[2])
                        | Q(from_mine_or_other=0)
                    )
                    & (
                        Q(to_mine_or_other=relative_to_mine_or_other[2])
                        | Q(to_mine_or_other=0)
                    )
                    & Q(who=2)
                )
            )
            | (
                (
                    (
                        Q(from_mine_or_other=relative_from_mine_or_other[3])
                        | Q(from_mine_or_other=0)
                    )
                    & (
                        Q(to_mine_or_other=relative_to_mine_or_other[3])
                        | Q(to_mine_or_other=0)
                    )
                    & Q(who=3)
                )
            )
            | (
                (
                    (
                        Q(from_mine_or_other=relative_from_mine_or_other[4])
                        | Q(from_mine_or_other=0)
                    )
                    & (
                        Q(to_mine_or_other=relative_to_mine_or_other[4])
                        | Q(to_mine_or_other=0)
                    )
                    & Q(who=4)
                )
            )
            | Q(who=5)
        )
        return return_value

    def null_relation(
        self,
        move_to,
        org,
        place_to,
        place_from,
        to_deck_id,
        to_x,
        to_y,
        to_mine_or_other,
        chain_user,
        cost_or_effect,
    ):
        if "rel" not in org or org["rel"] is None:
            return
        for kind in org["rel"].keys():
            for rel_card in org["rel"][kind]:
                monster = rel_card["monster"]
                if monster["place"] == "field":
                    field = self.field
                    y = monster["y"]
                    x = -1
                    if self.config.sort is False:
                        x = monster["x"]
                    else:
                        field_size = FieldSize.objects.get(id=1)
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for tmp_x in range(field_x):
                            if field[tmp_x][y]["det"] is not None and field[tmp_x][y]["det"]["place_unique_id"] == monster["place_unique_id"]:
                                x = tmp_x
                    #もうすでにフィールドを離れていた時
                    if x == -1:
                        continue
                    det = field[x][y]["det"]
                    mine_or_other = field[x][y]["mine_or_other"]
                    if (
                        det is None
                        or "rel" not in det
                        or det["rel"] is None
                        or kind not in det["rel"]
                    ):
                        continue
                    del_key = []
                    for key in range(len(det["rel"][kind])):
                        relation_name = det["rel"][kind][key]["name"]
                        if (
                            det["rel"][kind][key]["monster"]["place_unique_id"]
                            == org["place_unique_id"]
                        ):
                            if place_to == "field" and place_from == "field":
                                tmp2 = {}
                                tmp2["det"] = move_to
                                tmp2["mine_or_other"] = field[to_x][to_y][
                                    "mine_or_other"
                                ]
                                tmp2["user"] = field[to_x][to_y]["mine_or_other"]
                                tmp2["place"] = "field"
                                tmp2["deck_id"] = 0
                                tmp2["x"] = to_x
                                tmp2["y"] = to_y
                                tmp2["place_unique_id"] = move_to["place_unique_id"]
                                det["rel"][kind][key]["monster"] = tmp2
                                field[x][y]["det"] = det
                            else:
                                self.raise_null_relation(
                                    det,
                                    org,
                                    kind,
                                    relation_name,
                                    key,
                                    "field",
                                    mine_or_other,
                                    0,
                                    x,
                                    y,
                                    place_to,
                                    to_deck_id,
                                    to_x,
                                    to_y,
                                    to_mine_or_other,
                                    cost_or_effect,
                                    chain_user,
                                    move_to,
                                    True
                                )
                                del_key.append(key)
                    for del_key_det in reversed(del_key):
                        del det["rel"][kind][del_key_det]
                elif monster["place"] == "deck":
                    mine_or_other = monster["mine_or_other"]
                    deck_id = monster["deck_id"]
                    if self.user == 1:
                        mine_or_other2 = mine_or_other
                    elif self.user == 2:
                        if mine_or_other == 1:
                            mine_or_other2 = 2
                        elif mine_or_other == 2:
                            mine_or_other2 = 1
                        else:
                            mine_or_other2 = mine_or_other
                    if mine_or_other2 == 1:
                        tmp = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        tmp = self.decks[deck_id]["otherdeck"]
                    else:
                        tmp = self.decks[deck_id]["commondeck"]
                    for index in range(len(tmp)):
                        det = tmp[index]
                        if det["place_unique_id"] == monster["place_unique_id"]:
                            if (
                                det is None
                                or "rel" not in det
                                or det["rel"] is None
                                or kind not in det["rel"]
                            ):
                                continue
                            del_key = []
                            for key in range(len(det["rel"][kind])):
                                relation_name = det["rel"][kind][key]["name"]
                                if (
                                    det["rel"][kind][key]["monster"]["place_unique_id"]
                                    == org["place_unique_id"]
                                ):
                                    if place_to == "field" and place_from == "field":
                                        tmp2 = {}
                                        tmp2["det"] = move_to
                                        tmp2["mine_or_other"] = field[to_x][to_y][
                                            "mine_or_other"
                                        ]
                                        tmp2["user"] = field[to_x][to_y][
                                            "mine_or_other"
                                        ]
                                        tmp2["place"] = "field"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = move_to[
                                            "place_unique_id"
                                        ]
                                        det["rel"][kind][key]["monster"] = tmp2
                                        field[x][y]["det"] = det
                                    else:
                                        self.raise_null_relation(
                                            det,
                                            org,
                                            kind,
                                            relation_name,
                                            key,
                                            "deck",
                                            mine_or_other,
                                            deck_id,
                                            0,
                                            0,
                                            place_to,
                                            to_deck_id,
                                            to_x,
                                            to_y,
                                            to_mine_or_other,
                                            cost_or_effect,
                                            chain_user,
                                            move_to,
                                            True
                                        )
                                        del_key.append(key)
                            for del_key_det in reversed(del_key):
                                del det["rel"][kind][del_key_det]
                            tmp[index] = det
                    if mine_or_other2 == 1:
                        self.decks[deck_id]["mydeck"] = tmp
                    elif mine_or_other2 == 2:
                        self.decks[deck_id]["otherdeck"] = tmp
                    else:
                        self.decks[deck_id]["commondeck"] = tmp
                elif monster["place"] == "grave":
                    mine_or_other = monster["mine_or_other"]
                    deck_id = monster["deck_id"]
                    if self.user == 1:
                        mine_or_other2 = mine_or_other
                    elif self.user == 2:
                        if mine_or_other == 1:
                            mine_or_other2 = 2
                        elif mine_or_other == 2:
                            mine_or_other2 = 1
                        else:
                            mine_or_other2 = mine_or_other
                    if mine_or_other2 == 1:
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        tmp = self.graves[deck_id]["othergrave"]
                    else:
                        tmp = self.graves[deck_id]["commongrave"]
                    for index in range(len(tmp)):
                        det = tmp[index]
                        if det["place_unique_id"] == monster["place_unique_id"]:
                            if (
                                det is None
                                or "rel" not in det
                                or det["rel"] is None
                                or kind not in det["rel"]
                            ):
                                continue
                            for key in range(len(det["rel"][kind].keys)):
                                relation_name = det["rel"][kind][key]["name"]
                                if (
                                    det["rel"][kind][key]["monster"]["place_unique_id"]
                                    == org["place_unique_id"]
                                ):
                                    if place_to == "field" and place_from == "field":
                                        tmp2 = {}
                                        tmp2["det"] = move_to
                                        tmp2["mine_or_other"] = field[to_x][to_y][
                                            "mine_or_other"
                                        ]
                                        tmp2["user"] = field[to_x][to_y][
                                            "mine_or_other"
                                        ]
                                        tmp2["place"] = "field"
                                        tmp2["deck_id"] = 0
                                        tmp2["x"] = x
                                        tmp2["y"] = y
                                        tmp2["place_unique_id"] = move_to[
                                            "place_unique_id"
                                        ]
                                        det["rel"][kind][key]["monster"] = tmp2
                                        field[x][y]["det"] = det
                                    else:
                                        self.raise_null_relation(
                                            det,
                                            org,
                                            kind,
                                            relation_name,
                                            key,
                                            "grave",
                                            mine_or_other,
                                            deck_id,
                                            0,
                                            0,
                                            place_to,
                                            to_deck_id,
                                            to_x,
                                            to_y,
                                            to_mine_or_other,
                                            cost_or_effect,
                                            chain_user,
                                            move_to,
                                            True
                                        )
                                        del_key.append(key)
                            for del_key_det in reversed(del_key):
                                del det["rel"][kind][del_key_det]
                            tmp[index] = det
                    if mine_or_other2 == 1:
                        self.graves[deck_id]["mygrave"] = tmp
                    elif mine_or_other2 == 2:
                        self.graves[deck_id]["othergrave"] = tmp
                    else:
                        self.graves[deck_id]["commongrave"] = tmp
                elif monster["place"] == "hand":
                    mine_or_other = monster["mine_or_other"]
                    deck_id = monster["deck_id"]
                    if self.user == 1:
                        mine_or_other2 = mine_or_other
                    elif self.user == 2:
                        if mine_or_other == 1:
                            mine_or_other2 = 2
                        elif mine_or_other == 2:
                            mine_or_other2 = 1
                        else:
                            mine_or_other2 = mine_or_other
                    if mine_or_other2 == 1:
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        tmp = self.hands[deck_id]["otherhand"]
                    else:
                        tmp = self.hands[deck_id]["commonhand"]
                    for index in range(len(tmp)):
                        det = tmp[index]
                        if det["place_unique_id"] == monster["place_unique_id"]:
                            if (
                                det is None
                                or "rel" not in det
                                or det["rel"] is None
                                or kind not in det["rel"]
                            ):
                                continue
                            for key in range(len(det["rel"][kind].keys)):
                                relation_name = det["rel"][kind][key]["name"]
                                if (
                                    det["rel"][kind][key]["monster"]["place_unique_id"]
                                    == org["place_unique_id"]
                                ):
                                    if place_to == "field" and place_from == "field":
                                        tmp2 = {}
                                        tmp2["det"] = move_to
                                        tmp2["mine_or_other"] = field[to_x][to_y][
                                            "mine_or_other"
                                        ]
                                        tmp2["user"] = field[to_x][to_y][
                                            "mine_or_other"
                                        ]
                                        tmp2["place"] = "field"
                                        tmp2["deck_id"] = deck_id
                                        tmp2["x"] = 0
                                        tmp2["y"] = 0
                                        tmp2["place_unique_id"] = move_to[
                                            "place_unique_id"
                                        ]
                                        det["rel"][kind][key]["monster"] = tmp2
                                        field[x][y]["det"] = det
                                    else:
                                        self.raise_null_relation(
                                            det,
                                            org,
                                            kind,
                                            relation_name,
                                            key,
                                            "hand",
                                            mine_or_other,
                                            deck_id,
                                            0,
                                            0,
                                            place_to,
                                            to_deck_id,
                                            to_x,
                                            to_y,
                                            to_mine_or_other,
                                            cost_or_effect,
                                            chain_user,
                                            move_to,
                                            True
                                        )
                                        del_key.append(key)
                            for del_key_det in reversed(del_key):
                                del det["rel"][kind][del_key_det]
                            tmp[index] = det
                    if mine_or_other2 == 1:
                        self.hands[deck_id]["myhand"] = tmp
                    elif mine_or_other2 == 2:
                        self.hands[deck_id]["otherhand"] = tmp
                    else:
                        self.hands[deck_id]["commonhand"] = tmp

    def accumulate_global(
        self, monster, change_val, cost_or_effect, effect_kind, chain_user, global_name
    ):
        tmp = {}
        tmp["monster"] = monster
        tmp["change_val"] = change_val
        tmp["cost_or_effect"] = cost_or_effect
        tmp["effect_kind"] = effect_kind
        tmp["user"] = chain_user
        tmp["variable_id"] = global_name["variable_id"]
        tmp["variable_how"] = global_name["variable_how"]
        tmp["mine_or_other"] = global_name["mine_or_other"]
        self.acc_global.append(tmp)

    def check_alt_val(self, monster_effect, effect_kind):
        duel = self.duel
        if duel.alt_global != "":
            alt_global = json.loads(duel.alt_global)
        else:
            alt_global = {}
        monster_effect = json.loads(monster_effect)
        variable_id = monster_effect["variable_name"].split("_")
        mine_or_other = int(variable_id[2])
        variable_id = variable_id[1]
        chain_user = json.loads(duel.chain_user)
        user = chain_user[str(duel.chain - 1)]
        if str(variable_id) in alt_global:
            if mine_or_other == 0:
                if "value" in alt_global[str(variable_id)]:
                    if self.check_effect_kind(
                        alt_global[str(variable_id)]["effect_kind"], effect_kind
                    ):
                        alt_val = alt_global[str(variable_id)]["value"]
                        if alt_val > 0:
                            return True
                        else:
                            return False
            if (mine_or_other == 1 and user == 1) or (mine_or_other == 2 and user == 2):
                if "1_value" in alt_global[str(variable_id)]:
                    if self.check_effect_kind(
                        alt_global[str(variable_id)]["effect_kind"], effect_kind
                    ):
                        alt_val = alt_global[str(variable_id)]["1_value"]
                        if alt_val > 0:
                            return True
                        else:
                            return False
            if (mine_or_other == 1 and user == 2) or (mine_or_other == 2 and user == 1):
                if "2_value" in alt_global[str(variable_id)]:
                    if self.check_effect_kind(
                        alt_global[str(variable_id)]["effect_kind"], effect_kind
                    ):
                        alt_val = alt_global[str(variable_id)]["2_value"]
                        if alt_val > 0:
                            return True
                        else:
                            return False
        return False

    def flush_acc(self, monster_effect):
        chain_user = json.loads(self.duel.chain_user)
        user = chain_user[str(self.duel.chain - 1)]
        variable = json.loads(self.duel.global_variable)
        change_val_flag = monster_effect.change_val_monster_flag
        change_val_all = 0
        variable = json.loads(self.duel.global_variable)
        for tmp in self.acc_global:
            monster = tmp["monster"]
            change_val = tmp["change_val"]
            cost_or_effect = tmp["cost_or_effect"]
            effect_kind = tmp["effect_kind"]
            variable_id = tmp["variable_id"]
            how = tmp["variable_how"]
            mine_or_other = tmp["mine_or_other"]
            if change_val_flag:
                self.raise_trigger_change_val(
                    monster, change_val, cost_or_effect, effect_kind, user, 1
                )
            if self.duel.alt_global != "":
                alt_val = self.change_alt_global2(
                    variable_id, mine_or_other, how, effect_kind, change_val
                )
                change_val -= alt_val
                instead_val = self.check_variable_instead(
                    variable_id,
                    mine_or_other,
                    change_val,
                    cost_or_effect,
                    chain_user,
                    effect_kind,
                )
                change_val -= instead_val
            if change_val_flag:
                self.raise_trigger_change_val(
                    monster, change_val, cost_or_effect, effect_kind, user, 0
                )
            change_val_all += change_val
            if mine_or_other == 1:
                if how == 0:
                    variable[str(variable_id)]["1_value"] += change_val
                elif how == 1:
                    variable[str(variable_id)]["1_value"] -= change_val
                elif how == 2:
                    variable[str(variable_id)]["1_value"] = change_val
            elif mine_or_other == 2:
                if how == 0:
                    variable[str(variable_id)]["2_value"] += change_val
                elif how == 1:
                    variable[str(variable_id)]["2_value"] -= change_val
                elif how == 2:
                    variable[str(variable_id)]["2_value"] = change_val
            else:
                if how == 0:
                    variable[str(variable_id)]["value"] += change_val
                elif how == 1:
                    variable[str(variable_id)]["value"] -= change_val
                elif how == 2:
                    variable[str(variable_id)]["value"] = change_val
        self.duel.global_variable = json.dumps(variable)
        self.acc_global = []
        return change_val_all

    def raise_trigger_not_effected(
            self, monster, change_val, cost_or_effect, effect_kind, chain_user, org,variable_name = ""
    ):
        field = self.field
        change_val = int(float(change_val))
        duel = self.duel    
        virtual_chain = duel.virtual_chain
        owner = monster["det"]["owner"]
        if cost_or_effect == "effect":
            cost_or_effect = 2
        elif cost_or_effect == "cost":
            cost_or_effect = 1
        else:
            cost_or_effect = 0
        timing = TriggerTimingNotEffected.objects.filter(
            (Q(change_val__gte=change_val) & Q(change_val_operator=">="))
            | (Q(change_val__lte=change_val) & Q(change_val_operator="<="))
            | (Q(change_val=change_val) & Q(change_val_operator="="))
            | (~Q(change_val=change_val) & Q(change_val_operator="!="))
        )
        if duel.is_ai is False:
            timing = timing.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing = timing.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        timing3 = TriggerTimingNotEffected.objects.filter(
            (Q(change_val__gte=change_val) & Q(change_val_operator=">="))
            | (Q(change_val__lte=change_val) & Q(change_val_operator="<="))
            | (Q(change_val=change_val) & Q(change_val_operator="="))
            | (~Q(change_val=change_val) & Q(change_val_operator="!="))
        )
        if duel.is_ai is False:
            timing3 = timing3.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing3 = timing3.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        timing = timing.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
        timing3 = timing3.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
        org_monster_id = monster["det"]["id"]
        monster_id = self.get_monster_id_easy(monster["det"])
        mine_or_other = monster["mine_or_other"]
        timing = timing.filter(
            Q(monster_specify_flag=False) | (Q(monster__id=org_monster_id) & Q(org=True)) | (Q(monster__id=monster_id) & Q(org=False))
        )
        timing = timing.filter(org=org)
        timing = timing.filter(relation=False)
        timing3 = timing3.filter(org=org)
        timing3 = timing3.filter(relation=True)
        timing = timing.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timing3 = timing3.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timings = timing.all()
        timings3 = timing3.all()
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        if effect_kind:
            from_kinds = effect_kind
        else:
            from_kinds = ""
        for timing in timings:
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if timing.chain_user == 2:
                if user == 1:
                    user = 2
                else:
                    user = 1

            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            t_monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            t_monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            t_monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            t_monster.id,
                            timing.exist_hand.id,
                            user,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    if timing.relation is True:
                        if (
                                "rel" in monster["det"]
                                and timing.relation_kind in monster["det"]["rel"]
                        ):
                            for rel_card in monster["det"]["rel"][timing.relation_kind]:
                                if int(rel_card["to"]) == int(timing.relation_to) and (
                                        rel_card["name"] == timing.relation_name
                                        or timing.relation_name == ""
                                ):
                                    if not timing.monster.all().filter(
                                            id=rel_card["monster"]["det"]["id"]
                                    ):
                                        continue
                                    r_monster = rel_card["monster"]
                                    if timing.trigger.strategy != "":
                                        if timing.trigger.strategy in r_monster["variables"]:
                                            tmp_variable = r_monster["variables"][timing.trigger.strategy]
                                            if not tmp_variable["value"].isnumeric():
                                                tmp_variable["value"] = 0
                                        else:
                                            tmp_variable = {}
                                            tmp_variable["value"] = 0
                                        value = self.check_change_val(
                                            monster, user, r_monster["place"], r_monster["deck_id"], 0, 0, timing.trigger.strategy, mine_or_other,
                                            int(tmp_variable["value"])
                                        )
                                    else:
                                        value = 0
                                    tmp = num2
                                    tmp["monster"] = r_monster["det"]
                                    tmp["trigger"] = timing.trigger.id
                                    tmp["priority"] = timing.trigger.priority
                                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                                    tmp["mine_or_other"] = r_monster["mine_or_other"]
                                    tmp["user"] = user
                                    tmp["place"] = r_monster["place"]
                                    tmp["deck_id"] = r_monster["deck_id"]
                                    tmp["x"] = r_monster["x"]
                                    tmp["y"] = r_monster["y"]
                                    tmp["from_x"] = None
                                    tmp["from_y"] = None
                                    tmp["place_from"] = None
                                    tmp["deck_id_from"] = None
                                    tmp["change_val"] = change_val
                                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                    trigger_waiting.append(tmp)
                    else:
                        tmp = num2
                        if timing.trigger.strategy != "":
                            if timing.trigger.strategy in monster["variables"]:
                                tmp_variable = monster["variables"][timing.trigger.strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, monster["place"], monster["deck_id"], 0, 0, timing.trigger.strategy,
                                mine_or_other,
                                int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        tmp["who"] = timing.which_monster_effect
                        tmp["monster"] = monster["det"]
                        tmp["trigger"] = timing.trigger.id
                        tmp["priority"] = timing.trigger.priority
                        tmp["storategy_priority"] = timing.trigger.storategy_priority
                        tmp["mine_or_other"] = monster["mine_or_other"]
                        tmp["user"] = user
                        tmp["place"] = monster["place"]
                        tmp["deck_id"] = monster["deck_id"]
                        tmp["x"] = monster["x"]
                        tmp["y"] = monster["y"]
                        tmp["change_val"] = change_val
                        tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                        trigger_waiting.append(tmp)
            else:
                timing_kinds = timing.kinds
                if not self.check_effect_kind(timing_kinds, from_kinds):
                    continue
                if timing.trigger.strategy != "":
                    if timing.trigger.strategy in monster["variables"]:
                        tmp_variable = monster["variables"][timing.trigger.strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        monster, user, monster["place"], monster["deck_id"], 0, 0, timing.trigger.strategy,
                        mine_or_other,
                        int(tmp_variable["value"])
                    )
                else:
                    value = 0
                tmp = {}
                tmp["who"] = timing.which_monster_effect
                tmp["monster"] = monster["det"]
                tmp["trigger"] = timing.trigger.id
                tmp["priority"] = timing.trigger.priority
                tmp["storategy_priority"] = timing.trigger.storategy_priority
                tmp["mine_or_other"] = mine_or_other
                tmp["user"] = user
                tmp["place"] = monster["place"]
                tmp["from_x"] = None
                tmp["from_y"] = None
                tmp["place_from"] = None
                tmp["deck_id_from"] = None
                tmp["deck_id"] = monster["deck_id"]
                tmp["x"] = monster["x"]
                tmp["y"] = monster["y"]
                tmp["change_val"] = change_val
                tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                trigger_waiting.append(tmp)
        for timing in timings3:
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            monster.id,
                            timing.exist_hand.id,
                            user,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    if timing.trigger.strategy != "":
                        if timing.trigger.strategy in monster["variables"]:
                            tmp_variable = monster["variables"][timing.trigger.strategy]
                            if not tmp_variable["value"].isnumeric():
                                tmp_variable["value"] = 0
                        else:
                            tmp_variable = {}
                            tmp_variable["value"] = 0
                        value = self.check_change_val(
                            monster, user, monster["place"], monster["deck_id"], 0, 0, timing.trigger.strategy,
                            mine_or_other,
                            int(tmp_variable["value"])
                        )
                    else:
                        value = 0
                    tmp = num2
                    tmp["monster"] = monster["det"]
                    tmp["trigger"] = timing.trigger.id
                    tmp["priority"] = timing.trigger.priority
                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                    tmp["mine_or_other"] = monster["mine_or_other"]
                    tmp["user"] = user
                    tmp["place"] = monster["place"]
                    tmp["deck_id"] = monster["deck_id"]
                    tmp["x"] = monster["x"]
                    tmp["y"] = monster["y"]
                    tmp["change_val"] = change_val
                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                    trigger_waiting.append(tmp)
            else:
                timing_kinds = timing.kinds
                if not self.check_effect_kind(timing_kinds, from_kinds):
                    continue
                if (
                        "rel" in monster["det"]
                        and monster["det"]["rel"] is not None
                        and timing.relation_kind in monster["det"]["rel"]
                ):
                    for rel_card in monster["det"]["rel"][timing.relation_kind]:
                        
                        if int(rel_card["to"]) == int(timing.relation_to) and (
                                rel_card["name"] == timing.relation_name
                                or timing.relation_name == ""
                        ):
                            if timing.monster_specify_flag is True:
                                if not timing.monster.all().filter(
                                     id=rel_card["monster"]["det"]["id"]
                                ):
                                    continue
                            if  timing.who == 5:
                                tmp_rel = rel_card["monster"]
                                tmp_rel2 = field[tmp_rel["x"]][tmp_rel["y"]]
                                if "rel" in field[tmp_rel["x"]][tmp_rel["y"]]["det"]:
                                    rel = field[tmp_rel["x"]][tmp_rel["y"]]["det"]["rel"]
                                    if rel is None:
                                        continue
                                    if not timing.relation_kind2 in rel:
                                        continue
                                    for rel_card2 in rel[timing.relation_kind2]:
                                        if int(rel_card2["to"]) == int(timing.relation_to2) and (
                                                rel_card2["name"] == timing.relation_name2
                                                or timing.relation_name == ""
                                        ):
                                            if timing.monster_relate_specify_flag is True:
                                                if not timing.monster_relate.all().filter(
                                                        id=rel_card2["monster"]["det"]["id"]
                                                ):
                                                    continue
                                                if timing.once_per_turn_relate and not self.check_once_per_turn_relate(rel_card2["monster"]["mine_or_other"],rel_card2["monster"]["det"]["place_unique_id"]):
                                                    continue
                                                monster2 = rel_card2["monster"]
                                                if timing.trigger.strategy != "":
                                                    if timing.trigger.strategy in monster["variables"]:
                                                        tmp_variable = monster["variables"][timing.trigger.strategy]
                                                        if not tmp_variable["value"].isnumeric():
                                                            tmp_variable["value"] = 0
                                                    else:
                                                        tmp_variable = {}
                                                        tmp_variable["value"] = 0
                                                    value = self.check_change_val(
                                                        monster, user, monster["place"], monster["deck_id"], 0, 0,
                                                        timing.trigger.strategy,
                                                        mine_or_other,
                                                        int(tmp_variable["value"])
                                                    )
                                                else:
                                                    value = 0
                                                tmp = {}
                                                tmp["who"] = timing.which_monster_effect
                                                tmp["monster"] = monster["det"]
                                                tmp["monster_relate"] = monster2["det"]
                                                tmp["place_unique_id"] = monster["det"]["place_unique_id"]
                                                tmp["place_unique_id_relate"] = monster2["det"]["place_unique_id"]
                                                tmp["mine_or_other_relate"] = monster2["mine_or_other"]
                                                tmp["place_relate"] = monster2["place"]
                                                tmp["deck_id_relate"] = monster2["deck_id"]
                                                tmp["x_relate"] = monster2["x"]
                                                tmp["y_relate"] = monster2["y"]
                                                tmp["trigger"] = timing.trigger.id
                                                tmp["priority"] = timing.trigger.priority
                                                tmp["storategy_priority"] = timing.trigger.storategy_priority
                                                tmp["mine_or_other"] = monster["mine_or_other"]
                                                tmp["user"] = monster2["mine_or_other"]
                                                tmp["place"] = monster["place"]
                                                tmp["deck_id"] = monster["deck_id"]
                                                tmp["x"] = monster["x"]
                                                tmp["y"] = monster["y"]
                                                tmp["from_x"] = None
                                                tmp["from_y"] = None
                                                tmp["place_from"] = None
                                                tmp["deck_id_from"] = None
                                                tmp["change_val"] = change_val
                                                tmp[
                                                    "strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                                trigger_waiting.append(tmp)
                            else:
                                monster2 = rel_card["monster"]
                                if timing.trigger.strategy != "":
                                    if timing.trigger.strategy in monster["variables"]:
                                        tmp_variable = monster["variables"][timing.trigger.strategy]
                                        if not tmp_variable["value"].isnumeric():
                                            tmp_variable["value"] = 0
                                    else:
                                        tmp_variable = {}
                                        tmp_variable["value"] = 0
                                    value = self.check_change_val(
                                        monster, user, monster["place"], monster["deck_id"], 0, 0,
                                        timing.trigger.strategy,
                                        mine_or_other,
                                        int(tmp_variable["value"])
                                    )
                                else:
                                    value = 0
                                tmp = {}
                                tmp["who"] = timing.which_monster_effect
                                tmp["monster"] = monster["det"]
                                tmp["monster_relate"] = monster2["det"]
                                tmp["trigger"] = timing.trigger.id
                                tmp["priority"] = timing.trigger.priority
                                tmp["storategy_priority"] = timing.trigger.storategy_priority
                                tmp["mine_or_other"] = monster2["mine_or_other"]
                                tmp["user"] = user
                                tmp["place"] = monster2["place"]
                                tmp["deck_id"] = monster2["deck_id"]
                                tmp["x"] = monster2["x"]
                                tmp["y"] = monster2["y"]
                                tmp["from_x"] = None
                                tmp["from_y"] = None
                                tmp["place_from"] = None
                                tmp["deck_id_from"] = None
                                tmp["change_val"] = change_val
                                tmp[
                                    "strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                trigger_waiting.append(tmp)
        self.duel.trigger_waiting = json.dumps(trigger_waiting)
    def raise_trigger_monster_change_val(
            self, monster, change_val, cost_or_effect, effect_kind, chain_user, org,variable_name
    ):
        field = self.field
        change_val = int(float(change_val))
        duel = self.duel    
        virtual_chain = duel.virtual_chain
        owner = monster["det"]["owner"]
        if cost_or_effect == "effect":
            cost_or_effect = 2
        elif cost_or_effect == "cost":
            cost_or_effect = 1
        else:
            cost_or_effect = 0
        timing = TriggerTimingMonsterChangeVal.objects.filter(
            (Q(change_val__gte=change_val) & Q(change_val_operator=">="))
            | (Q(change_val__lte=change_val) & Q(change_val_operator="<="))
            | (Q(change_val=change_val) & Q(change_val_operator="="))
            | (~Q(change_val=change_val) & Q(change_val_operator="!="))
        )
        if duel.is_ai is False:
            timing = timing.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing = timing.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        timing3 = TriggerTimingMonsterChangeVal.objects.filter(
            (Q(change_val__gte=change_val) & Q(change_val_operator=">="))
            | (Q(change_val__lte=change_val) & Q(change_val_operator="<="))
            | (Q(change_val=change_val) & Q(change_val_operator="="))
            | (~Q(change_val=change_val) & Q(change_val_operator="!="))
        )
        if duel.is_ai is False:
            timing3 = timing3.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing3 = timing3.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        timing = timing.filter(
            variable_name = variable_name
        )
        timing3 = timing3.filter(
            variable_name = variable_name
        )
        timing = timing.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
        timing3 = timing3.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
        org_monster_id = monster["det"]["id"]
        monster_id = self.get_monster_id_easy(monster["det"])
        mine_or_other = monster["mine_or_other"]
        timing = timing.filter(
            Q(monster_specify_flag=False) | (Q(monster__id=org_monster_id) & Q(org=True)) | (Q(monster__id=monster_id) & Q(org=False))
        )
        timing = timing.filter(org=org)
        timing = timing.filter(relation=False)
        timing3 = timing3.filter(org=org)
        timing3 = timing3.filter(relation=True)
        timing = timing.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timing3 = timing3.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timings = timing.all()
        timings3 = timing3.all()
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        if effect_kind:
            from_kinds = effect_kind
        else:
            from_kinds = ""
        for timing in timings:
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if timing.chain_user == 2:
                if user == 1:
                    user = 2
                else:
                    user = 1

            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            t_monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            t_monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            t_monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            t_monster.id,
                            timing.exist_hand.id,
                            user,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    if timing.relation is True:
                        if (
                                "rel" in monster["det"]
                                and timing.relation_kind in monster["det"]["rel"]
                        ):
                            for rel_card in monster["det"]["rel"][timing.relation_kind]:
                                if int(rel_card["to"]) == int(timing.relation_to) and (
                                        rel_card["name"] == timing.relation_name
                                        or timing.relation_name == ""
                                ):
                                    if not timing.monster.all().filter(
                                            id=rel_card["monster"]["det"]["id"]
                                    ):
                                        continue
                                    r_monster = rel_card["monster"]
                                    if timing.trigger.strategy != "":
                                        if timing.trigger.strategy in r_monster["variables"]:
                                            tmp_variable = r_monster["variables"][timing.trigger.strategy]
                                            if not tmp_variable["value"].isnumeric():
                                                tmp_variable["value"] = 0
                                        else:
                                            tmp_variable = {}
                                            tmp_variable["value"] = 0
                                        value = self.check_change_val(
                                            monster, user, r_monster["place"], r_monster["deck_id"], 0, 0, timing.trigger.strategy, mine_or_other,
                                            int(tmp_variable["value"])
                                        )
                                    else:
                                        value = 0
                                    tmp = num2
                                    tmp["monster"] = r_monster["det"]
                                    tmp["trigger"] = timing.trigger.id
                                    tmp["priority"] = timing.trigger.priority
                                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                                    tmp["mine_or_other"] = r_monster["mine_or_other"]
                                    tmp["user"] = user
                                    tmp["place"] = r_monster["place"]
                                    tmp["deck_id"] = r_monster["deck_id"]
                                    tmp["x"] = r_monster["x"]
                                    tmp["y"] = r_monster["y"]
                                    tmp["from_x"] = None
                                    tmp["from_y"] = None
                                    tmp["place_from"] = None
                                    tmp["deck_id_from"] = None
                                    tmp["change_val"] = change_val
                                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                    trigger_waiting.append(tmp)
                    else:
                        tmp = num2
                        if timing.trigger.strategy != "":
                            if timing.trigger.strategy in monster["variables"]:
                                tmp_variable = monster["variables"][timing.trigger.strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, monster["place"], monster["deck_id"], 0, 0, timing.trigger.strategy,
                                mine_or_other,
                                int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        tmp["who"] = timing.which_monster_effect
                        tmp["monster"] = monster["det"]
                        tmp["trigger"] = timing.trigger.id
                        tmp["priority"] = timing.trigger.priority
                        tmp["storategy_priority"] = timing.trigger.storategy_priority
                        tmp["mine_or_other"] = monster["mine_or_other"]
                        tmp["user"] = user
                        tmp["place"] = monster["place"]
                        tmp["deck_id"] = monster["deck_id"]
                        tmp["x"] = monster["x"]
                        tmp["y"] = monster["y"]
                        tmp["change_val"] = change_val
                        tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                        trigger_waiting.append(tmp)
            else:
                timing_kinds = timing.kinds
                if not self.check_effect_kind(timing_kinds, from_kinds):
                    continue
                if timing.trigger.strategy != "":
                    if timing.trigger.strategy in monster["variables"]:
                        tmp_variable = monster["variables"][timing.trigger.strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        monster, user, monster["place"], monster["deck_id"], 0, 0, timing.trigger.strategy,
                        mine_or_other,
                        int(tmp_variable["value"])
                    )
                else:
                    value = 0
                tmp = {}
                tmp["who"] = timing.which_monster_effect
                tmp["monster"] = monster["det"]
                tmp["trigger"] = timing.trigger.id
                tmp["priority"] = timing.trigger.priority
                tmp["storategy_priority"] = timing.trigger.storategy_priority
                tmp["mine_or_other"] = mine_or_other
                tmp["user"] = user
                tmp["place"] = monster["place"]
                tmp["from_x"] = None
                tmp["from_y"] = None
                tmp["place_from"] = None
                tmp["deck_id_from"] = None
                tmp["deck_id"] = monster["deck_id"]
                tmp["x"] = monster["x"]
                tmp["y"] = monster["y"]
                tmp["change_val"] = change_val
                tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                trigger_waiting.append(tmp)
        for timing in timings3:
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            monster.id,
                            timing.exist_hand.id,
                            user,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    if timing.trigger.strategy != "":
                        if timing.trigger.strategy in monster["variables"]:
                            tmp_variable = monster["variables"][timing.trigger.strategy]
                            if not tmp_variable["value"].isnumeric():
                                tmp_variable["value"] = 0
                        else:
                            tmp_variable = {}
                            tmp_variable["value"] = 0
                        value = self.check_change_val(
                            monster, user, monster["place"], monster["deck_id"], 0, 0, timing.trigger.strategy,
                            mine_or_other,
                            int(tmp_variable["value"])
                        )
                    else:
                        value = 0
                    tmp = num2
                    tmp["monster"] = monster["det"]
                    tmp["trigger"] = timing.trigger.id
                    tmp["priority"] = timing.trigger.priority
                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                    tmp["mine_or_other"] = monster["mine_or_other"]
                    tmp["user"] = user
                    tmp["place"] = monster["place"]
                    tmp["deck_id"] = monster["deck_id"]
                    tmp["x"] = monster["x"]
                    tmp["y"] = monster["y"]
                    tmp["change_val"] = change_val
                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                    trigger_waiting.append(tmp)
            else:
                timing_kinds = timing.kinds
                if not self.check_effect_kind(timing_kinds, from_kinds):
                    continue
                if (
                        "rel" in monster["det"]
                        and monster["det"]["rel"] is not None
                        and timing.relation_kind in monster["det"]["rel"]
                ):
                    for rel_card in monster["det"]["rel"][timing.relation_kind]:
                        
                        if int(rel_card["to"]) == int(timing.relation_to) and (
                                rel_card["name"] == timing.relation_name
                                or timing.relation_name == ""
                        ):
                            if timing.monster_specify_flag is True:
                                if not timing.monster.all().filter(
                                     id=rel_card["monster"]["det"]["id"]
                                ):
                                    continue
                            if  timing.who == 5:
                                tmp_rel = rel_card["monster"]
                                tmp_rel2 = field[tmp_rel["x"]][tmp_rel["y"]]
                                if "rel" in field[tmp_rel["x"]][tmp_rel["y"]]["det"]:
                                    rel = field[tmp_rel["x"]][tmp_rel["y"]]["det"]["rel"]
                                    if rel is None:
                                        continue
                                    if not timing.relation_kind2 in rel:
                                        continue
                                    for rel_card2 in rel[timing.relation_kind2]:
                                        if int(rel_card2["to"]) == int(timing.relation_to2) and (
                                                rel_card2["name"] == timing.relation_name2
                                                or timing.relation_name == ""
                                        ):
                                            if timing.monster_relate_specify_flag is True:
                                                if not timing.monster_relate.all().filter(
                                                        id=rel_card2["monster"]["det"]["id"]
                                                ):
                                                    continue
                                                if timing.once_per_turn_relate and not self.check_once_per_turn_relate(rel_card2["monster"]["mine_or_other"],rel_card2["monster"]["det"]["place_unique_id"]):
                                                    continue
                                                monster2 = rel_card2["monster"]
                                                if timing.trigger.strategy != "":
                                                    if timing.trigger.strategy in monster["variables"]:
                                                        tmp_variable = monster["variables"][timing.trigger.strategy]
                                                        if not tmp_variable["value"].isnumeric():
                                                            tmp_variable["value"] = 0
                                                    else:
                                                        tmp_variable = {}
                                                        tmp_variable["value"] = 0
                                                    value = self.check_change_val(
                                                        monster, user, monster["place"], monster["deck_id"], 0, 0,
                                                        timing.trigger.strategy,
                                                        mine_or_other,
                                                        int(tmp_variable["value"])
                                                    )
                                                else:
                                                    value = 0
                                                tmp = {}
                                                tmp["who"] = timing.which_monster_effect
                                                tmp["monster"] = monster["det"]
                                                tmp["monster_relate"] = monster2["det"]
                                                tmp["place_unique_id"] = monster["det"]["place_unique_id"]
                                                tmp["place_unique_id_relate"] = monster2["det"]["place_unique_id"]
                                                tmp["mine_or_other_relate"] = monster2["mine_or_other"]
                                                tmp["place_relate"] = monster2["place"]
                                                tmp["deck_id_relate"] = monster2["deck_id"]
                                                tmp["x_relate"] = monster2["x"]
                                                tmp["y_relate"] = monster2["y"]
                                                tmp["trigger"] = timing.trigger.id
                                                tmp["priority"] = timing.trigger.priority
                                                tmp["storategy_priority"] = timing.trigger.storategy_priority
                                                tmp["mine_or_other"] = monster["mine_or_other"]
                                                tmp["user"] = monster2["mine_or_other"]
                                                tmp["place"] = monster["place"]
                                                tmp["deck_id"] = monster["deck_id"]
                                                tmp["x"] = monster["x"]
                                                tmp["y"] = monster["y"]
                                                tmp["from_x"] = None
                                                tmp["from_y"] = None
                                                tmp["place_from"] = None
                                                tmp["deck_id_from"] = None
                                                tmp["change_val"] = change_val
                                                tmp[
                                                    "strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                                trigger_waiting.append(tmp)
                            else:
                                monster2 = rel_card["monster"]
                                if timing.trigger.strategy != "":
                                    if timing.trigger.strategy in monster["variables"]:
                                        tmp_variable = monster["variables"][timing.trigger.strategy]
                                        if not tmp_variable["value"].isnumeric():
                                            tmp_variable["value"] = 0
                                    else:
                                        tmp_variable = {}
                                        tmp_variable["value"] = 0
                                    value = self.check_change_val(
                                        monster, user, monster["place"], monster["deck_id"], 0, 0,
                                        timing.trigger.strategy,
                                        mine_or_other,
                                        int(tmp_variable["value"])
                                    )
                                else:
                                    value = 0
                                tmp = {}
                                tmp["who"] = timing.which_monster_effect
                                tmp["monster"] = monster["det"]
                                tmp["monster_relate"] = monster2["det"]
                                tmp["trigger"] = timing.trigger.id
                                tmp["priority"] = timing.trigger.priority
                                tmp["storategy_priority"] = timing.trigger.storategy_priority
                                tmp["mine_or_other"] = monster2["mine_or_other"]
                                tmp["user"] = user
                                tmp["place"] = monster2["place"]
                                tmp["deck_id"] = monster2["deck_id"]
                                tmp["x"] = monster2["x"]
                                tmp["y"] = monster2["y"]
                                tmp["from_x"] = None
                                tmp["from_y"] = None
                                tmp["place_from"] = None
                                tmp["deck_id_from"] = None
                                tmp["change_val"] = change_val
                                tmp[
                                    "strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                trigger_waiting.append(tmp)
        self.duel.trigger_waiting = json.dumps(trigger_waiting)
    def raise_trigger_change_val(
        self, monster, change_val, cost_or_effect, effect_kind, chain_user, org
    ):
        duel = self.duel
        virtual_chain = duel.virtual_chain
        owner = monster["det"]["owner"]
        if cost_or_effect == "effect":
            cost_or_effect = 2
        elif cost_or_effect == "cost":
            cost_or_effect = 1
        else:
            cost_or_effect = 0
        timing = TriggerTimingChangeVal.objects.filter(
            (Q(change_val__gte=change_val) & Q(change_val_operator=">="))
            | (Q(change_val__lte=change_val) & Q(change_val_operator="<="))
            | (Q(change_val=change_val) & Q(change_val_operator="="))
            | (~Q(change_val=change_val) & Q(change_val_operator="!="))
        )
        timing3 = TriggerTimingChangeVal.objects.filter(
            (Q(change_val__gte=change_val) & Q(change_val_operator="<="))
            | (Q(change_val__lte=change_val) & Q(change_val_operator=">="))
            | (Q(change_val=change_val) & Q(change_val_operator="="))
            | (~Q(change_val=change_val) & Q(change_val_operator="!="))
        )
        org_monster_id = monster["det"]["id"]
        monster_id = self.get_monster_id_easy(monster["det"])
        mine_or_other = monster["mine_or_other"]
        timing = timing.filter(
            Q(monster_specify_flag=False) | (Q(monster__id=org_monster_id) & Q(org=True)) | (Q(monster__id=monster_id) & Q(org=False))
        )
        timing = timing.filter(org=org)
        timing = timing.filter(relation=False)
        timing3 = timing3.filter(org=org)
        timing3 = timing3.filter(relation=True)
        timing = timing.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timing3 = timing3.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timing = timing.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
        timing3 = timing3.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
        timings = timing.all()
        timings3 = timing3.all()
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        if effect_kind:
            from_kinds = effect_kind
        else:
            from_kinds = ""
        for timing in timings:
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if timing.chain_user == 2:
                if user == 1:
                    user = 2
                else:
                    user = 1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            t_monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            t_monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            t_monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for t_monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            t_monster.id,
                            timing.exist_hand.id,
                            user,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    if timing.relation is True:
                        if (
                            "rel" in monster["det"]
                            and timing.relation_kind in monster["det"]["rel"]
                        ):
                            for rel_card in monster["det"]["rel"][timing.relation_kind]:
                                if int(rel_card["to"]) == int(timing.relation_to) and (
                                    rel_card["name"] == timing.relation_name
                                    or timing.relation_name == ""
                                ):
                                    if not timing.monster.all().filter(
                                        id=rel_card["monster"]["det"]["id"]
                                    ):
                                        continue
                                    r_monster = rel_card["monster"]
                                    if timing.trigger.strategy != "":
                                        if timing.trigger.strategy in r_monster["variables"]:
                                            tmp_variable = r_monster["variables"][timing.trigger.strategy]
                                            if not tmp_variable["value"].isnumeric():
                                                tmp_variable["value"] = 0
                                        else:
                                            tmp_variable = {}
                                            tmp_variable["value"] = 0
                                        value = self.check_change_val(
                                            r_monster, user, r_monster["place"], r_monster["deck_id"], 0, 0,
                                            timing.trigger.strategy,
                                            mine_or_other,
                                            int(tmp_variable["value"])
                                        )
                                    else:
                                        value = 0
                                    tmp = num2
                                    tmp["monster"] = r_monster["det"]
                                    tmp["trigger"] = timing.trigger.id
                                    tmp["priority"] = timing.trigger.priority
                                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                                    tmp["mine_or_other"] = r_monster["mine_or_other"]
                                    tmp["user"] = user
                                    tmp["place"] = r_monster["place"]
                                    tmp["deck_id"] = r_monster["deck_id"]
                                    tmp["x"] = r_monster["x"]
                                    tmp["y"] = r_monster["y"]
                                    tmp["from_x"] = None
                                    tmp["from_y"] = None
                                    tmp["place_from"] = None
                                    tmp["deck_id_from"] = None
                                    tmp["change_val"] = change_val
                                    tmp[
                                        "strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                    trigger_waiting.append(tmp)
                    else:
                        if timing.trigger.strategy != "":
                            if timing.trigger.strategy in monster["variables"]:
                                tmp_variable = monster["variables"][timing.trigger.strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                monster, user, monster["place"], monster["deck_id"], 0, 0,
                                timing.trigger.strategy,
                                mine_or_other,
                                int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        tmp = num2
                        tmp["who"] = timing.which_monster_effect
                        tmp["monster"] = monster["det"]
                        tmp["trigger"] = timing.trigger.id
                        tmp["priority"] = timing.trigger.priority
                        tmp["storategy_priority"] = timing.trigger.storategy_priority
                        tmp["mine_or_other"] = monster["mine_or_other"]
                        tmp["user"] = user
                        tmp["place"] = monster["place"]
                        tmp["deck_id"] = monster["deck_id"]
                        tmp["x"] = monster["x"]
                        tmp["y"] = monster["y"]
                        tmp["change_val"] = change_val
                        tmp[
                            "strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                        trigger_waiting.append(tmp)
            else:
                timing_kinds = timing.kinds
                if not self.check_effect_kind(timing_kinds, from_kinds):
                    continue
                if timing.trigger.strategy != "":
                    if timing.trigger.strategy in monster["variables"]:
                        tmp_variable = monster["variables"][timing.trigger.strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        monster, user, monster["place"], monster["deck_id"], 0, 0,
                        timing.trigger.strategy,
                        mine_or_other,
                        int(tmp_variable["value"])
                    )
                else:
                    value = 0
                tmp = {}
                tmp["who"] = timing.which_monster_effect
                tmp["monster"] = monster["det"]
                tmp["trigger"] = timing.trigger.id
                tmp["priority"] = timing.trigger.priority
                tmp["storategy_priority"] = timing.trigger.storategy_priority
                tmp["mine_or_other"] = mine_or_other
                tmp["user"] = user
                tmp["place"] = monster["place"]
                tmp["from_x"] = None
                tmp["from_y"] = None
                tmp["place_from"] = None
                tmp["deck_id_from"] = None
                tmp["deck_id"] = monster["deck_id"]
                tmp["x"] = monster["x"]
                tmp["y"] = monster["y"]
                tmp["change_val"] = change_val
                tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                trigger_waiting.append(tmp)
        for timing in timings3:
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            monster.id,
                            timing.exist_hand.id,
                            user,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    tmp = num2
                    if timing.trigger.strategy != "":
                        if timing.trigger.strategy in monster["variables"]:
                            tmp_variable = monster["variables"][timing.trigger.strategy]
                            if not tmp_variable["value"].isnumeric():
                                tmp_variable["value"] = 0
                        else:
                            tmp_variable = {}
                            tmp_variable["value"] = 0
                        value = self.check_change_val(
                            monster, user, monster["place"], monster["deck_id"], 0, 0,
                            timing.trigger.strategy,
                            mine_or_other,
                            int(tmp_variable["value"])
                        )
                    else:
                        value = 0
                    tmp["monster"] = monster["det"]
                    tmp["trigger"] = timing.trigger.id
                    tmp["priority"] = timing.trigger.priority
                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                    tmp["mine_or_other"] = monster["mine_or_other"]
                    tmp["user"] = user
                    tmp["place"] = monster["place"]
                    tmp["deck_id"] = monster["deck_id"]
                    tmp["x"] = monster["x"]
                    tmp["y"] = monster["y"]
                    tmp["change_val"] = change_val
                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                    trigger_waiting.append(tmp)
            else:
                timing_kinds = timing.kinds
                if not self.check_effect_kind(timing_kinds, from_kinds):
                    continue
                if (
                    "rel" in monster["det"]
                    and timing.relation_kind in monster["det"]["rel"]
                ):
                    for rel_card in monster["det"]["rel"][timing.relation_kind]:
                        if int(rel_card["to"]) == int(timing.relation_to) and (
                            rel_card["name"] == timing.relation_name
                            or timing.relation_name == ""
                        ):
                            if not timing.monster.all().filter(
                                id=rel_card["monster"]["det"]["id"]
                            ):
                                continue
                            monster2 = rel_card["monster"]
                            if timing.trigger.strategy != "":
                                if timing.trigger.strategy in monster2["variables"]:
                                    tmp_variable = monster2["variables"][timing.trigger.strategy]
                                    if not tmp_variable["value"].isnumeric():
                                        tmp_variable["value"] = 0
                                else:
                                    tmp_variable = {}
                                    tmp_variable["value"] = 0
                                value = self.check_change_val(
                                    monster2, user, monster2["place"], monster2["deck_id"], 0, 0,
                                    timing.trigger.strategy,
                                    mine_or_other,
                                    int(tmp_variable["value"])
                                )
                            else:
                                value = 0
                            tmp = {}
                            tmp["who"] = timing.which_monster_effect
                            tmp["monster"] = monster2["det"]
                            tmp["trigger"] = timing.trigger.id
                            tmp["priority"] = timing.trigger.priority
                            tmp["storategy_priority"] = timing.trigger.storategy_priority
                            tmp["mine_or_other"] = monster2["mine_or_other"]
                            tmp["user"] = user
                            tmp["place"] = monster2["place"]
                            tmp["deck_id"] = monster2["deck_id"]
                            tmp["x"] = monster2["x"]
                            tmp["y"] = monster2["y"]
                            tmp["from_x"] = None
                            tmp["from_y"] = None
                            tmp["place_from"] = None
                            tmp["deck_id_from"] = None
                            tmp["change_val"] = change_val
                            tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                            trigger_waiting.append(tmp)
        duel.trigger_waiting = json.dumps(trigger_waiting)

    def raise_set_relation(
        self,
        det,
        org,
        relation_kind,
        relation_name,
        key,
        place,
        to_mine_or_other,
        to_deck_id,
        to_x,
        to_y,
        place_to,
        deck_id,
        x,
        y,
        mine_or_other,
        cost_or_effect,
        chain_user,
    ):
        duel = self.duel
        virtual_chain = duel.virtual_chain
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        monster_id = self.get_monster_id(
            org, place, org["owner"], to_deck_id, to_x, to_y, to_mine_or_other
        )
        monster = Monster.objects.get(id=monster_id)
        if org["rel"][relation_kind][key]["to"] == 1:
            det_to = 0
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=True)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=False)
            )
            timings = timings.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
            if duel.is_ai is False:
                timings = timings.filter(
                    Q(enemy = 0) | Q(enemy = 1)
                )
            else:
                timings = timings.filter(
                    Q(enemy = 1) | Q(enemy = 2)
                )
        else:
            det_to = 1
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=False)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=False)
            )
            timings = timings.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
            if duel.is_ai is False:
                timings = timings.filter(
                    Q(enemy = 0) | Q(enemy = 1)
                )
            else:
                timings = timings.filter(
                    Q(enemy = 1) | Q(enemy = 2)
                )
        for timing in timings:
            if cost_or_effect == 1:
                if timing.cost_or_effect == 2:
                    continue
            elif cost_or_effect == 2:
                if timing.cost_or_effect == 1:
                    continue
            if timing.who == 0:
                user = org["owner"]
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = to_mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            tmp = {}
            if timing.trigger.strategy != "":
                if timing.trigger.strategy in org["variables"]:
                    tmp_variable = org["variables"][timing.trigger.strategy]
                    if not tmp_variable["value"].isnumeric():
                        tmp_variable["value"] = 0
                else:
                    tmp_variable = {}
                    tmp_variable["value"] = 0
                value = self.check_change_val(
                    org, user, org["place"], org["deck_id"], 0, 0,
                    timing.trigger.strategy,
                    mine_or_other,
                    int(tmp_variable["value"])
                )
            else:
                value = 0
            tmp["who"] = timing.which_monster_effect
            tmp["monster"] = org
            tmp["move_from"] = None
            tmp["trigger"] = timing.trigger.id
            tmp["priority"] = timing.trigger.priority
            tmp["storategy_priority"] = timing.trigger.storategy_priority
            tmp["mine_or_other"] = to_mine_or_other
            tmp["user"] = user
            tmp["place"] = place_to
            tmp["deck_id"] = to_deck_id
            tmp["x"] = to_x
            tmp["y"] = to_y
            tmp["from_x"] = None
            tmp["from_y"] = None
            tmp["place_from"] = None
            tmp["deck_id_from"] = None
            tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
            trigger_waiting.append(tmp)
        monster_id = self.get_monster_id(
            det, place, det["owner"], deck_id, x, y, mine_or_other
        )
        monster = Monster.objects.get(id=monster_id)
        if det_to == 1:
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=True)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=False)
            )
        else:
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=False)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=False)
            )
        for timing in timings:
            if cost_or_effect == 1:
                if timing.cost_or_effect == 2:
                    continue
            elif cost_or_effect == 2:
                if timing.cost_or_effect == 1:
                    continue
            if timing.who == 0:
                user = det["owner"]
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.trigger.strategy != "":
                if timing.trigger.strategy in det["variables"]:
                    tmp_variable = det["variables"][timing.trigger.strategy]
                    if not tmp_variable["value"].isnumeric():
                        tmp_variable["value"] = 0
                else:
                    tmp_variable = {}
                    tmp_variable["value"] = 0
                value = self.check_change_val(
                    det, user, det["place"], det["deck_id"], 0, 0,
                    timing.trigger.strategy,
                    mine_or_other,
                    int(tmp_variable["value"])
                )
            else:
                value = 0
            tmp = {}
            tmp["who"] = timing.which_monster_effect
            tmp["monster"] = det
            tmp["move_from"] = None
            tmp["trigger"] = timing.trigger.id
            tmp["priority"] = timing.trigger.priority
            tmp["storategy_priority"] = timing.trigger.storategy_priority
            tmp["mine_or_other"] = mine_or_other
            tmp["user"] = user
            tmp["place"] = place
            tmp["deck_id"] = deck_id
            tmp["x"] = x
            tmp["y"] = y
            tmp["from_x"] = None
            tmp["from_y"] = None
            tmp["place_from"] = None
            tmp["deck_id_from"] = None
            tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
            trigger_waiting.append(tmp)
        duel.trigger_waiting = json.dumps(trigger_waiting)

    def raise_null_relation(
        self,
        det,
        org,
        relation_kind,
        relation_name,
        key,
        place,
        mine_or_other,
        deck_id,
        x,
        y,
        place_to,
        to_deck_id,
        to_x,
        to_y,
        to_mine_or_other,
        cost_or_effect,
        chain_user,
        move_to = None,
        leave = False
    ):
        if move_to is None:
            move_to = org
        duel = self.duel
        virtual_chain = duel.virtual_chain
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        monster_id = self.get_monster_id(
            det, place, det["owner"], deck_id, x, y, mine_or_other
        )
        monster = Monster.objects.get(id=monster_id)

        if det["rel"][relation_kind][key]["to"] == 1:
            org_to = 0
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=True)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=True)
            )
            timings = timings.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
            if duel.is_ai is False:
                timings = timings.filter(
                    Q(enemy = 0) | Q(enemy = 1)
                )
            else:
                timings = timings.filter(
                    Q(enemy = 1) | Q(enemy = 2)
                )
        else:
            org_to = 1
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=False)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=True)
            )
            timings = timings.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2))  
        )
            if duel.is_ai is False:
                timings = timings.filter(
                    Q(enemy = 0) | Q(enemy = 1)
                )
            else:
                timings = timings.filter(
                    Q(enemy = 1) | Q(enemy = 2)
                )
        if leave is True:
            timings = timings.filter(leave_flag_self = True)
        for timing in timings:
            if timing.who == 0:
                user = det["owner"]
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = mine_or_other
            elif timing.who == 4:
                user = org["owner"]
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            tmp_relate = {}
            tmp_relate["monster"] = move_to
            tmp_relate["det"] = move_to
            tmp_relate["place_unique_id"] = move_to["place_unique_id"]
            tmp_relate["card_unique_id"] = move_to["card_unique_id"]
            tmp_relate["mine_or_other"] = to_mine_or_other
            tmp_relate["user"] = to_mine_or_other
            tmp_relate["place"] = place_to
            tmp_relate["deck_id"] = to_deck_id
            tmp_relate["x"] = to_x
            tmp_relate["y"] = to_y
            if timing.trigger.strategy != "":
                if timing.trigger.strategy in det["variables"]:
                    tmp_variable = det["variables"][timing.trigger.strategy]
                    if not tmp_variable["value"].isnumeric():
                        tmp_variable["value"] = 0
                else:
                    tmp_variable = {}
                    tmp_variable["value"] = 0
                value = self.check_change_val(
                    det, user, det["place"], det["deck_id"], 0, 0,
                    timing.trigger.strategy,
                    mine_or_other,
                    int(tmp_variable["value"])
                )
            else:
                value = 0
            tmp = {}
            tmp["who"] = timing.which_monster_effect
            tmp["null_relate"] = tmp_relate
            tmp["monster"] = det
            tmp["move_from"] = None
            tmp["trigger"] = timing.trigger.id
            tmp["priority"] = timing.trigger.priority
            tmp["storategy_priority"] = timing.trigger.storategy_priority
            tmp["mine_or_other"] = mine_or_other
            tmp["user"] = user
            tmp["place"] = place
            tmp["deck_id"] = deck_id
            tmp["x"] = x
            tmp["y"] = y
            tmp["from_x"] = None
            tmp["from_y"] = None
            tmp["place_from"] = None
            tmp["deck_id_from"] = None
            tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
            trigger_waiting.append(tmp)
        monster_id = self.get_monster_id(
            move_to, place, move_to["owner"], to_deck_id, to_x, to_y, to_mine_or_other
        )
        monster = Monster.objects.get(id=monster_id)
        if org_to == 1:
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=True)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=True)
            )
        else:
            timings = (
                TriggerTimingRelation.objects.filter(monster=monster)
                .filter(relation_to=False)
                .filter(relation_kind=relation_kind)
                .filter(relation_name=relation_name)
                .filter(clear_flag=True)
            )
        if leave is True:
            timings = timings.filter(leave_flag_null_relate = True)
        for timing in timings:
            if cost_or_effect == 1:
                if timing.cost_or_effect == 2:
                    continue
            elif cost_or_effect == 2:
                if timing.cost_or_effect == 1:
                    continue
            if timing.who == 0:
                user = org["owner"]
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = to_mine_or_other
            elif timing.who == 4:
                user = det["owner"]
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.trigger.strategy != "":
                if timing.trigger.strategy in move_to["variables"]:
                    tmp_variable = move_to["variables"][timing.trigger.strategy]
                    if not tmp_variable["value"].isnumeric():
                        tmp_variable["value"] = 0
                else:
                    tmp_variable = {}
                    tmp_variable["value"] = 0
                value = self.check_change_val(
                    move_to, user, move_to["place"], move_to["deck_id"], 0, 0,
                    timing.trigger.strategy,
                    mine_or_other,
                    int(tmp_variable["value"])
                )
            else:
                value = 0
            tmp_relate = {}
            tmp_relate["monster"] = det
            tmp_relate["det"] = det
            tmp_relate["place_unique_id"] = det["place_unique_id"]
            tmp_relate["mine_or_other"] = mine_or_other
            tmp_relate["user"] = mine_or_other
            tmp_relate["place"] = place
            tmp_relate["deck_id"] = deck_id
            tmp_relate["x"] = x
            tmp_relate["y"] = y
            tmp = {}
            tmp["who"] = timing.which_monster_effect
            tmp["null_relate"] = tmp_relate
            tmp["monster"] = move_to
            tmp["place_unique_id"] = move_to["place_unique_id"]
            tmp["move_from"] = None
            tmp["trigger"] = timing.trigger.id
            tmp["priority"] = timing.trigger.priority
            tmp["storategy_priority"] = timing.trigger.storategy_priority
            tmp["mine_or_other"] = to_mine_or_other
            tmp["user"] = user
            tmp["place"] = place_to
            tmp["deck_id"] = to_deck_id
            tmp["x"] = to_x
            tmp["y"] = to_y
            tmp["from_x"] = None
            tmp["from_y"] = None
            tmp["place_from"] = None
            tmp["deck_id_from"] = None
            tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
            trigger_waiting.append(tmp)

        duel.trigger_waiting = json.dumps(trigger_waiting)

    def raise_trigger(
        self,
        move_to,
        move_from,
        org,
        cost_or_effect,
        place_to,
        to_mine_or_other,
        chain_user,
        to_deck_id,
        effect_kind,
        x=None,
        y=None,
    ):
        duel = self.duel
        virtual_chain = duel.virtual_chain
        move_from = copy.deepcopy(move_from)
        if cost_or_effect == "effect":
            cost_or_effect = 2
        elif cost_or_effect == "cost":
            cost_or_effect = 1
        else:
            cost_or_effect = 0
        place_from = move_from["place"]
        owner = move_from["det"]["owner"]
        from_mine_or_other = move_from["det"]["mine_or_other"]
        if place_from == "deck":
            from_place_kind = 1
        elif place_from == "grave":
            from_place_kind = 2
        elif place_from == "hand":
            from_place_kind = 3
        elif place_from == "field":
            from_place_kind = 4
        elif place_from == "under":
            from_place_kind = 5
        else:
            from_place_kind = 0
        timing = TriggerTiming.objects.filter(
            Q(from_place_kind=from_place_kind) | Q(from_place_kind=0)
        )
        if duel.is_ai is False:
            timing = timing.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing = timing.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        timing2 = TriggerTiming.objects.filter(
            Q(from_place_kind=from_place_kind) | Q(from_place_kind=0)
        )
        if duel.is_ai is False:
            timing2 = timing2.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing2 = timing2.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        timing3 = TriggerTiming.objects.filter(
            Q(from_place_kind=from_place_kind) | Q(from_place_kind=0)
        )
        if duel.is_ai is False:
            timing3 = timing3.filter(
                Q(enemy = 0) | Q(enemy = 1)
            )
        else:
            timing3 = timing3.filter(
                Q(enemy = 1) | Q(enemy = 2)
            )
        monster_id = self.get_monster_id(
            move_to, place_to, move_to["owner"], to_deck_id, x, y, to_mine_or_other
        )
        org_monster_id = self.get_monster_id(
            org,
            place_from,
            org["owner"],
            move_from["deck_id"],
            move_from["x"],
            move_from["y"],
            org["owner"],
        )
        timing = timing.filter(
            Q(monster__in=[monster_id]) | Q(monster_specify_flag=False)
        )
        timing = timing.filter(org_flag=False, relation=False)

        timing2 = timing2.filter(org_flag=True, relation=False)
        timing3 = timing3.filter(
            Q(monster__in=[org_monster_id]) | Q(monster_specify_flag=False)
        )
        timing3 = timing3.filter(relation=True)
        timing = self.check_trigger_timing_sql(
            timing, owner, chain_user, from_mine_or_other, to_mine_or_other
        )
        timing2 = self.check_trigger_timing_sql(
            timing2, owner, chain_user, from_mine_or_other, to_mine_or_other
        )
        timing3 = self.check_trigger_timing_sql(
            timing3, owner, chain_user, from_mine_or_other, to_mine_or_other
        )
        timing = timing.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timing2 = timing2.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        timing3 = timing3.filter(Q(cost_or_effect=cost_or_effect) | Q(cost_or_effect=0))
        from_x = 0
        from_y = 0
        from_deck_id = 0
        if place_from == "deck":
            timing = timing.filter(
                ~(Q(exclude_from_deck__isnull=True) & Q(exclude_from_place_kind=3))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_from_deck__isnull=True) & Q(exclude_from_place_kind=3))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_from_deck__isnull=True) & Q(exclude_from_place_kind=3))
            )
            from_x = 0
            from_y = 0
            from_deck_id = move_from["deck_id"]
            timing = timing.filter(Q(from_deck__id=from_deck_id) | Q(from_place_kind=0))
            timing2 = timing2.filter(
                Q(from_deck__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing3 = timing3.filter(
                Q(from_deck__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing = timing.filter(
                ~Q(exclude_from_deck__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
            timing2 = timing2.filter(
                ~Q(exclude_from_deck__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
            timing3 = timing3.filter(
                ~Q(exclude_from_deck__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
        elif place_from == "grave":
            timing = timing.filter(
                ~(Q(exclude_from_grave__isnull=True) & Q(exclude_from_place_kind=3))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_from_grave__isnull=True) & Q(exclude_from_place_kind=3))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_from_grave__isnull=True) & Q(exclude_from_place_kind=3))
            )
            from_x = 0
            from_y = 0
            from_deck_id = move_from["deck_id"]
            from_deck_id = from_deck_id
            timing = timing.filter(
                Q(from_grave__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing2 = timing2.filter(
                Q(from_grave__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing3 = timing3.filter(
                Q(from_grave__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing = timing.filter(
                ~Q(exclude_from_grave__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
            timing2 = timing2.filter(
                ~Q(exclude_from_grave__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
            timing3 = timing3.filter(
                ~Q(exclude_from_grave__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
        elif place_from == "hand":
            timing = timing.filter(
                ~(Q(exclude_from_hand__isnull=True) & Q(exclude_from_place_kind=3))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_from_hand__isnull=True) & Q(exclude_from_place_kind=3))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_from_hand__isnull=True) & Q(exclude_from_place_kind=3))
            )
            from_x = 0
            from_y = 0
            from_deck_id = move_from["deck_id"]
            from_deck_id = from_deck_id
            timing = timing.filter(Q(from_hand__id=from_deck_id) | Q(from_place_kind=0))
            timing2 = timing2.filter(
                Q(from_hand__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing3 = timing3.filter(
                Q(from_hand__id=from_deck_id) | Q(from_place_kind=0)
            )
            timing = timing.filter(
                ~Q(exclude_from_hand__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
            timing2 = timing2.filter(
                ~Q(exclude_from_hand__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
            timing3 = timing3.filter(
                ~Q(exclude_from_hand__id=from_deck_id) | Q(exclude_from_place_kind=0)
            )
        elif place_from == "under":
            timing = timing.filter(
                ~(Q(exclude_from_hand__isnull=True) & Q(exclude_from_place_kind=5))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_from_hand__isnull=True) & Q(exclude_from_place_kind=5))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_from_hand__isnull=True) & Q(exclude_from_place_kind=5))
            )
            from_x = move_from["x"]
            from_y = move_from["y"]
            from_deck_id = 0
        elif place_from == "field":
            timing = timing.filter(
                ~(Q(exclude_from_field__isnull=True) & Q(exclude_from_place_kind=4))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_from_field__isnull=True) & Q(exclude_from_place_kind=4))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_from_field__isnull=True) & Q(exclude_from_place_kind=4))
            )
            from_x = move_from["x"]
            from_y = move_from["y"]
            field = self.field
            from_deck_id = 0
            kinds = field[from_x][from_y]["kind"]
            kinds = kinds.split("_")
            queries = [Q(from_field__id=int(from_field)) for from_field in kinds]
            query = queries.pop()
            query3 =  Q(from_field__isnull=True)
            for item in queries:
                query |= item
            query|= query3
            queries2 = [
                ~Q(exclude_from_field__id=int(from_field)) for from_field in kinds
            ]
            query2 = queries2.pop()
            for item in queries2:
                query2 |= item
            query = query & query2
            timing=timing.filter(query)
            timing2=timing2.filter(query)
            timing3=timing3.filter(query)
        if place_to == "deck":
            to_place_kind = 1
        elif place_to == "grave":
            to_place_kind = 2
        elif place_to == "hand":
            to_place_kind = 3
        elif place_to == "field":
            to_place_kind = 4
        elif place_to == "under":
            to_place_kind = 5
        else:
            to_place_kind = 0
        timing = timing.filter(Q(to_place_kind=to_place_kind) | Q(to_place_kind=0))
        timing.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2)) ) 
        timing2 = timing2.filter(Q(to_place_kind=to_place_kind) | Q(to_place_kind=0))
        timing2.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2)) ) 
        timing3 = timing3.filter(Q(to_place_kind=to_place_kind) | Q(to_place_kind=0))
        timing3.filter(
            (Q(chain__lte=virtual_chain) & Q(chain_kind=0)) | 
            (Q(chain__gte=virtual_chain) & Q(chain_kind=1)) | 
            (Q(chain=virtual_chain) & Q(chain_kind=2)) ) 
        if place_to == "deck":
            timing = timing.filter(
                ~(Q(exclude_to_deck__isnull=True) & Q(exclude_to_place_kind=3))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_to_deck__isnull=True) & Q(exclude_to_place_kind=3))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_to_deck__isnull=True) & Q(exclude_to_place_kind=3))
            )
            to_deck_id = to_deck_id
            timing = timing.filter(Q(to_deck__id=to_deck_id) | Q(to_deck__isnull=True))
            timing2 = timing2.filter(
                Q(to_deck__id=to_deck_id) | Q(to_deck__isnull=True)
            )
            timing3 = timing3.filter(
                Q(to_deck__id=to_deck_id) | Q(to_deck__isnull=True)
            )
            timing = timing.filter(
                ~Q(exclude_to_deck__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
            timing2 = timing2.filter(
                ~Q(exclude_to_deck__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
            timing3 = timing3.filter(
                ~Q(exclude_to_deck__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
        elif place_to == "grave":
            timing = timing.filter(
                ~(Q(exclude_to_grave__isnull=True) & Q(exclude_to_place_kind=3))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_to_grave__isnull=True) & Q(exclude_to_place_kind=3))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_to_grave__isnull=True) & Q(exclude_to_place_kind=3))
            )
            to_deck_id = to_deck_id
            timing = timing.filter(
                Q(to_grave__id=to_deck_id) | Q(to_grave__isnull=True)
            )
            timing2 = timing2.filter(
                Q(to_grave__id=to_deck_id) | Q(to_grave__isnull=True)
            )
            timing3 = timing3.filter(
                Q(to_grave__id=to_deck_id) | Q(to_grave__isnull=True)
            )
            timing = timing.filter(
                ~Q(exclude_to_grave__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
            timing2 = timing2.filter(
                ~Q(exclude_to_grave__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
            timing3 = timing3.filter(
                ~Q(exclude_to_grave__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
        elif place_to == "hand":
            timing = timing.filter(
                ~(Q(exclude_to_hand__isnull=True) & Q(exclude_to_place_kind=3))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_to_hand__isnull=True) & Q(exclude_to_place_kind=3))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_to_hand__isnull=True) & Q(exclude_to_place_kind=3))
            )
            to_deck_id = to_deck_id
            timing = timing.filter(Q(to_hand__id=to_deck_id) | Q(to_hand__isnull=True))
            timing2 = timing2.filter(
                Q(to_hand__id=to_deck_id) | Q(to_hand__isnull=True)
            )
            timing3 = timing3.filter(
                Q(to_hand__id=to_deck_id) | Q(to_hand__isnull=True)
            )
            timing = timing.filter(
                ~Q(exclude_to_hand__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
            timing2 = timing2.filter(
                ~Q(exclude_to_hand__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
            timing3 = timing3.filter(
                ~Q(exclude_to_hand__id=to_deck_id) | Q(exclude_to_place_kind=0)
            )
        elif place_to == "under":
            timing = timing.filter(Q(exclude_to_place_kind=5))
            timing2 = timing2.filter(Q(exclude_to_place_kind=5))
            timing3 = timing3.filter(Q(exclude_to_place_kind=5))
        elif place_to == "field":
            timing = timing.filter(
                ~(Q(exclude_to_field__isnull=True) & Q(exclude_to_place_kind=4))
            )
            timing2 = timing2.filter(
                ~(Q(exclude_to_field__isnull=True) & Q(exclude_to_place_kind=4))
            )
            timing3 = timing3.filter(
                ~(Q(exclude_to_field__isnull=True) & Q(exclude_to_place_kind=4))
            )
            field = self.field
            if self.field_free is False:
                kinds = field[x][y]["kind"]
            else:
                kinds = field[0][y]["kind"]
            kinds = kinds.split("_")
            queries = [Q(to_field__id=int(to_field)) for to_field in kinds]
            query = queries.pop()
            free_query = Q(to_field__isnull=True)
            for item in queries:
                query |= item
            query |= free_query
            queries2 = [~Q(exclude_to_field__id=int(to_field)) for to_field in kinds]
            query2 = queries2.pop()
            for item in queries2:
                query2 &= item
            query = query & query2
            timing = timing.filter(query)
            timing2 = timing2.filter(query)
            timing3 = timing3.filter(query)
        timings = timing.all()
        timings2 = timing2.all()
        timings3 = timing3.all()
        if duel.trigger_waiting == "":
            trigger_waiting = []
        else:
            trigger_waiting = json.loads(duel.trigger_waiting)
        if effect_kind:
            from_kinds = effect_kind
        else:
            from_kinds = ""
        for timing in timings:
            timing_kinds = timing.kinds
            if not self.check_effect_kind(timing_kinds, from_kinds):
                continue
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = from_mine_or_other
            elif timing.who == 4:
                user = to_mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = []
                if timing.exist_place_kind == 4:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistField(
                            monster.id,
                            timing.exist_field.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 1:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistDeck(
                            monster.id,
                            timing.exist_deck.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 2:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistGrave(
                            monster.id,
                            timing.exist_grave.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                elif timing.exist_place_kind == 3:
                    for monster in timing.monster_exist.all():
                        tmp = self.checkMonsterExistHand(
                            monster.id,
                            timing.exist_hand.id,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                        if tmp:
                            num.extend(tmp)
                if not num:
                    continue
                for num2 in num:
                    if timing.win_or_lose == 1:
                        self.win_the_game_user(user)
                        return;
                    elif timing.win_or_lose == 2:
                        if user == 1:
                            other_user = 2
                        else:
                            other_user = 1
                        self.win_the_game_user(other_user)
                        return;
                    if timing.trigger.strategy != "":
                        if timing.trigger.strategy in move_to["variables"]:
                            tmp_variable = move_to["variables"][timing.trigger.strategy]
                            if not tmp_variable["value"].isnumeric():
                                tmp_variable["value"] = 0
                        else:
                            tmp_variable = {}
                            tmp_variable["value"] = 0
                        value = self.check_change_val(
                            move_to, user, move_to["place"], move_to["deck_id"], 0, 0,
                            timing.trigger.strategy,
                            to_mine_or_other,
                            int(tmp_variable["value"])
                        )
                    else:
                        value = 0
                    tmp = num2
                    tmp["who"] = timing.which_monster_effect
                    tmp["monster"] = move_to
                    tmp["move_from"] = move_from
                    tmp["trigger"] = timing.trigger.id
                    tmp["priority"] = timing.trigger.priority
                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                    tmp["mine_or_other"] = user
                    tmp["user"] = user
                    tmp["place"] = place_to
                    tmp["deck_id"] = to_deck_id
                    tmp["x"] = x
                    tmp["y"] = y
                    tmp["from_x"] = from_x
                    tmp["from_y"] = from_y
                    tmp["place_from"] = place_from
                    tmp["deck_id_from"] = from_deck_id
                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                    trigger_waiting.append(tmp)
                    if self.config.order != 0 and duel.already_choosed != 1 and duel.ask2 == 0:
                        duel.ask2 = 4
            else:
                if timing.win_or_lose == 1:
                    self.win_the_game_user(user)
                    return;
                elif timing.win_or_lose == 2:
                    if user == 1:
                        other_user = 2
                    else:
                        other_user = 1
                    self.win_the_game_user(other_user)
                    return;
                if timing.trigger.strategy != "":
                    if timing.trigger.strategy in move_to["variables"]:
                        tmp_variable = move_to["variables"][timing.trigger.strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        move_to, user, move_to["place"], move_to["deck_id"], 0, 0,
                        timing.trigger.strategy,
                        to_mine_or_other,
                        int(tmp_variable["value"])
                    )
                else:
                    value = 0
                tmp = {}
                tmp["who"] = timing.which_monster_effect
                tmp["monster"] = move_to
                tmp["move_from"] = move_from
                tmp["trigger"] = timing.trigger.id
                tmp["priority"] = timing.trigger.priority
                tmp["storategy_priority"] = timing.trigger.storategy_priority
                tmp["mine_or_other"] = user
                tmp["user"] = user
                tmp["place"] = place_to
                tmp["deck_id"] = to_deck_id
                tmp["x"] = x
                tmp["y"] = y
                tmp["from_x"] = from_x
                tmp["from_y"] = from_y
                tmp["place_from"] = place_from
                tmp["deck_id_from"] = from_deck_id
                tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                trigger_waiting.append(tmp)
                if self.config.order != 0 and duel.already_choosed != 1 and duel.ask2 == 0:
                    duel.ask2 = 4
        for timing in timings3:
            timing_kinds = timing.kinds
            if not self.check_effect_kind(timing_kinds, from_kinds):
                continue
            if "rel" in org and timing.relation_kind in org["rel"]:
                for rel_card in org["rel"][timing.relation_kind]:
                    if int(rel_card["to"]) == int(timing.relation_to) and (
                        rel_card["name"] == timing.relation_name
                        or timing.relation_name == ""
                    ):
                        monsters = timing.monster_relate
                        monster_relate = rel_card["monster"]
                        if not self.check_once_per_turn_relate(rel_card["monster"]["mine_or_other"],rel_card["monster"]["det"]["place_unique_id"]):
                            continue
                        if self.config.sort is True:
                            field_size = FieldSize.objects.get(id=1)
                            if self.field_free is True:
                                field_x = 20
                            else:
                                field_x = field_size.field_x
                            for tmp_x in range(field_x):
                                if field[tmp_x][monster_relate["y"]]["det"] is not None and field[tmp_x][monster_relate["y"]]["det"]["place_unique_id"] == monster_relate["place_unique_id"]:
                                    monster_relate["x"] = tmp_x
                        monster_det = monster_relate["det"]
                        monster_id = self.get_monster_id(
                           monster_det,
                           monster_relate["place"],
                           monster_det["owner"],
                           monster_relate["deck_id"],
                           monster_relate["x"],
                           monster_relate["y"],
                           monster_det["owner"],
                       )
                        if timing.monster_relate_except_flag is True:
                            monsters_except = timing.monster_relate_except
                            flag = True
                            for trigger_monster in monsters_except.all():
                                if trigger_monster.id == monster_id:
                                    flag = False
                                    break
                            if flag is False:
                                continue
                        if timing.monster_relate_specify_flag is True:
                            if not self.check_once_per_turn_relate(monster_relate["mine_or_other"],monster_relate["det"]["place_unique_id"]):
                                continue
                            flag = False
                            if monsters.exists():
                                for trigger_monster in monsters.all():
                                    if trigger_monster.id == monster_id:
                                        flag = True
                            else:
                                flag = True

                            if flag is False:
                                continue
                        if timing.who == 0:
                            user = owner
                        elif timing.who == 1:
                            user = chain_user
                        elif timing.who == 2:
                            if chain_user == 1:
                                user = 2
                            elif chain_user == 2:
                                user = 1
                        elif timing.who == 3:
                            user = from_mine_or_other
                        elif timing.who == 4:
                            user = to_mine_or_other
                        elif timing.who == 5:
                            user = monster_relate["mine_or_other"]
                            if duel.is_ai is True:
                                if user == 1:
                                    if timing.enemy_own == 2:
                                        continue
                                else:
                                    if timing.enemy_own == 0:
                                        continue
                            else:
                                if timing.enemy_own == 2:
                                    continue
                            if (user == 2 and from_mine_or_other == 2) or (
                                user == 1 and from_mine_or_other == 1
                            ):
                                if timing.from_mine_or_other == 2:
                                    continue
                            elif (user == 2 and from_mine_or_other == 1) or (
                                user == 2 and from_mine_or_other == 1
                            ):
                                if timing.from_mine_or_other == 1:
                                    continue
                            if (user == 2 and to_mine_or_other == 2) or (
                                user == 1 and to_mine_or_other == 1
                            ):
                                if timing.to_mine_or_other == 2:
                                    continue
                                elif (user == 2 and to_mine_or_other == 1) or (
                                    user == 2 and to_mine_or_other == 1
                                ):
                                    if timing.to_mine_or_other == 1:
                                        continue
                        if duel.is_ai is True:
                            if user == 1:
                                if timing.enemy_own == 2:
                                    continue
                            else:
                                if timing.enemy_own == 0:
                                    continue
                        else:
                            if timing.enemy_own == 2:
                                continue
                        if timing.monster_exist_specify_flag:
                            num = 0
                            if timing.exist_place_kind == "field":
                                for monster in timing.monster_exist:
                                    num += self.checkMonsterExistField(
                                        monster.id,
                                        timing.exist_field,
                                        user,
                                        timing.exist_kinds,
                                        timing.exist_mine_or_other,
                                        timing.once_per_turn_exist
                                    )
                            elif timing.exist_place_kind == "deck":
                                for monster in timing.monster_exist:
                                    num += self.checkMonsterExistDeck(
                                        monster.id,
                                        timing.exist_deck,
                                        user,
                                        timing.exist_kinds,
                                        timing.exist_mine_or_other,
                                        timing.once_per_turn_exist
                                    )
                            elif timing.exist_place_kind == "grave":
                                for monster in timing.monster_exist:
                                    num += self.checkMonsterExistGrave(
                                        monster.id,
                                        timing.exist_grave,
                                        user,
                                        timing.exist_kinds,
                                        timing.exist_mine_or_other,
                                        timing.once_per_turn_exist
                                    )
                            elif timing.exist_place_kind == "hand":
                                for monster in timing.monster_exist:
                                    num += self.checkMonsterExistHand(
                                        monster.id,
                                        timing.exist_hand,
                                        user,
                                        timing.exist_kinds,
                                        timing.exist_mine_or_other,
                                        timing.once_per_turn_exist
                                    )
                            if num == 0:
                                continue
                        tmp = {}
                        if timing.win_or_lose == 1:
                            self.win_the_game_user(user)
                            return;
                        elif timing.win_or_lose == 2:
                            if user == 1:
                                other_user = 2
                            else:
                                other_user = 1
                            self.win_the_game_user(other_user)
                            return;
                        if timing.trigger.strategy != "":
                            if timing.trigger.strategy in move_to["variables"]:
                                tmp_variable = move_to["variables"][timing.trigger.strategy]
                                if not tmp_variable["value"].isnumeric():
                                    tmp_variable["value"] = 0
                            else:
                                tmp_variable = {}
                                tmp_variable["value"] = 0
                            value = self.check_change_val(
                                move_to, user, move_to["place"], move_to["deck_id"], 0, 0,
                                timing.trigger.strategy,
                                to_mine_or_other,
                                int(tmp_variable["value"])
                            )
                        else:
                            value = 0
                        tmp["who"] = timing.which_monster_effect
                        tmp["monster"] = move_to
                        tmp["move_from"] = move_from
                        tmp["trigger"] = timing.trigger.id
                        tmp["priority"] = timing.trigger.priority
                        tmp["storategy_priority"] = timing.trigger.storategy_priority
                        tmp["mine_or_other"] = user
                        tmp["user"] = user
                        tmp["place"] = place_to
                        tmp["deck_id"] = to_deck_id
                        tmp["x"] = x
                        tmp["y"] = y
                        tmp["from_x"] = from_x
                        tmp["from_y"] = from_y
                        tmp["place_from"] = place_from
                        tmp["deck_id_from"] = from_deck_id
                        tmp["monster_relate"] = monster_relate["det"]
                        tmp["place_unique_id_relate"] = monster_relate["det"]["place_unique_id"]
                        tmp["mine_or_other_relate"] = monster_relate["mine_or_other"]
                        tmp["place_relate"] = monster_relate["place"]
                        tmp["deck_id_relate"] = monster_relate["deck_id"]
                        tmp["x_relate"] = monster_relate["x"]
                        tmp["y_relate"] = monster_relate["y"]
                        tmp["from_x_relate"] = None
                        tmp["from_y_relate"] = None
                        tmp["place_from_relate"] = None
                        tmp["deck_id_from_relate"] = None
                        tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                        trigger_waiting.append(tmp)
                        if self.config.order != 0 and duel.already_choosed != 1 and duel.ask2 == 0:
                            duel.ask2 = 4
        for timing in timings2:
            timing_kinds = timing.kinds
            if not self.check_effect_kind(timing_kinds, from_kinds):
                continue
            if timing.who == 0:
                user = owner
            elif timing.who == 1:
                user = chain_user
            elif timing.who == 2:
                if chain_user == 1:
                    user = 2
                elif chain_user == 2:
                    user = 1
            elif timing.who == 3:
                user = from_mine_or_other
            elif timing.who == 4:
                user = to_mine_or_other
            else:
                user = -1
            if duel.is_ai is True:
                if user == 1:
                    if timing.enemy_own == 2:
                        continue
                elif user == 2:
                    if timing.enemy_own == 0:
                        continue
            else:
                if timing.enemy_own == 2:
                    continue
            if timing.monster_exist_specify_flag:
                num = 0
                if timing.exist_place_kind == "field":
                    for monster in timing.monster_exist:
                        num += self.checkMonsterExistField(
                            monster.id,
                            timing.exist_field,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                elif timing.exist_place_kind == "deck":
                    for monster in timing.monster_exist:
                        num += self.checkMonsterExistDeck(
                            monster.id,
                            timing.exist_deck,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                elif timing.exist_place_kind == "grave":
                    for monster in timing.monster_exist:
                        num += self.checkMonsterExistGrave(
                            monster.id,
                            timing.exist_grave,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                elif timing.exist_place_kind == "hand":
                    for monster in timing.monster_exist:
                        num += self.checkMonsterExistHand(
                            monster.id,
                            timing.exist_hand,
                            user,
                            timing.exist_kinds,
                            timing.exist_mine_or_other,
                            timing.once_per_turn_exist
                        )
                if num == 0:
                    continue
            if timing.relation is False:
                if timing.relation2 is True:
                    if (
                        "rel" in org
                        and timing.relation_kind in org["rel"]
                    ):
                        for rel_card in org["rel"][timing.relation_kind]:
                            if int(rel_card["to"]) == int(timing.relation_to) and (
                                rel_card["name"] == timing.relation_name
                                or timing.relation_name == ""
                            ):
                                '''
                                rel_monster_id = self.get_monster_id_easy(rel_card["monster"]["det"])
                                if not timing.monster.all().filter(
                                    id=rel_monster_id
                                ):
                                    continue
                                '''
                                monster = rel_card["monster"]
                                if timing.win_or_lose == 1:
                                    self.win_the_game_user(user)
                                    return;
                                elif timing.win_or_lose == 2:
                                    if user == 1:
                                        other_user = 2
                                    else:
                                        other_user = 1
                                    self.win_the_game_user(other_user)
                                    return;
                                if timing.trigger.strategy != "":
                                    if timing.trigger.strategy in monster["det"]:
                                        tmp_variable = monster["det"]["variables"][timing.trigger.strategy]
                                        if not tmp_variable["value"].isnumeric():
                                            tmp_variable["value"] = 0
                                    else:
                                        tmp_variable = {}
                                        tmp_variable["value"] = 0
                                    value = self.check_change_val(
                                        monster["det"], user, monster["det"]["place"], monster["det"]["deck_id"], 0, 0,
                                        timing.trigger.strategy,
                                        to_mine_or_other,
                                        int(tmp_variable["value"])
                                    )
                                else:
                                    value = 0
                                tmp = {}
                                tmp["monster"] = monster["det"]
                                tmp["trigger"] = timing.trigger.id
                                tmp["priority"] = timing.trigger.priority
                                tmp["storategy_priority"] = timing.trigger.storategy_priority
                                tmp["mine_or_other"] = user 
                                tmp["user"] = user
                                tmp["place"] = monster["place"]
                                tmp["deck_id"] = monster["deck_id"]
                                tmp["x"] = monster["x"]
                                tmp["y"] = monster["y"]
                                tmp["from_x"] = None
                                tmp["from_y"] = None
                                tmp["place_from"] = None
                                tmp["deck_id_from"] = None
                                tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                                trigger_waiting.append(tmp)
                                if self.config.order != 0 and duel.already_choosed != 1 and duel.ask2 == 0:
                                    duel.ask2 = 4

                else:
                    if timing.win_or_lose == 1:
                        self.win_the_game_user(user)
                        return;
                    elif timing.win_or_lose == 2:
                        if user == 1:
                            other_user = 2
                        else:
                            other_user = 1
                        self.win_the_game_user(other_user)
                        return;
                    if timing.trigger.strategy != "":
                        if timing.trigger.strategy in move_to["variables"]:
                            tmp_variable = move_to["variables"][timing.trigger.strategy]
                            if not tmp_variable["value"].isnumeric():
                                tmp_variable["value"] = 0
                        else:
                            tmp_variable = {}
                            tmp_variable["value"] = 0
                        value = self.check_change_val(
                            move_to, user, move_to["place"], move_to["deck_id"], 0, 0,
                            timing.trigger.strategy,
                            to_mine_or_other,
                            int(tmp_variable["value"])
                        )
                    else:
                        value = 0
                    tmp = {}
                    tmp["who"] = timing.which_monster_effect
                    tmp["monster"] = move_to
                    tmp["move_from"] = move_from
                    tmp["trigger"] = timing.trigger.id
                    tmp["priority"] = timing.trigger.priority
                    tmp["storategy_priority"] = timing.trigger.storategy_priority
                    tmp["mine_or_other"] = user
                    tmp["user"] = user
                    tmp["place"] = place_to
                    tmp["deck_id"] = to_deck_id
                    tmp["x"] = x
                    tmp["y"] = y
                    tmp["from_x"] = from_x
                    tmp["from_y"] = from_y
                    tmp["place_from"] = place_from
                    tmp["deck_id_from"] = from_deck_id
                    tmp["strategy_value"] = value if timing.trigger.strategy_up_or_down == 0 else -value
                    trigger_waiting.append(tmp)
                    if self.config.order != 0 and duel.already_choosed != 1 and duel.ask2 == 0:
                        duel.ask2 = 4
        duel.trigger_waiting = json.dumps(trigger_waiting)
        self.null_relation(
            move_to,
            org,
            place_to,
            place_from,
            to_deck_id,
            x,
            y,
            to_mine_or_other,
            chain_user,
            cost_or_effect,
        )

    def invoke_trigger_waiting(self, trigger_waiting, tmp_priority=0,mode=0):
        duel = self.duel
        flag2 = False
        if duel.ask2 > 0 and mode != 2:
            return False
        if mode == 0:
            trigger_waitings = json.loads(duel.trigger_waiting)
        elif mode == 1:
            trigger_waitings = trigger_waiting
        elif mode == 2:
            trigger_waitings = json.loads(duel.trigger_force)
        trigger_waitings.sort(key=lambda x: (x["priority"],x["storategy_priority"],x["strategy_value"]), reverse=True)
        flag = False
        count = 0
        remove_waitings = []
        for trigger_waiting in trigger_waitings[:]:
            if mode == 2 and flag is True:
                duel.trigger_force = "[]"
                return
            trigger = Trigger.objects.get(id=trigger_waiting["trigger"])
            if trigger.priority < tmp_priority:
                continue
            flag = True
            monster = trigger_waiting["monster"]
            if "who" not in trigger_waiting:
                who = 0
            else:
                who = trigger_waiting["who"]
            if "change_val" in trigger_waiting:
                change_val = trigger_waiting["change_val"]
            else:
                change_val = 0
            if "null_relate" in trigger_waiting:
                null_relate = trigger_waiting["null_relate"]
            else:
                null_relate = None
            if "move_from" in trigger_waiting:
                move_from = trigger_waiting["move_from"]
            else:
                move_from = None
            if "monster_relate" in trigger_waiting:
                monster_relate = trigger_waiting["monster_relate"]
                place_unique_id_relate = trigger_waiting["place_unique_id_relate"]
                mine_or_other_relate = str(trigger_waiting["mine_or_other_relate"])
                x_relate = trigger_waiting["x_relate"]
                y_relate = trigger_waiting["y_relate"]
                place_relate = trigger_waiting["place_relate"]
                deck_id_relate = trigger_waiting["deck_id_relate"]
            else:
                monster_relate = None
                mine_or_other_relate = None
                x_relate = None
                y_relate = None
                place_relate = None
                deck_id_relate = None
            if "monster_exist" in trigger_waiting:
                monster_exist = trigger_waiting["monster_exist"]
                place_unique_id_exist = trigger_waiting["place_unique_id_exist"]
                mine_or_other_exist = str(trigger_waiting["mine_or_other_exist"])
                x_exist = trigger_waiting["x_exist"]
                y_exist = trigger_waiting["y_exist"]
                place_exist = trigger_waiting["place_exist"]
                deck_id_exist = trigger_waiting["deck_id_exist"]
            else:
                monster_exist = None
                place_unique_id_exist = None
                mine_or_other_exist = None
                x_exist = None
                y_exist = None
                place_exist = None
                deck_id_exist = None
            if "move_from_relate" in trigger_waiting:
                move_from_relate = trigger_waiting["move_from_relate"]
                place_from_relate = trigger_waiting["place_from_relate"]
                deck_id_from_relate = trigger_waiting["deck_id_from_relate"]
                from_x_relate = trigger_waiting["from_x_relate"]
                from_y_relate = trigger_waiting["from_y_relate"]
            else:
                place_from_relate = None
                deck_id_from_relate = None
                from_x_relate = None
                from_y_relate = None
            if "move_from_relate" in trigger_waiting:
                move_from_relate = trigger_waiting["move_from_relate"]
            else:
                move_from_relate = None
            if monster:
                place_unique_id = monster["place_unique_id"]
            else:
                place_unique_id = None
            user = trigger_waiting["user"]
            mine_or_other = str(trigger_waiting["mine_or_other"])
            place = trigger_waiting["place"]
            deck_id = trigger_waiting["deck_id"]
            if "place_from" in trigger_waiting:
                place_from = trigger_waiting["place_from"]
                deck_id_from = trigger_waiting["deck_id_from"]
            else:
                place_from = None
                deck_id_from = None

            x = trigger_waiting["x"]
            y = trigger_waiting["y"]
            if(move_from is None):
                from_x = trigger_waiting["x"]
                from_y = trigger_waiting["y"]
            else:
                from_x = move_from["x"]
                from_y = move_from["y"]
            monster_from = {}
            monster_from["x"] = from_x
            monster_from["y"] = from_y
            monster_from["deck_id"] = deck_id_from
            monster_from["place"] = place_from
            if move_from is not None:
                monster_from["place_unique_id"] = move_from["det"]["place_unique_id"]
                if "user" not in move_from :
                    monster_from["user"] = self.user
                monster_from["mine_or_other"] = move_from["mine_or_other"]
                monster_from["det"] = move_from["det"]
            else:
                monster_from["place_unique_id"] = None
                monster_from["user"] = None
                monster_from["mine_or_other"] = None
                monster_from["det"] = None
            if user == 1:
                other_user = 2
            else:
                other_user = 1
            count += 1
            if who == 0:
                if not self.check_launch_trigger(
                    trigger,
                    duel.phase,
                    duel.user_turn,
                    user,
                    other_user,
                    mine_or_other,
                    place,
                    place_unique_id,
                    deck_id,
                    x,
                    y,
                    True,
                    move_from,
                    place_from,
                    deck_id_from,
                    from_x,
                    from_y,
                    monster,
                    place_unique_id_exist,
                ):
                    trigger_waitings.remove(trigger_waiting)
                    remove_waitings.append(trigger_waiting)
                    if len(trigger_waitings) == 0:
                        duel.in_trigger_waiting = False
                    continue
                else:
                    prompt_monster = monster

            elif who == 1:
                if not self.check_launch_trigger(
                        trigger,
                    
                        duel.phase,
                        duel.user_turn,
                        user,
                        other_user,
                        mine_or_other_exist,
                        place_exist,
                        place_unique_id_exist,
                        deck_id_exist,
                        x_exist,
                        y_exist,
                        True
                ):
                    trigger_waitings.remove(trigger_waiting)
                    remove_waitings.append(trigger_waiting)

                    if len(trigger_waitings) == 0:
                        duel.in_trigger_waiting = False
                    continue
                else:
                    prompt_monster = monster_exist
            elif who == 2:
                if null_relate is not None:
                    if not self.check_launch_trigger(
                            trigger,
                            duel.phase,
                            duel.user_turn,
                            user,
                            other_user,
                            null_relate["mine_or_other"],
                            null_relate["place"],
                            null_relate["place_unique_id"],
                            null_relate["deck_id"],
                            null_relate["x"],
                            null_relate["y"],
                            True
                    ):
                        trigger_waitings.remove(trigger_waiting)
                        remove_waitings.append(trigger_waiting)
                        if len(trigger_waitings) == 0:
                           duel.in_trigger_waiting = False
                    continue
                elif monster_relate is not None:
                    if not self.check_launch_trigger(
                            trigger,
                            duel.phase,
                            duel.user_turn,
                            user,
                            other_user,
                            mine_or_other_relate,
                            place_relate,
                            place_unique_id_relate,
                            deck_id_relate,
                            x_relate,
                            y_relate,
                            True
                    ):
                       trigger_waitings.remove(trigger_waiting)
                       remove_waitings.append(trigger_waiting)

                       prompt_monster = monster_relate
                       if len(trigger_waitings) == 0:
                           duel.in_trigger_waiting = False
                       continue
                else:
                       prompt_monster = monster_relate
            duel.in_trigger_waiting = True
            duel.in_cost_force = True
            if trigger.force == 0 and (duel.force == 0 and (user == 1  or duel.is_ai is False)):
                if duel.is_ai is False or user == 1:
                    if user == duel.user_turn:
                        duel.ask = 1
                    else:
                        duel.ask = 2
                elif user == 2:
                    self.answer_ai()
                if trigger.trigger_prompt == "" and (duel.is_ai is False or user == 1):
                    duel.trigger_name = prompt_monster["monster_name"] + "の効果を使用しますか？"
                else:
                    if monster:
                        duel.trigger_name = trigger.trigger_prompt.replace(
                        "@",monster["monster_name"]
                        )
                    else:
                        duel.trigger_name = trigger.trigger_prompt
                    flag = 2
                break
            elif trigger.force >= 1 or duel.force == 2 or (user == 2 and duel.is_ai is True):
                flag = self.invoke_trigger        (
                    trigger,
                    place,
                    monster,
                    mine_or_other,
                    user,
                    deck_id,
                    x,
                    y,
                    monster_from,
                    place_from,
                    deck_id_from,
                    from_x,
                    from_y,
                    0,
                    null_relate,
                    change_val,
                    place_relate,
                    monster_relate,
                    mine_or_other_relate,
                    deck_id_relate,
                    x_relate,
                    y_relate,
                    move_from_relate,
                    place_from_relate,
                    deck_id_from_relate,
                    from_x_relate,
                    from_y_relate,
                    place_exist,
                    monster_exist,
                    mine_or_other_exist,
                    deck_id_exist,
                    x_exist,
                    y_exist,
                    who=who
                )
                if duel.force == 2 :
                    duel.force = 0
            else:
                flag = True
                duel.force = 0
            trigger_waitings.remove(trigger_waiting)
            flag2 = True
            remove_waitings.append(trigger_waiting)
            if len(trigger_waitings) == 0:
                duel.in_trigger_waiting = False
                duel.already_choosed = 0
            if flag is False or flag == 2:
                break
        # invoke_triggerでtriggerが引かれる場合がある
        if mode == 0:
            trigger_waitings2 = json.loads(duel.trigger_waiting)
            for remove_waiting in remove_waitings:
                trigger_waitings2.remove(remove_waiting)
            duel.trigger_waiting = json.dumps(trigger_waitings2)
            if len(trigger_waitings2) == 0:
                duel.in_trigger_waiting = False
                duel.already_choosed = 0

        if flag2 is True:
            duel.current_priority = 10000
        return flag


    def get_variables(self):
        duel = self.duel
        global_variables = json.loads(duel.global_variable)
        virtual_variables = self.virtual_variables
        global_variables.update(virtual_variables)
        return global_variables

    def get_as_monster(self, as_monster):
        duel = self.duel
        place1 = []
        if as_monster[0] == "~":
            tmp = self.cost
            if duel.in_cost is True:
                tmp = tmp[str(int(duel.chain))]
            else:
                tmp = tmp[str(int(duel.chain - 1))]
            if as_monster in tmp:
                place1 = tmp[as_monster]
        elif as_monster[0] == "%":
            tmp = self.timing_mess
            if as_monster in tmp:
                place1 = tmp[as_monster]
        else:
            tmp = self.mess
            tmp = tmp[str(int(duel.chain - 1))]
            if as_monster in tmp:
                place1 = tmp[as_monster]
        return_value = []
        for place2 in place1:
            place2 = copy.deepcopy(place2)
            if "rel" in place2:
                del place2["det"]["rel"]
            return_value.append(place2)
        return return_value

    def delete_monster(self, monster, chain_user):
        field = self.field
        place = monster["monster"]["place"]
        mine_or_other = monster["monster"]["mine_or_other"]
        deck_id = monster["monster"]["deck_id"]
        x = monster["monster"]["x"]
        y = monster["monster"]["y"]
        place_unique_id = monster["monster"]["place_unique_id"]
        if place == "field":
            field[x][y]["det"] = None
            if self.config.sort is True:
                field = self.sortField(field,y)
        elif place == "deck":
            if (self.user == chain_user and int(mine_or_other) == 1) or (
                chain_user != self.user and int(mine_or_other) == 2
            ):
                mine_or_other = 1
            elif (self.user != chain_user and int(mine_or_other) == 1) or (
                chain_user == self.user and int(mine_or_other) == 2
            ):
                mine_or_other = 2
            else:
                mine_or_other = 3
            if mine_or_other == 1:
                tmp = self.decks[deck_id]["mydeck"]
            elif mine_or_other == 2:
                tmp = self.decks[deck_id]["otherdeck"]
            else:
                tmp = self.decks[deck_id]["commondeck"]
            user_decks = tmp
            for index in range(len(user_decks)):
                if place_unique_id == user_decks[index]["place_unique_id"]:
                    del user_decks[index]
            if mine_or_other == 1:
                self.decks[deck_id]["mydeck"] = user_decks
            elif mine_or_other == 2:
                self.decks[deck_id]["otherdeck"] = user_decks
            else:
                self.decks[deck_id]["commondeck"] = user_decks
        elif place == "grave":
            if (self.user == chain_user and int(mine_or_other) == 1) or (
                chain_user != self.user and int(mine_or_other) == 2
            ):
                mine_or_other = 1
            elif (self.user != chain_user and int(mine_or_other) == 1) or (
                chain_user == self.user and int(mine_or_other) == 2
            ):
                mine_or_other = 2
            else:
                mine_or_other = 3
            if mine_or_other == 1:
                tmp = self.graves[deck_id]["mygrave"]
            elif mine_or_other == 2:
                tmp = self.graves[deck_id]["othergrave"]
            else:
                tmp = self.graves[deck_id]["commongrave"]
            user_graves = tmp
            for index in range(len(user_graves)):
                if place_unique_id == user_graves[index]["place_unique_id"]:
                    del user_graves[index]
            if mine_or_other == 1:
                self.graves[deck_id]["mygrave"] = user_graves
            elif mine_or_other == 2:
                self.graves[deck_id]["othergrave"] = user_graves
            else:
                self.graves[deck_id]["commongrave"] = user_graves
        elif place == "hand":
            if (self.user == chain_user and int(mine_or_other) == 1) or (
                chain_user != self.user and int(mine_or_other) == 2
            ):
                mine_or_other = 1
            elif (self.user != chain_user and int(mine_or_other) == 1) or (
                chain_user == self.user and int(mine_or_other) == 2
            ):
                mine_or_other = 2
            else:
                mine_or_other = 3
            if mine_or_other == 1:
                tmp = self.hands[deck_id]["myhand"]
            elif mine_or_other == 2:
                tmp = self.hands[deck_id]["otherhand"]
            else:
                tmp = self.hands[deck_id]["commonhand"]
            user_hands = tmp
            for index in range(len(user_hands)):
                if place_unique_id == user_hands[index]["place_unique_id"]:
                    del user_hands[index]
            if mine_or_other == 1:
                self.hands[deck_id]["myhand"] = user_hands
            elif mine_or_other == 2:
                self.hands[deck_id]["otherhand"] = user_hands
            else:
                self.hands[deck_id]["commonhand"] = user_hands
        self.field = field

    def del_relation(
        self,
        monster,
        relation_name,
        relation_kind,
        relation_to,
        relate_place_unique_id,
        cost_or_effect,
        chain_user,
    ):
        field = self.field
        place = monster["monster"]["place"]
        mine_or_other = int(monster["monster"]["mine_or_other"])
        deck_id = monster["monster"]["deck_id"]
        x = monster["monster"]["x"]
        y = monster["monster"]["y"]
        place_unique_id = monster["monster"]["place_unique_id"]
        if place == "field":
            if self.config.sort is True:
                x = self.search_place_unique_id(y,place_unique_id)
                if x == -1:
                    return
            if field[x][y]["det"] != None and field[x][y]["det"]["place_unique_id"] == place_unique_id:
                for relate_index in range(
                    len(field[x][y]["det"]["rel"][relation_kind])
                ):
                    relate_det = field[x][y]["det"]["rel"][relation_kind][relate_index]
                    if (
                        relate_det["monster"]["det"]["place_unique_id"]
                        == relate_place_unique_id
                    ):
                        self.raise_null_relation(
                            field[x][y]["det"],
                            relate_det["monster"]["det"],
                            relation_kind,
                            relate_det["name"],
                            relate_index,
                            "field",
                            mine_or_other,
                            0,
                            x,
                            y,
                            relate_det["monster"]["place"],
                            relate_det["monster"]["deck_id"],
                            relate_det["monster"]["x"],
                            relate_det["monster"]["y"],
                            relate_det["monster"]["mine_or_other"],
                            cost_or_effect,
                            chain_user,
                        )
                        del field[x][y]["det"]["rel"][relation_kind][relate_index]
                        break
        elif place == "deck":
            if (self.user == chain_user and int(mine_or_other) == 1) or (
                chain_user != self.user and int(mine_or_other) == 2
            ):
                mine_or_other2 = 1
            elif (self.user != chain_user and int(mine_or_other) == 1) or (
                chain_user == self.user and int(mine_or_other) == 2
            ):
                mine_or_other2 = 2
            else:
                mine_or_other2 = 3
            if mine_or_other2 == 1:
                tmp = self.decks[deck_id]["mydeck"]
            elif mine_or_other2 == 2:
                tmp = self.decks[deck_id]["otherdeck"]
            else:
                tmp = self.decks[deck_id]["commondeck"]
            user_decks = tmp
            for index in range(len(user_decks)):
                if place_unique_id == user_decks[index]["place_unique_id"]:
                    for relate_index in range(
                        len(user_decks[index]["rel"][relation_kind])
                    ):
                        relate_det = user_decks[index]["rel"][relation_kind][
                            relate_index
                        ]
                        if (
                            relate_det["monster"]["det"]["place_unique_id"]
                            == "place_unique_id"
                        ):
                            self.raise_null_relation(
                                user_decks[index],
                                relate_det["monster"]["det"],
                                relation_kind,
                                relate_det["name"],
                                relate_index,
                                "deck",
                                mine_or_other,
                                deck_id,
                                0,
                                0,
                                relate_det["monster"]["place"],
                                relate_det["monster"]["deck_id"],
                                relate_det["monster"]["x"],
                                relate_det["monster"]["y"],
                                relate_det["monster"]["mine_or_other"],
                                cost_or_effect,
                                chain_user,
                            )
                            del user_decks[index][relation_kind][relate_index]
            if mine_or_other2 == 1:
                self.decks[deck_id]["mydeck"] = user_decks
            elif mine_or_other2 == 2:
                self.decks[deck_id]["otherdeck"] = user_decks
            else:
                self.decks[deck_id]["commondeck"] = user_decks
        elif place == "grave":
            if (self.user == chain_user and int(mine_or_other) == 1) or (
                chain_user != self.user and int(mine_or_other) == 2
            ):
                mine_or_other2 = 1
            elif (self.user != chain_user and int(mine_or_other) == 1) or (
                chain_user == self.user and int(mine_or_other) == 2
            ):
                mine_or_other2 = 2
            else:
                mine_or_other2 = 3
            if mine_or_other2 == 1:
                tmp = self.graves[deck_id]["mygrave"]
            elif mine_or_other2 == 2:
                tmp = self.graves[deck_id]["othergrave"]
            else:
                tmp = self.graves[deck_id]["commongrave"]
            user_graves = tmp
            for index in range(len(user_graves)):
                if place_unique_id == user_graves[index]["place_unique_id"]:
                    for relate_index in range(
                        len(user_graves[index]["rel"][relation_kind])
                    ):
                        relate_det = user_graves[index]["rel"][relation_kind][
                            relate_index
                        ]
                        if (
                            relate_det["monster"]["det"]["place_unique_id"]
                            == "place_unique_id"
                        ):
                            self.raise_null_relation(
                                user_graves[index],
                                relate_det["monster"]["det"],
                                relation_kind,
                                relate_det["name"],
                                relate_index,
                                "grave",
                                mine_or_other,
                                deck_id,
                                0,
                                0,
                                relate_det["monster"]["place"],
                                relate_det["monster"]["deck_id"],
                                relate_det["monster"]["x"],
                                relate_det["monster"]["y"],
                                relate_det["monster"]["mine_or_other"],
                                cost_or_effect,
                                chain_user,
                            )
                            del user_graves[index][relation_kind][relate_index]
            if mine_or_other2 == 1:
                self.graves[deck_id]["mygrave"] = user_graves
            elif mine_or_other2 == 2:
                self.graves[deck_id]["othergrave"] = user_graves
            else:
                self.graves[deck_id]["commongrave"] = user_graves
        elif place == "hand":
            if (self.user == chain_user and int(mine_or_other) == 1) or (
                chain_user != self.user and int(mine_or_other) == 2
            ):
                mine_or_other2 = 1
            elif (self.user != chain_user and int(mine_or_other) == 1) or (
                chain_user == self.user and int(mine_or_other) == 2
            ):
                mine_or_other2 = 2
            else:
                mine_or_other2 = 3
            if mine_or_other2 == 1:
                tmp = self.hands[deck_id]["myhand"]
            elif mine_or_other2 == 2:
                tmp = self.hands[deck_id]["otherhand"]
            else:
                tmp = self.hands[deck_id]["commonhand"]
            user_hands = tmp
            for index in range(len(user_hands)):
                if place_unique_id == user_hands[index]["place_unique_id"]:
                    for relate_index in range(
                        len(user_hands[index]["rel"][relation_kind])
                    ):
                        relate_det = user_hands[index]["rel"][relation_kind][
                            relate_index
                        ]
                        if (
                            relate_det["monster"]["det"]["place_unique_id"]
                            == "place_unique_id"
                        ):
                            self.raise_null_relation(
                                user_hands[index],
                                relate_det["monster"]["det"],
                                relation_kind,
                                relate_det["name"],
                                relate_index,
                                "hand",
                                mine_or_other,
                                deck_id,
                                0,
                                0,
                                relate_det["monster"]["place"],
                                relate_det["monster"]["deck_id"],
                                relate_det["monster"]["x"],
                                relate_det["monster"]["y"],
                                relate_det["monster"]["mine_or_other"],
                                cost_or_effect,
                                chain_user,
                            )
                            del user_hands[index][relation_kind][relate_index]
            if mine_or_other == 1:
                self.hands[deck_id]["myhand"] = user_hands
            elif mine_or_other == 2:
                self.hands[deck_id]["otherhand"] = user_hands
            else:
                self.hands[deck_id]["commonhand"] = user_hands

    def set_relation(
        self,
        relation_name,
        place2,
        relation_kind,
        relation_from,
        monster,
        place_unique_id,
        from_x,
        from_y,
        deck_id,
        cost_or_effect=0,
        chain_user=None,
        relation_hide = False
    ):
        place = place2["place"]
        field = self.field
        monster = copy.deepcopy(monster)
        monster["det"]["rel"] = None
        if place == "field":
            x = int(place2["x"])
            y = int(place2["y"])
            mine_or_other = field[x][y]["mine_or_other"]
            if "place_unique_id" in place2:
                place_unique_id = place2["place_unique_id"]
            if self.config.sort is True:
                x = self.search_place_unique_id(y,place_unique_id)
                if x == -1:
                    return
            if field[x][y]["det"]["place_unique_id"] == place_unique_id:
                if "rel" not in field[x][y]["det"]:
                    field[x][y]["det"]["rel"] = {}
                if relation_kind not in field[x][y]["det"]["rel"]:
                    field[x][y]["det"]["rel"][relation_kind] = []
                tmp2 = {}
                tmp2["monster"] = copy.deepcopy(monster)
                tmp2["name"] = relation_name
                tmp2["hide"] = relation_hide
                tmp2["to"] = relation_from
                field[x][y]["det"]["rel"][relation_kind].append(tmp2)
                key = len(field[x][y]["det"]["rel"][relation_kind]) - 1
                self.raise_set_relation(
                    monster["det"],
                    field[x][y]["det"],
                    relation_kind,
                    relation_name,
                    key,
                    "field",
                    mine_or_other,
                    0,
                    x,
                    y,
                    monster["place"],
                    monster["deck_id"],
                    monster["x"],
                    monster["y"],
                    monster["mine_or_other"],
                    cost_or_effect,
                    chain_user,
                )
            self.field = field
        elif place == "deck":
            mine_or_other_org = int(place2["mine_or_other"])
            deck_id = place2["deck_id"]
            place_unique_id = place2["place_unique_id"]
            if (self.user == chain_user and mine_or_other_org == 1) or (
                chain_user != self.user and mine_or_other_org == 2
            ):
                mine_or_other = "1"
            elif (self.user != chain_user and mine_or_other_org == 1) or (
                chain_user == self.user and mine_or_other_org == 2
            ):
                mine_or_other = "2"
            else:
                mine_or_other = "3"
            if place == "deck":
                if mine_or_other == "1":
                    tmp = self.decks[deck_id]["mydeck"]
                elif mine_or_other == "2":
                    tmp = self.decks[deck_id]["otherdeck"]
                else:
                    tmp = self.decks[deck_id]["commondeck"]
                user_decks = tmp
                for index in range(len(user_decks)):
                    if place_unique_id == user_decks[index]["place_unique_id"]:
                        if "rel" not in user_decks[index]:
                            user_decks[index]["rel"] = {}
                        if relation_kind not in user_decks[index]["rel"]:
                            user_decks[index]["rel"][relation_kind] = []
                        tmp2 = {}
                        tmp2["monster"] = copy.deepcopy(monster)
                        tmp2["name"] = relation_name
                        tmp2["hide"] = relation_hide
                        tmp2["to"] = relation_from
                        user_decks[index]["rel"][relation_kind].append(tmp2)
                        key = len(user_decks[index]["rel"][relation_kind]) - 1
                        self.raise_set_relation(
                            monster["det"],
                            user_decks[index],
                            relation_kind,
                            relation_name,
                            key,
                            "deck",
                            mine_or_other_org,
                            deck_id,
                            0,
                            0,
                            monster["place"],
                            monster["deck_id"],
                            monster["x"],
                            monster["y"],
                            monster["mine_or_other"],
                            cost_or_effect,
                            chain_user,
                        )
                if mine_or_other == "1":
                    self.decks[deck_id]["mydeck"] = user_decks
                elif mine_or_other == "2":
                    self.decks[deck_id]["otherdeck"] = user_decks
                else:
                    self.decks[deck_id]["commondeck"] = user_decks
            elif place == "grave":
                mine_or_other_org = int(place2["mine_or_other"])
                deck_id = place2["deck_id"]
                place_unique_id = place2["place_unique_id"]
                if (self.user == chain_user and mine_or_other_org == 1) or (
                    chain_user != self.user and mine_or_other_org == 2
                ):
                    mine_or_other = "1"
                elif (self.user != chain_user and mine_or_other_org == 1) or (
                    chain_user == self.user and mine_or_other_org == 2
                ):
                    mine_or_other = "2"
                else:
                    mine_or_other = "3"
                if place == "grave":
                    if mine_or_other == "1":
                        tmp = self.graves[deck_id]["mygrave"]
                    elif mine_or_other == "2":
                        tmp = self.graves[deck_id]["othergrave"]
                    else:
                        tmp = self.graves[deck_id]["commongrave"]
                    user_graves = tmp
                    for index in range(len(user_graves)):
                        if place_unique_id == user_graves[index]["place_unique_id"]:
                            if "rel" not in user_graves[index]:
                                user_graves[index]["rel"] = {}
                            if relation_kind not in user_graves[index]["rel"]:
                                user_graves[index]["rel"][relation_kind] = []
                            tmp2 = {}
                            tmp2["monster"] = copy.deepcopy(monster)
                            tmp2["name"] = relation_name
                            tmp2["hide"] = relation_hide
                            tmp2["to"] = relation_from
                            user_graves[index]["rel"][relation_kind].append(tmp2)
                            key = len(user_graves[index]["rel"][relation_kind]) - 1
                            self.raise_set_relation(
                                monster["det"],
                                user_graves[index],
                                relation_kind,
                                relation_name,
                                key,
                                "grave",
                                mine_or_other_org,
                                deck_id,
                                0,
                                0,
                                monster["place"],
                                monster["deck_id"],
                                monster["x"],
                                monster["y"],
                                monster["mine_or_other"],
                                cost_or_effect,
                                chain_user,
                            )
                if mine_or_other == "1":
                    self.graves[deck_id]["mygrave"] = user_graves
                elif mine_or_other == "2":
                    self.graves[deck_id]["othergrave"] = user_graves
                else:
                    self.graves[deck_id]["commongrave"] = user_graves
            elif place == "hand":
                mine_or_other_org = int(place2["mine_or_other"])
                deck_id = place2["deck_id"]
                place_unique_id = place2["place_unique_id"]
                if (self.user == chain_user and mine_or_other_org == 1) or (
                    chain_user != self.user and mine_or_other_org == 2
                ):
                    mine_or_other = "1"
                elif (self.user != chain_user and mine_or_other_org == 1) or (
                    chain_user == self.user and mine_or_other_org == 2
                ):
                    mine_or_other = "2"
                else:
                    mine_or_other = "3"
                if place == "hand":
                    if mine_or_other == "1":
                        tmp = self.hands[deck_id]["myhand"]
                    elif mine_or_other == "2":
                        tmp = self.hands[deck_id]["otherhand"]
                    else:
                        tmp = self.hands[deck_id]["commonhand"]
                    user_hands = tmp
                    for index in range(len(user_hands)):
                        if place_unique_id == user_hands[index]["place_unique_id"]:
                            if "rel" not in user_hands[index]:
                                user_hands[index]["rel"] = {}
                            if relation_kind not in user_hands[index]["rel"]:
                                user_hands[index]["rel"][relation_kind] = []
                            tmp2 = {}
                            tmp2["monster"] = copy.deepcopy(monster)
                            tmp2["name"] = relation_name
                            tmp2["hide"] = relation_hide
                            tmp2["to"] = relation_from
                            user_hands[index]["rel"][relation_kind].append(tmp2)
                            key = len(user_hands[index]["rel"][relation_kind]) - 1
                            self.raise_set_relation(
                                monster["det"],
                                user_hands[index],
                                relation_kind,
                                relation_name,
                                key,
                                "hand",
                                mine_or_other_org,
                                deck_id,
                                0,
                                0,
                                monster["place"],
                                monster["deck_id"],
                                monster["x"],
                                monster["y"],
                                monster["mine_or_other"],
                                cost_or_effect,
                                chain_user,
                            )
                if mine_or_other == "1":
                    self.hands[deck_id]["myhand"] = user_hands
                elif mine_or_other == "2":
                    self.hands[deck_id]["otherhand"] = user_hands
                else:
                    self.hands[deck_id]["commonhand"] = user_hands

    """
    def check_dest(self,monster,user):
        return_value = {}
        place = monster["place"]
        return_value["place"] = place
        if(place == "field"):
            x = monster["x"]
            y = monster["y"]
            field = self.field
            if self.field_free ==False:
                field_det = field[x][y]
            else:
                field_det = field[0][y]
            mine_or_other = field_det["mine_or_other"]
            return_value["kind"] = field_det["kind"]
        else:
            x=0
            y=0
            return_value["kind"] = monster["deck_id"]
            mine_or_other = monster["mine_or_other"]
        if user == 1:
            return_value["mine_or_other2"] = int( mine_or_other)
        elif user == 2:
            if int(mine_or_other) == 1:
                return_value["mine_or_other2"] = 2
            elif int(mine_or_other) == 2:
                return_value["mine_or_other2"] = 1
            else:
                return_value["mine_or_other2"] = mine_or_other
        else :
            return_value["mine_or_other2"] = mine_or_other
        return return_value
    """
    # リレーションされたモンスター取得
    def get_relation_monster(
        self, monster, monster_effect, effect_kind_rel, chain_user
    ):
        field = self.field
        return_monsters = []
        for index in range(len(monster_effect["relation_name"])):
            relation_name = monster_effect["relation_name"][index]
            relation_kind = monster_effect["put_relation_kind"][index]
            relation_to = int(monster_effect["put_relation_to"][index])
            if relation_kind != "" and relation_kind not in monster["rel"]:
                continue
            for index2 in range(len(monster["rel"][relation_kind]) - 1, -1, -1):
                if relation_name != "":
                    if monster["rel"][relation_kind][index2]["name"] != relation_name:
                        continue
                if monster["rel"][relation_kind][index2]["to"] != relation_to:
                    continue
                tmp_monster = monster["rel"][relation_kind][index2]["monster"]
                mine_or_other = tmp_monster["mine_or_other"]
                place_unique_id = tmp_monster["place_unique_id"]
                if self.user == 1:
                    mine_or_other2 = mine_or_other
                elif self.user == 2:
                    if int(mine_or_other) == 1:
                        mine_or_other2 = 2
                    elif int(mine_or_other) == 2:
                        mine_or_other2 = 1
                    else:
                        mine_or_other2 = mine_or_other
                if self.check_not_effected(
                    tmp_monster["det"],
                    tmp_monster["user"],
                    effect_kind_rel,
                    tmp_monster["place"],
                    tmp_monster["deck_id"],
                    tmp_monster["x"],
                    tmp_monster["y"],
                    mine_or_other,
                ):
                    continue
                if tmp_monster["place"] == "field":
                    x = tmp_monster["x"]
                    y = tmp_monster["y"]
                    return_monster = self.field[x][y]["det"]
                    tmp_monster["org_det"] = copy.deepcopy(return_monster)
                    tmp_monster["det"] = self.copy_monster_from_field(
                        return_monster,
                        field[x][y]["kind"],
                        field[x][y]["mine_or_other"],
                    )
                # いちいち探してるのはリレーション復元のため
                elif tmp_monster["place"] == "deck":
                    deck_id = tmp_monster["deck_id"]
                    if mine_or_other2 == 1:
                        decks = self.decks[deck_id]["mydeck"]
                    elif mine_or_other2 == 2:
                        decks = self.decks[deck_id]["otherdeck"]
                    elif mine_or_other2 == 3:
                        decks = self.decks[deck_id]["commondeck"]
                    for deck in decks:
                        if deck["place_unique_id"] == place_unique_id:
                            tmp_monster["org_det"] = copy.deepcopy(deck)
                            tmp_monster["det"] = self.copy_monster_from_deck(
                                deck, deck_id, mine_or_other
                            )
                elif tmp_monster["place"] == "grave":
                    deck_id = tmp_monster["deck_id"]
                    if mine_or_other2 == 1:
                        graves = self.graves[deck_id]["mygrave"]
                    elif mine_or_other2 == 2:
                        graves = self.graves[deck_id]["othergrave"]
                    elif mine_or_other2 == 3:
                        graves = self.graves[deck_id]["commongrave"]
                    for grave in graves:
                        if grave["place_unique_id"] == place_unique_id:
                            tmp_monster["org_det"] = copy.deepcopy(grave)
                            tmp_monster["det"] = self.copy_monster_from_grave(
                                grave, deck_id, mine_or_other
                            )
                elif tmp_monster["place"] == "hand":
                    deck_id = tmp_monster["deck_id"]
                    if mine_or_other2 == 1:
                        hands = self.hands[deck_id]["myhand"]
                    elif mine_or_other2 == 2:
                        hands = self.hands[deck_id]["otherhand"]
                    elif mine_or_other2 == 3:
                        hands = self.hands[deck_id]["commonhand"]
                    for hand in hands:
                        if hand["place_unique_id"] == place_unique_id:
                            tmp_monster["org_det"] = copy.deepcopy(hand)
                            tmp_monster["det"] = self.copy_monster_from_hand(
                                hand, deck_id, mine_or_other, mine_or_other
                            )
                return_monsters.append(tmp_monster)
                self.delete_monster(monster["rel"][relation_kind][index2], chain_user)
        return return_monsters

    def get_next_effect(self, monster_effect_text, user):
        duel = self.duel
        if duel.chain -2 < 0:
            return None
        chain_det_trigger = json.loads(self.duel.chain_det_trigger)
        trigger = chain_det_trigger[str(duel.chain - 2)]
        monster_effects = json.loads(monster_effect_text)
        for monster_effect in monster_effects:
            if trigger == monster_effect["trigger"]:
                if monster_effect["next_pac"] != 0:
                    pac = PacWrapper.objects.get(id=monster_effect["next_pac"])
                    return self._pac(pac)
                else:
                    effect = MonsterEffectWrapper.objects.get(
                        id=monster_effect["next_effect"]
                    )
                    return effect
        return self.pop_pac(user)

    def is_float(self, n):
        try:
            float(n)
        except ValueError:
            return False
        else:
            return True

    def get_koka(self):
        cost = self.cost
        koka = []
        chain = 0
        for cost_det in cost:
            chain += 1
            for variable in cost[cost_det]:
                if variable != "~trigger" and variable != "~trigger_org" and variable != "~trigger_org_relate" and variable != "~trigger_relate":
                    for cost_det_det in cost[cost_det][variable]:
                        tmp = {}
                        tmp["koka"] = cost_det_det
                        tmp["chain"] = chain

                        koka.append(tmp)
                else:
                    for cost_det_det in cost[cost_det][variable]:
                        tmp = {}
                        tmp["trigger"] = cost_det_det
                        tmp["koka"] = None
                        tmp["chain"] = chain

                        if not tmp in koka:
                            koka.append(tmp)
        return koka

    def move_to_flag(self, flag_change_how, move_to, flag_change_val):
        if flag_change_how != "0":
            if "flag" not in move_to:
                move_to["flag"] = 0
            if flag_change_how == "1":
                move_to["flag"] += int(flag_change_val)
            elif flag_change_how == "2":
                move_to["flag"] -= int(flag_change_val)
            elif flag_change_how == "3":
                move_to["flag"] = int(flag_change_val)
            elif flag_change_how == "4":
                move_to["flag"] = int(flag_change_val) | move_to["flag"]
            elif flag_change_how == "5":
                move_to["flag"] -= (int(flag_change_val)) & move_to["flag"]
        return move_to

    def unmute(self):
        self.duel.log_turn += self.duel.cost_log
        self.duel.log += self.duel.cost_log
        self.current_log += self.duel.cost_log
        self.duel.cost_log = ""

    def checkMonsterExistField(
        self, monster_id, field_kind, mine_or_other, effect_kind, exist_mine_or_other,exist_once_per_turn
    ):
        field = self.field
        num = []
        if mine_or_other == 2:
            if exist_mine_or_other == 1:
                mine_or_other_absolute = 2
            elif exist_mine_or_other == 2:
                mine_or_other_absolute = 1
            else:
                mine_or_other_absolute = exist_mine_or_other
        else:
            mine_or_other_absolute = exist_mine_or_other
        for x in range(len(field)):
            for y in range(len(field[x])):
                if field[x][y]["kind"] != str(field_kind):
                    continue
                if (
                    field[x][y]["mine_or_other"] != mine_or_other_absolute
                    and mine_or_other_absolute != 0
                ):
                    continue
                monster_id_det = self.get_monster_id(
                    field[x][y]["det"],
                    "field",
                    field[x][y]["mine_or_other"],
                    0,
                    x,
                    y,
                    field[x][y]["mine_or_other"],
                )
                if monster_id != monster_id_det:
                    continue
                if self.check_eternal_invalid(
                    field[x][y]["det"],
                    field[x][y]["mine_or_other"],
                    effect_kind,
                    "field",
                    0,
                    x,
                    y,
                    field[x][y]["mine_or_other"],
                ):
                    continue
                if exist_once_per_turn and not self.check_once_per_turn_exist(mine_or_other_absolute,field[x][y]["det"]["place_unique_id"]):
                    continue
                tmp = {}
                tmp["monster_exist"] = field[x][y]["det"]
                tmp["mine_or_other_exist"] = field[x][y]["mine_or_other"]
                tmp["place_unique_id_exist"] = field[x][y]["det"]["place_unique_id"]
                tmp["place_exist"] = "field"
                tmp["deck_id_exist"] = 0
                tmp["x_exist"] = x
                tmp["y_exist"] = y
                num.append(tmp)
        return num

    def check_effect_kind(self, check_kinds, effect_kinds):
        if check_kinds == "":
            return True
        check_kinds = check_kinds.split("_")
        effect_kinds = str(effect_kinds).split("_")

        return_flag = True
        for check_kind in check_kinds:
            check_kinds2 = check_kind.split("-")
            flag = False
            for check_kind2 in check_kinds2:
                if check_kind2[0] == "!":
                    if check_kind2[1:] not in effect_kinds:
                        flag = True
                        break
                elif check_kind2 in effect_kinds:
                    flag = True
                    break
            if flag is False:
                return_flag = False
        return return_flag

    def checkMonsterExistDeck(
        self, monster_id, deck_id, mine_or_other, effect_kind, exist_mine_or_other,exist_once_per_turn
    ):
        num = []
        if mine_or_other == 2:
            if exist_mine_or_other == 1:
                mine_or_other_absolute = 2
            elif exist_mine_or_other == 2:
                mine_or_other_absolute = 1
            else:
                mine_or_other_absolute = exist_mine_or_other
        else:
            mine_or_other_absolute = exist_mine_or_other
        if self.user == 2:
            if mine_or_other_absolute == 1:
                mine_or_other_relative = 2
            elif mine_or_other_absolute == 2:
                mine_or_other_relative = 1
            else:
                mine_or_other_relative = mine_or_other_absolute
        else:
            mine_or_other_relative = mine_or_other_absolute
        if mine_or_other_relative == 1:
            decks = self.decks[deck_id]["mydeck"]
        elif mine_or_other_relative == 2:
            decks = self.decks[deck_id]["otherdeck"]
        elif mine_or_other_relative == 3:
            decks = self.decks[deck_id]["commondeck"]
        else:
            decks = self.decks[deck_id]["mydeck"]
        for deck in decks:
            monster_id_det = self.get_monster_id_easy(deck)
            if monster_id != monster_id_det:
                continue
            if self.check_eternal_invalid(
                deck, self.user, effect_kind, "deck", deck_id, 0, 0, self.user
            ):
                continue
            if  exist_once_per_turn and not self.check_once_per_turn_exist(mine_or_other_absolute,deck["place_unique_id"]):
                continue
            tmp = {}
            tmp["monster_exist"] = deck
            tmp["place_unique_id_exist"] = deck["place_unique_id"]
            tmp["mine_or_other_exist"] = mine_or_other_absolute
            tmp["place_exist"] = "deck"
            tmp["deck_id_exist"] = deck_id
            tmp["x_exist"] = 0
            tmp["y_exist"] = 0
            num.append(tmp)

        return num

    def checkMonsterExistGrave(
        self, monster_id, deck_id, mine_or_other, effect_kind, exist_mine_or_other,exist_once_per_turn
    ):
        num = []
        if mine_or_other == 2:
            if exist_mine_or_other == 1:
                mine_or_other_absolute = 2
            elif exist_mine_or_other == 2:
                mine_or_other_absolute = 1
            else:
                mine_or_other_absolute = exist_mine_or_other
        else:
            mine_or_other_absolute = exist_mine_or_other
        if self.user == 2:
            if mine_or_other_absolute == 1:
                mine_or_other_relative = 2
            elif mine_or_other_absolute == 2:
                mine_or_other_relative = 1
            else:
                mine_or_other_relative = mine_or_other_absolute
        else:
            mine_or_other_relative = mine_or_other_absolute
        if mine_or_other_relative == 1:
            graves = self.graves[deck_id]["mygrave"]
        elif mine_or_other_relative == 2:
            graves = self.graves[deck_id]["othergrave"]
        elif mine_or_other_relative == 3:
            graves = self.graves[deck_id]["commongrave"]
        else:
            graves = self.graves[deck_id]["mygrave"]
        for grave in graves:
            monster_id_det = self.get_monster_id_easy(grave)
            if monster_id != monster_id_det:
                continue
            if self.check_eternal_invalid(
                grave, self.user, effect_kind, "grave", deck_id, 0, 0, self.user
            ):
                continue
            if  exist_once_per_turn and not self.check_once_per_turn_exist(mine_or_other_absolute,grave["place_unique_id"]):
                continue
            tmp = {}
            tmp["monster_exist"] = grave
            tmp["place_unique_id_exist"] = grave["place_unique_id"]
            tmp["mine_or_other_exist"] = mine_or_other_absolute
            tmp["place_exist"] = "grave"
            tmp["deck_id_exist"] = deck_id
            tmp["x_exist"] = 0
            tmp["y_exist"] = 0
            num.append(tmp)
        return num

    def checkMonsterExistHand(
        self, monster_id, deck_id, mine_or_other, effect_kind, exist_mine_or_other,exist_once_per_turn
    ):
        num = []
        if mine_or_other == 2:
            if exist_mine_or_other == 1:
                mine_or_other_absolute = 2
            elif exist_mine_or_other == 2:
                mine_or_other_absolute = 1
            else:
                mine_or_other_absolute = exist_mine_or_other
        else:
            mine_or_other_absolute = exist_mine_or_other
        if self.user == 2:
            if mine_or_other_absolute == 1:
                mine_or_other_relative = 2
            elif mine_or_other_absolute == 2:
                mine_or_other_relative = 1
            else:
                mine_or_other_relative = mine_or_other_absolute
        else:
            mine_or_other_relative = mine_or_other_absolute
        if mine_or_other_relative == 1:
            hands = self.hands[deck_id]["myhand"]
        elif mine_or_other_relative == 2:
            hands = self.hands[deck_id]["otherhand"]
        elif mine_or_other_relative == 3:
            hands = self.hands[deck_id]["commonhand"]
        else:
            hands = self.hands[deck_id]["myhand"]
        for hand in hands:
            monster_id_det = self.get_monster_id_easy(hand)
            if monster_id != monster_id_det:
                continue
            if self.check_eternal_invalid(
                hand, self.user, effect_kind, "hand", deck_id, 0, 0, mine_or_other_absolute
            ):
                continue
            if  exist_once_per_turn and not self.check_once_per_turn_exist(mine_or_other_absolute,hand["place_unique_id"]):
                continue
            tmp = {}
            tmp["monster_exist"] = hand
            tmp["place_unique_id_exist"] = hand["place_unique_id"]
            tmp["mine_or_other_exist"] = mine_or_other_absolute
            tmp["place_exist"] = "hand"
            tmp["deck_id_exist"] = deck_id
            tmp["x_exist"] = 0
            tmp["y_exist"] = 0
            num.append(tmp)
        return num

    def check_under(self, under_condition, monster, monster2):
        flag = under_condition["flag"]
        monster_name_kind = under_condition["monster_name_kind"]
        monster_condition_val = under_condition["monster_condition"]
        equation_kind = under_condition["equation"]["equation_kind"]
        count = 0
        variety = []
        same_name = {}
        variable_variety = []
        variable_counter = 0
        counter = -1
        x_counter = 0
        y_counter = 0
        if equation_kind == "x":
            counter = "x"
        elif equation_kind == "y":
            counter = "y"
        elif (
            equation_kind != "number"
            and equation_kind != "kind"
            and equation_kind != "same_name"
        ):
            counter = equation_kind
        if "under" not in monster:
            pass
        else:
            for under_monster in monster["under"]:
                under_monster2 = {}
                under_monster2["det"] = under_monster
                under_monster2["mine_or_other"] = monster2["mine_or_other"]
                under_monster2["user"] = monster2["user"]
                under_monster2["place"] = "under"
                under_monster2["deck_id"] = monster2["deck_id"]
                under_monster2["x"] = monster2["x"]
                under_monster2["y"] = monster2["y"]
                under_monster2["place_unique_id"] = monster["place_unique_id"]
                if flag:
                    flag_det = int(flag["flag_det"])
                    if flag["operator"] == "=":
                        if under_monster["flag"] != int(flag_det):
                            continue
                    elif flag["operator"] == "&":
                        if under_monster["flag"] & int(flag_det) == 0:
                            continue
                    elif flag["operator"] == "^":
                        if under_monster["flag"] & int(flag_det) != 0:
                            continue
                current_and_or = "and"
                name_flag = True
                for name_kind in monster_name_kind:
                    if name_kind != "":
                        if name_kind["operator"] == "=":
                            if under_monster["monster_name"] != self.get_name(
                                name_kind["monster_name"], 0, monster
                            ):
                                if current_and_or == "and":
                                    name_flag = False
                            else:
                                if current_and_or == "or":
                                    name_flag = True
                            current_and_or = name_kind["and_or"]
                        elif name_kind["operator"] == "!=":
                            if under_monster["monster_name"] == self.get_name(
                                name_kind["monster_name"], 0, under_monster
                            ):
                                if current_and_or == "and":
                                    name_flag = False
                            else:
                                if current_and_or == "or":
                                    name_flag = True

                    elif name_kind["operator"] == "like":
                        if (
                            under_monster["monster_name"].find(
                                self.get_name(
                                    name_kind["monster_name"], 0, under_monster
                                )
                            )
                            > -1
                        ):
                            if current_and_or == "and":
                                name_flag = False
                        else:
                            if current_and_or == "or":
                                name_flag = True
                    current_and_or = name_kind["and_or"]
                if name_flag is False:
                    continue
                cond_flag = True
                for cond_det in monster_condition_val:
                    current_and_or = "and"
                    tmp_flag = True

                    for cond_val in cond_det:
                        if not cond_val:
                            continue
                        # cond_val["name"] = self.check_swap_val(monster,monster2["mine_or_other"],monster2["place"],monster2["deck_id"],monster2["x"],monster2["y"],cond_val["name"],monster2["mine_or_other"])
                        tmp = under_monster["variables"][cond_val["name"]]

                        if cond_val["init"] == 0:
                            # value_tmp= self.check_change_val(monster,monster2["mine_or_other"],monster2["place"],monster2["deck_id"],monster2["x"],monster2["y"],cond_val["name"],monster2["mine_or_other"])
                            value = int(tmp["value"])
                            value += self.check_change_val(under_monster,under_monster2["mine_or_other"],under_monster2["place"],under_monster2["deck_id"],under_monster2["x"],under_monster2["y"],cond_val["name"],under_monster2["mine_or_other"])
                        elif cond_val["init"] == 1:
                            value = tmp["i_val"]
                        elif cond_val["init"] == 2:
                            value = tmp["i_i_val"]
                        if cond_val["operator"] == "=" or cond_val["operator"] == "":
                            if int(value) != self.calculate_boland(
                                cond_val["num"], under_monster2, False
                            ):
                                tmp_flag = False
                        elif cond_val["operator"] == "<=":
                            if int(value) > self.calculate_boland(
                                cond_val["num"], under_monster2, False
                            ):
                                tmp_flag = False
                        elif cond_val["operator"] == ">=":
                            if int(value) < self.calculate_boland(
                                cond_val["num"], under_monster2, False
                            ):
                                tmp_flag = False
                        elif cond_val["operator"] == "!=":
                            if int(value) == self.calculate_boland(
                                cond_val["num"], None, False
                            ):
                                tmp_flag = False
                        if current_and_or == "and":
                            if cond_flag is True:
                                cond_flag = tmp_flag

                        else:
                            if cond_flag is False:
                                cond_flag = tmp_flag
                    current_and_or = cond_val["and_or"]
                if cond_flag is False:
                    continue
                if (
                    "monster_effect" in under_condition
                    and under_condition["monster_effect"] != 0
                ):
                    monster_id = under_monster["id"]
                    if monster_id != under_condition["monster_effect"]:
                        continue
                if counter == "x":
                    x_counter += under_monster2["x"]
                elif counter == "y":
                    y_counter += under_monster2["y"]
                elif counter != -1:
                    variable = under_monster2["det"]["variables"][counter]["value"]
                    tmp_varieties = variable.split("_")
                    for tmp_variety in tmp_varieties:
                        variable_variety.append(tmp_variety)
                    variable_counter += int(variable["value"])
                if monster["id"] not in variety:
                    variety.append(monster["id"])
                if monster["monster_name"] not in same_name:
                    same_name[monster["monster_name"]] = 0
                same_name[monster["monster_name"]] += 1
                count += 1
        min_equation_number = under_condition["min_equation_number"]
        max_equation_number = under_condition["max_equation_number"]
        and_or = "and"
        flag = True
        if equation_kind == "number":
            if count >= self.calculate_boland(
                min_equation_number, monster2
            ) and count <= self.calculate_boland(max_equation_number, monster2):
                if and_or == "or":
                    flag = True
                elif flag is True:
                    flag = True
            else:
                if and_or == "and":
                    flag = False
                elif flag is False:
                    flag = False

        elif equation_kind == "kind":
            if len(variety) >= self.calculate_boland(
                min_equation_number, under_monster2
            ) and len(variety) <= self.calculate_boland(max_equation_number, under_monster2):
                if and_or == "or":
                    flag = True
                elif flag is True:
                    flag = True
            else:
                if and_or == "and":
                    flag = False
                elif flag is False:
                    flag = False
        elif equation_kind == "same_name":
            same_name_max = max(same_name.values())
            if (
                same_name
                and same_name_max
                >= self.calculate_boland(min_equation_number, under_monster2)
                and same_name_max
                <= self.calculate_boland(max_equation_number, under_monster2)
            ):
                if and_or == "or":
                    flag = True
                elif flag is True:
                    flag = True
            else:
                if and_or == "and":
                    flag = False
                elif flag is False:
                    flag = False
        elif counter == "x":
            if x_counter >= self.calculate_boland(
                min_equation_number, under_monster2
            ) and x_counter <= self.calculate_boland(max_equation_number, under_monster2):
                if and_or == "or":
                    flag = True
                elif flag is True:
                    flag = True
            else:
                if and_or == "and":
                    flag = False
                elif flag is False:
                    flag = False
        elif counter == "y":
            if y_counter >= self.calculate_boland(
                min_equation_number, under_monster2
            ) and y_counter <= self.calculate_boland(max_equation_number, under_monster2):
                if and_or == "or":
                    flag = True
                elif flag is True:
                    flag = True
            else:
                if and_or == "and":
                    flag = False
                elif flag is False:
                    flag = False
        else:
            if variable_counter >= self.calculate_boland(
                min_equation_number, under_monster2
            ) and variable_counter <= self.calculate_boland(max_equation_number, under_monster2):
                if and_or == "or":
                    flag = True
                elif flag is True:
                    flag = True
            else:
                if and_or == "and":
                    flag = False
                elif flag is False:
                    flag = False
        return flag

    def get_all_under(self, monster):
        return_value = []
        if "under" in monster:
            for under in monster["under"]:
                return_value.append(under)
            del monster["under"]
        return_value.append(monster)
        return return_value

    def damage_monster(self, monster, val_name, change_val):
        place = monster["place"]
        deck_id = monster["deck_id"]
        x = monster["x"]
        y = monster["y"]
        mine_or_other = monster["mine_or_other"]
        place_unique_id = monster["place_unique_id"]
        duel = self.duel
        field = duel.field
        if duel.in_cost is True:
            chain_user = json.loads(duel.chain_user)
            chain_user = chain_user[str(self.tmp_chain)]
        elif duel.chain == 0 or duel.ask > 0:
            chain_user = self.user
        else:
            chain_user = json.loads(duel.chain_user)
            chain_user = chain_user[str(duel.chain - 1)]
        if place == "field":
            if "eternal" not in field[x][y]["det"]:
                field[x][y]["det"]["eternal"] = []
            change_val_eternal = {}
            change_val_eternal["variables"] = {}
            change_val_eternal["variables"][val_name] = {}
            change_val_eternal["variables"][val_name]["ini"] = 0
            change_val_eternal["variables"][val_name]["value"] = -change_val
            change_val_eternal["monster_variable_change_life"] = "turn_3"
            change_val_eternal["monster_variable_change_life_length"] = 1
            change_val_eternal["effect_kind"] = -1
            field[x][y]["det"]["eternal"].append(change_val_eternal)
            return
        if (mine_or_other == 1 and chain_user == 1) or (
            mine_or_other == 2 and chain_user == 2
        ):
            mine_or_other2 = 1
        elif (mine_or_other == 2 and chain_user == 1) or (
            mine_or_other == 1 and chain_user == 2
        ):
            mine_or_other2 = 2
        else:
            mine_or_other2 = 3
        if place == "deck":
            if mine_or_other2 == 1:
                deck = self.decks[deck_id]["mydeck"]
            elif mine_or_other2 == 2:
                deck = self.decks[deck_id]["otherdeck"]
            elif mine_or_other2 == 3:
                deck = self.decks[deck_id]["commondeck"]
            i = 0
            for i in range(len(deck)):
                if deck[i]["place_unique_id"] != place_unique_id:
                    continue
                if "eternal" not in deck[i]:
                    deck[i]["eternal"] = []
                change_val_eternal = {}
                change_val_eternal["variables"] = {}
                change_val_eternal["variables"][val_name] = {}
                change_val_eternal["variables"][val_name]["ini"] = 0
                change_val_eternal["variables"][val_name]["value"] = -change_val
                change_val_eternal["monster_variable_change_life"] = "turn_3"
                change_val_eternal["monster_variable_change_life_length"] = 1
                change_val_eternal["effect_kind"] = -1
                deck[i]["eternal"].append(change_val_eternal)
                break
            if mine_or_other2 == 1:
                self.decks[deck_id]["mydeck"] = deck
            elif mine_or_other2 == 2:
                self.decks[deck_id]["otherdeck"] = deck
            elif mine_or_other2 == 3:
                self.decks[deck_id]["commondeck"] = deck
        if place == "grave":
            if mine_or_other2 == 1:
                deck = self.graves[deck_id]["mygrave"]
            elif mine_or_other2 == 2:
                deck = self.graves[deck_id]["othergrave"]
            elif mine_or_other2 == 3:
                deck = self.graves[deck_id]["commongrave"]
            i = 0
            for i in range(len(deck)):
                if deck[i]["place_unique_id"] != place_unique_id:
                    continue
                if "eternal" not in deck[i]:
                    deck[i]["eternal"] = []
                change_val_eternal = {}
                change_val_eternal["variables"] = {}
                change_val_eternal["variables"][val_name] = {}
                change_val_eternal["variables"][val_name]["ini"] = 0
                change_val_eternal["variables"][val_name]["value"] = -change_val
                change_val_eternal["monster_variable_change_life"] = "turn_3"
                change_val_eternal["monster_variable_change_life_length"] = 1
                change_val_eternal["effect_kind"] = -1
                deck[i]["eternal"].append(change_val_eternal)
                break
            if mine_or_other2 == 1:
                self.graves[deck_id]["mygrave"] = deck
            elif mine_or_other2 == 2:
                self.graves[deck_id]["othergrave"] = deck
            elif mine_or_other2 == 3:
                self.graves[deck_id]["commongrave"] = deck
        if place == "hand":
            if mine_or_other2 == 1:
                deck = self.hands[deck_id]["myhand"]
            elif mine_or_other2 == 2:
                deck = self.hands[deck_id]["otherhand"]
            elif mine_or_other2 == 3:
                deck = self.hands[deck_id]["commonhand"]
            i = 0
            for i in range(len(deck)):
                if deck[i]["place_unique_id"] != place_unique_id:
                    continue
                if "eternal" not in deck[i]:
                    deck[i]["eternal"] = []
                change_val_eternal = {}
                change_val_eternal["variables"] = {}
                change_val_eternal["variables"][val_name] = {}
                change_val_eternal["variables"][val_name]["ini"] = 0
                change_val_eternal["variables"][val_name]["value"] = -change_val
                change_val_eternal["monster_variable_change_life"] = "turn_3"
                change_val_eternal["monster_variable_change_life_length"] = 1
                change_val_eternal["effect_kind"] = -1
                deck[i]["eternal"].append(change_val_eternal)
                break
            if mine_or_other2 == 1:
                self.hands[deck_id]["myhand"] = deck
            elif mine_or_other2 == 2:
                self.hands[deck_id]["otherhand"] = deck
            elif mine_or_other2 == 3:
                self.hands[deck_id]["commonhand"] = deck
        return

    def check_monster_exists(
        self,
        monster_effect_det,
        min,
        max,
        user,
        effect_kind,
        cost_flag,
        whether_monster_flag,
        exclude,
    ):
        return_val = []
        duel = self.duel
        place_array = []
        monster_effect_text = monster_effect_det["monster"]
        place_tmp = monster_effect_det["monster"]["place"]
        tmp_place_counter = 0
        for place_key in range(len(place_tmp)):
            place_and_or = place_tmp[place_key]["and_or"]
            place_det = place_tmp[place_key]["det"]
            if place_and_or == "":
                place_and_or = "or"
            place_array.append([])
            place_array[tmp_place_counter].append(place_det)
            if place_and_or == "and":
                place_key += 1
                place_and_or = place_tmp[place_key]["and_or"]
                place_det = place_tmp[place_key]["det"]
                place_array[tmp_place_counter][1] = place_det
                if place_and_or == "and":
                    place_key += 1
                    place_and_or = place_tmp[place_key]["and_or"]
                    place_det = place_tmp[place_key]["det"]
                    place_array[tmp_place_counter][2] = place_det
                    if place_and_or == "and":
                        place_key += 1
                        place_and_or = place_tmp[place_key]["and_or"]
                        place_det = place_tmp[place_key]["det"]
                        place_array[tmp_place_counter][3] = place_det
                        if place_and_or == "and":
                            place_key += 1
                            place_and_or = place_tmp[place_key]["and_or"]
                            place_det = place_tmp[place_key]["det"]
                            place_array[tmp_place_counter][4] = place_det
            tmp_place_counter += 1
        for place_each in place_array:
            place_tmp2 = place_each[0].split("_")
            if place_tmp2[0] == "deck":
                deck = Deck.objects.get(id=place_tmp2[1])
                if deck.mine_or_other == 1:
                    return_val.extend(
                        self.return_deck(
                            duel,
                            deck.id,
                            3,
                            place_tmp2[2],
                            monster_effect_text,
                            effect_kind,
                            cost_flag,
                            exclude,
                        )
                    )
                else:
                    return_val.extend(
                        self.return_deck(
                            duel,
                            deck.id,
                            user,
                            place_tmp2[2],
                            monster_effect_text,
                            effect_kind,
                            cost_flag,
                            exclude,
                        )
                    )
            elif place_tmp2[0] == "grave":
                grave = Grave.objects.get(id=place_tmp2[1])
                if grave.mine_or_other == 1:
                    return_val.extend(
                        self.return_grave(
                            duel,
                            grave.id,
                            3,
                            place_tmp2[2],
                            monster_effect_text,
                            effect_kind,
                            cost_flag,
                            exclude,
                        )
                    )
                else:
                    return_val.extend(
                        self.return_grave(
                            duel,
                            grave.id,
                            user,
                            place_tmp2[2],
                            monster_effect_text,
                            effect_kind,
                            cost_flag,
                            exclude,
                        )
                    )
            elif place_tmp2[0] == "hand":
                hand = Hand.objects.get(id=place_tmp2[1])
                if hand.mine_or_other == 1:
                    return_val.extend(
                        self.return_hand(
                            duel,
                            hand.id,
                            3,
                            place_tmp2[2],
                            monster_effect_text,
                            effect_kind,
                            cost_flag,
                            exclude,
                        )
                    )
                else:
                    return_val.extend(
                        self.return_hand(
                            duel,
                            hand.id,
                            user,
                            place_tmp2[2],
                            monster_effect_text,
                            effect_kind,
                            cost_flag,
                            exclude,
                        )
                    )
            elif place_tmp2[0] == "field":
                kind = ""
                for place_each2 in place_each:
                    place_tmp22 = place_each2.split("_")
                    if kind == "":
                        kind = place_tmp22[1]
                    else:
                        kind += "_" + place_tmp22[1]
                return_val.extend(
                    self.return_field(
                        duel,
                        kind,
                        user,
                        place_tmp2[2],
                        monster_effect_text,
                        effect_kind,
                        cost_flag,
                        whether_monster_flag,
                        exclude,
                    )
                )
        equation_kind = monster_effect_det["equation"]["equation_kind"]
        if len(return_val) == 0:
            return False
        if equation_kind == "number":
            if len(return_val) >= min:
                return True
            else:
                return False
        if equation_kind == "kind":
            variety = self.check_variety(return_val)
            if variety >= min:
                return True
            else:
                return False
        elif equation_kind == "same_name":
            check_same_name = self.check_same_name(return_val)
            if check_same_name >= min:
                return True
            else:
                return False
        else:
            return True
        
    def return_deck(
        self,
        duel,
        deck_id,
        user,
        mine_or_other,
        monster_effect_text,
        effect_kind,
        cost_flag,
        exclude,
    ):
        cost = json.loads(duel.cost)
        mess = json.loads(duel.mess)
        if cost_flag is True:
            if str(duel.chain) in cost:
                cost = cost[str(duel.chain)]
            else:
                cost = []
        else:
            if str(duel.chain - 1) in cost:
                cost = cost[str(duel.chain - 1)]
            else:
                cost = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        if user == self.user:
            mine_or_other2 = int(mine_or_other)
        elif user != self.user:
            if int(mine_or_other) == 1:
                mine_or_other2 = 2
            elif int(mine_or_other) == 2:
                mine_or_other2 = 1
            else:
                mine_or_other2 = int(mine_or_other)
        mine_or_other3 = mine_or_other2
        if user == 2:
            if mine_or_other2 == 1:
                mine_or_other3 = 2
            elif mine_or_other2 == 2:
                mine_or_other3 = 1

        if mine_or_other2 == 1:
            user_decks = self.decks[deck_id]["mydeck"]
        elif mine_or_other2 == 2:
            user_decks = self.decks[deck_id]["otherdeck"]
        elif mine_or_other2 == 3 or mine_or_other2 == 0:
            user_decks = self.decks[deck_id]["commondeck"]
        return_val = []
        for user_deck in user_decks:
            flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:

                    if exclude_det in cost:
                        for cost_det in cost[exclude_det]:
                            if (
                                user_deck["place_unique_id"]
                                == cost_det["place_unique_id"]
                            ):
                                flag = False
                                continue
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if (
                                user_deck["place_unique_id"]
                                == mess_det["place_unique_id"]
                            ):
                                flag = False
                                continue
            tmp2 = {}
            tmp2["det"] = user_deck
            tmp2["mine_or_other"] = mine_or_other3
            tmp2["user"] = user
            tmp2["place"] = "deck"
            tmp2["deck_id"] = deck_id
            tmp2["x"] = 0
            tmp2["y"] = 0
            tmp2["place_unique_id"] = user_deck["place_unique_id"]
            if not self.validate_answer(
                tmp2, monster_effect_text, "", duel, 1, cost_flag, effect_kind, user
            ):
                flag = False
            if flag is True:
                tmp = user_deck
                return_val.append(tmp)
        return return_val

    def return_grave(
        self,
        duel,
        deck_id,
        user,
        mine_or_other,
        monster_effect_text,
        effect_kind,
        cost_flag,
        exclude,
    ):
        cost = json.loads(duel.cost)
        mess = json.loads(duel.mess)
        if cost_flag is True:
            if str(duel.chain) in cost:
                cost = cost[str(duel.chain)]
            else:
                cost = []
        else:
            if str(duel.chain - 1) in cost:
                cost = cost[str(duel.chain - 1)]
            else:
                cost = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        if user == self.user:
            mine_or_other2 = int(mine_or_other)
        elif user != self.user:
            if int(mine_or_other) == 1:
                mine_or_other2 = 2
            elif int(mine_or_other) == 2:
                mine_or_other2 = 1
            else:
                mine_or_other2 = int(mine_or_other)

        mine_or_other3 = mine_or_other2
        if user == 2:
            if mine_or_other2 == 1:
                mine_or_other3 = 2
            elif mine_or_other2 == 2:
                mine_or_other3 = 1
        if mine_or_other2 == 1:
            user_graves = self.graves[deck_id]["mygrave"]
        elif mine_or_other2 == 2:
            user_graves = self.graves[deck_id]["othergrave"]
        elif mine_or_other2 == 3 or mine_or_other2 == 0:
            user_graves = self.graves[deck_id]["commongrave"]
        return_val = []
        for user_grave in user_graves:
            flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:

                    if exclude_det in cost:
                        for cost_det in cost[exclude_det]:
                            if (
                                user_grave["place_unique_id"]
                                == cost_det["place_unique_id"]
                            ):
                                flag = False
                                continue
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if (
                                user_grave["place_unique_id"]
                                == mess_det["place_unique_id"]
                            ):
                                flag = False
                                continue
            tmp2 = {}
            tmp2["det"] = user_grave
            tmp2["mine_or_other"] = mine_or_other3
            tmp2["user"] = user
            tmp2["place"] = "grave"
            tmp2["deck_id"] = deck_id
            tmp2["x"] = 0
            tmp2["y"] = 0
            tmp2["place_unique_id"] = user_grave["place_unique_id"]
            if not self.validate_answer(
                tmp2, monster_effect_text, "", duel, 1, cost_flag, effect_kind, user
            ):
                flag = False
            if flag is True:
                tmp = user_grave
                return_val.append(tmp)
        return return_val

    def return_hand(
        self,
        duel,
        deck_id,
        user,
        mine_or_other,
        monster_effect_text,
        effect_kind,
        cost_flag,
        exclude,
    ):
        cost = self.cost
        mess = json.loads(duel.mess)
        if cost_flag is True:
            if str(duel.chain) in cost:
                cost = cost[str(duel.chain)]
            else:
                cost = []
        else:
            if str(duel.chain - 1) in cost:
                cost = cost[str(duel.chain - 1)]
            else:
                cost = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        if user == self.user:
            mine_or_other2 = int(mine_or_other)
        elif user != self.user:
            if int(mine_or_other) == 1:
                mine_or_other2 = 2
            elif int(mine_or_other) == 2:
                mine_or_other2 = 1
            else:
                mine_or_other2 = int(mine_or_other)
        mine_or_other3 = mine_or_other2
        if user == 2:
            if mine_or_other2 == 1:
                mine_or_other3 = 2
            elif mine_or_other2 == 2:
                mine_or_other3 = 1

        if mine_or_other2 == 1:
            user_hands = self.hands[deck_id]["myhand"]
        elif mine_or_other2 == 2:
            user_hands = self.hands[deck_id]["otherhand"]
        elif mine_or_other2 == 3 or mine_or_other2 == 0:
            user_hands = self.hands[deck_id]["commonhand"]
        return_val = []
        for user_hand in user_hands:
            flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:
                    if exclude_det in cost:
                        for cost_det in cost[exclude_det]:
                            if (
                                user_hand["place_unique_id"]
                                == cost_det["place_unique_id"]
                            ):
                                flag = False
                                continue
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if (
                                user_hand["place_unique_id"]
                                == mess_det["place_unique_id"]
                            ):
                                flag = False
                                continue
            tmp2 = {}
            tmp2["det"] = user_hand
            tmp2["mine_or_other"] = mine_or_other3
            tmp2["user"] = user
            tmp2["place"] = "hand"
            tmp2["deck_id"] = deck_id
            tmp2["x"] = 0
            tmp2["y"] = 0
            tmp2["place_unique_id"] = user_hand["place_unique_id"]
            if not self.validate_answer(
                tmp2, monster_effect_text, "", duel, 1, cost_flag, effect_kind, user
            ):
                flag = False
            if flag is True:
                return_val.append(tmp2)
        return return_val

    def return_field2(
        self,
        duel,
        kind,
        user,
        mine_or_other,
        monster_effect_det,
        effect_kind,
        cost_flag,
        whether_monster_flag=True,
        exclude="",
        num = 0,
        strategy ="",
        strategy_up_or_down = 0,
        min = 0,
        min_flag = False,
         equation_kind = "number"
    ):
        if num == 0:
            return [],0
        cost = self.cost
        mess = self.mess
        effect_kind = duel.ask_kind
        if duel.in_cost is True:
            if str(duel.chain) in cost:
                cost_chain = cost[str(duel.chain)]
            else:
                cost_chain = []
        else:
            if str(duel.chain - 1) in cost:
                cost_chain = cost[str(duel.chain - 1)]
            else:
                cost_chain = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        count = 0
        field = self.field
        return_value = []
        if user == self.user:
            mine_or_other2 = int(mine_or_other)
        elif user != self.user:
            if mine_or_other == 1:
                mine_or_other2 = 2
            elif mine_or_other == 2:
                mine_or_other2 = 1
            else:
                mine_or_other2 = int(mine_or_other)
        mine_or_other3 = mine_or_other2
        if user == 2:
            if mine_or_other2 == 1:
                mine_or_other3 = 2
            elif mine_or_other2 == 2:
                mine_or_other3 = 1
        for x in range(len(field)):
            for y in range(len(field[x])):
                flag_exclude = True
                if exclude != "":
                    excludes = exclude.split(",")
                    for exclude_det in excludes:
    
                        if exclude_det in cost_chain:
                            for cost_det in cost_chain[exclude_det]:
                                if field[x][y]["det"] is not None and field[x][y]["det"]["place_unique_id"] == cost_det["place_unique_id"]:
                                    flag_exclude = False
                                    break 
                        if exclude_det in mess:
                            for mess_det in mess[exclude_det]:
                                if field[x][y]["det"] is not None and field[x][y]["det"]["place_unique_id"] == mess_det["place_unique_id"]:
                                    flag_exclude = False
                                    break
                if flag_exclude is False:
                    flag = False
                    continue
                if field[x][y]["kind"] != kind:
                    flag = False
                    continue
                if int(field[x][y]["mine_or_other"]) != mine_or_other3:
                    flag = False
                    continue
                flag = True
                if field[x][y]["det"] is None and whether_monster_flag :
                    continue
                if field[x][y]["det"] is None and not whether_monster_flag  :
                    tmp2 = {}
                    tmp2["det"] = None
                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                    tmp2["user"] = user
                    tmp2["place"] = "field"
                    tmp2["deck_id"] = 0
                    tmp2["x"] = x
                    tmp2["y"] = y
                    tmp2["strategy_value"] = 0
                    tmp2["place_unique_id"] = None
                    tmp2["variable"] = 1
                elif field[x][y]["det"] is not None and whether_monster_flag  :
                    if strategy != "": 
                        if strategy in field[x][y]["det"]["variables"]:
                            tmp_variable = field[x][y]["det"]["variables"][strategy]
                            if not tmp_variable["value"].isnumeric():
                                tmp_variable["value"] = 0
                        else:
                            tmp_variable = {}
                            tmp_variable["value"] = 0
                        value = self.check_change_val(
                            field[x][y]["det"], user, "field", 0, x, y, strategy, mine_or_other, int(tmp_variable["value"])
                        )
                    else:
                        value = 0
                    if equation_kind == "number":
                        variable = 1
                    else:
                        field[x][y]["det"]["variables"][equation_kind]["value"]
                    tmp2 = {}
                    tmp2["det"] = field[x][y]["det"]
                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                    tmp2["user"] = user
                    tmp2["place"] = "field"
                    tmp2["deck_id"] = 0
                    tmp2["x"] = x
                    tmp2["y"] = y
                    tmp2["strategy_value"] = value
                    tmp2["variable"] = variable
                    tmp2["place_unique_id"] = field[x][y]["det"]["place_unique_id"]
                    if not self.check_monster_condition_det(
                        monster_effect_det, field[x][y]["det"], user, effect_kind, 1, "field", 0, x, y
                    ):
                        flag = False
                else:
                    flag= False

                if flag is True:
                    return_value.append(tmp2)
        return_value = sorted(return_value, key=lambda x: x["strategy_value"], reverse=strategy_up_or_down)
        return_value3 = []
        for return_value2 in return_value:
                del return_value2["strategy_value"]
                return_value3.append(return_value2)
                count += 1
                if count >= min and min_flag is True:
                    return return_value3,count
                if count >= num:
                    return return_value3,count

        return return_value3,count

    def return_field(
        self,
        duel,
        kind,
        user,
        mine_or_other,
        monster_effect_text,
        effect_kind,
        cost_flag,
        whether_monster_flag=True,
        exclude="",
    ):
        field = self.field
        return_val = []
        if user == self.user:
            mine_or_other2 = int(mine_or_other)
        elif user != self.user:
            if mine_or_other == 1:
                mine_or_other2 = 2
            elif mine_or_other == 2:
                mine_or_other2 = 1
            else:
                mine_or_other2 = int(mine_or_other)
        mine_or_other3 = mine_or_other2
        if user == 2:
            if mine_or_other2 == 1:
                mine_or_other3 = 2
            elif mine_or_other2 == 2:
                mine_or_other3 = 1
        for x in range(len(field)):
            for y in range(len(field[x])):
                if field[x][y]["kind"] != kind:
                    flag = False
                    continue
                if int(field[x][y]["mine_or_other"]) != mine_or_other3:
                    flag = False
                    continue
                flag = True
                if field[x][y]["det"] is None and whether_monster_flag == 1:
                    continue
                if field[x][y]["det"] is None and whether_monster_flag == 0:
                    pass
                else:
                    tmp2 = {}
                    tmp2["det"] = field[x][y]["det"]
                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                    tmp2["user"] = user
                    tmp2["place"] = "field"
                    tmp2["deck_id"] = 0
                    tmp2["x"] = x
                    tmp2["y"] = y
                    tmp2["place_unique_id"] = field[x][y]["det"]["place_unique_id"]
                    if not self.validate_answer(
                        tmp2,
                        monster_effect_text,
                        exclude,
                        duel,
                        1,
                        cost_flag,
                        effect_kind,
                        user,
                    ):
                        flag = False

                if flag is True:
                    tmp = field[x][y]["det"]
                    return_val.append(tmp)
        return return_val

    def check_same_name(self, return_val):
        names = {}
        for tmp in return_val:
            if tmp["monster_name"] not in names.keys():
                names[tmp["monster_name"]] = 1
            else:
                names[tmp["monster_name"]] += 1
        return max(names.values())

    def check_variety(self, return_val):
        variety = []
        for tmp in return_val:
            id = self.get_monster_id_easy(tmp)
            if id not in variety:
                variety.append(id)
        return len(variety)
    def check_force(
        self, user, effect_kind, deck_id,ignore_timing
):
        if user == 1:
            other_user = 2
        else:
            other_user = 1
        mine_or_other = other_user
        duel = self.duel
        return_value = []
        if user == self.user:
            hand = self.hands[deck_id]["otherhand"]
        elif user != self.user:
            hand = self.hands[deck_id]["myhand"]
        user_hands = hand
        flag = 0
        i=0
        for user_hand in user_hands:
            id = self.get_monster_id(
                user_hand, "hand", other_user,i, 0, 0, mine_or_other
            )
            monster_det = Monster.objects.get(id=id)
            triggers = monster_det.trigger.all()
            triggers = triggers.filter(trigger_timing=False)
            phase = duel.phase
            turn = duel.user_turn
            place_unique_id = user_hand["place_unique_id"]
            tmp2 = {}
            tmp2["det"] = user_hand
            tmp2["mine_or_other"] = mine_or_other
            tmp2["user"] = user
            tmp2["place"] = "hand"
            tmp2["deck_id"] = deck_id
            tmp2["x"] = 0
            tmp2["y"] = 0
            tmp2["place_unique_id"] = user_hand["place_unique_id"]
            tmp2["able"] = 0
            if user_hand["flag"]== 0:
                for trigger in triggers:
                    if self.check_launch_trigger_ignore_chain_and_timing(
                            trigger,
                            phase,
                            turn,
                            other_user,
                            user,
                            mine_or_other,
                            "hand",
                            place_unique_id,
                            deck_id,
                            ignore_timing
                    ):
                        tmp2["able"] = 1
                        flag = 1
            return_value.append(tmp2)
        if flag == 1:
            return None
        else:
            return return_value
    def get_current_chain_user(self):
        duel = self.duel
        if duel.in_cost is True:
            chain_user = json.loads(duel.chain_user)
            chain_user = chain_user[str(self.tmp_chain)]
        elif duel.chain == 0 or duel.ask > 0:
            chain_user = self.user
        else:
            chain_user = json.loads(duel.chain_user)
            chain_user = chain_user[str(duel.chain - 1)]
        return int(chain_user)
    def sortField(self,field,y):
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is True:
            field_x = 20
        else:
            field_x = field_size.field_x
        j=1    
        for i in range(field_x):
            if field[i][y]["det"] is None:
                j = i + 1
                while j < field_x:
                    if field[j][y]["det"] is not None:
                        field[i][y]["det"] = field[j][y]["det"]
                        field[j][y]["det"] = None
                        break
                    j += 1
                if j >= field_x:
                    break
        return field
    def sortAllField(self,field):
        field_size = FieldSize.objects.get(id=1)
        if self.field_free is True:
            field_x = 20
        else:
            field_x = field_size.field_x
        j=1
        for y in range(field_size.field_y):
            for i in range(field_x):
                if field[i][y]["det"] is None:
                    j = i + 1
                    while j < field_x:
                        if field[j][y]["det"] is not None:
                            field[i][y]["det"] = field[j][y]["det"]
                            field[j][y]["det"] = None
                            break
                        j += 1
                    if j >= field_x:
                        break
        return field
    def check_multiple(
        self, user, effect_kind, monster_effect_text, monster_condition
    ):
        duel = self.duel
        if "whether_monster" in monster_effect_text:
            whether_monster = monster_effect_text["whether_monster"]
        exclude = monster_effect_text["exclude"]
        return_value = []
        tmp0 = []
        tmp1 = []
        return_value.append(tmp0)
        return_value.append(tmp1)
        counter = 0
        for monster_effect_det in monster_effect_text["monster"]:
            counter += 1
            if counter == 2:
                effect_kind = monster_effect_text["multiple_effect_kind"]
            monster_effect_det_monster = monster_effect_det["monster"]
            if (
                    "as_monster_condition" in monster_effect_det
                    and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monsters = monster_effect_det["as_monster_condition"]
                if not isinstance(as_monsters, list):
                    tmp_monster = []
                    tmp_monster.append(as_monsters)
                    as_monsters = tmp_monster
                for as_monster in as_monsters:
                    if as_monster[0] == "~":
                        tmp = self.cost
                        tmp = tmp[str(int(duel.chain))]
                        if as_monster not in tmp:
                            continue
                        place1 = tmp[as_monster]
                    elif as_monster[0] == "%":
                        tmp = self.timing_mess
                        if as_monster not in tmp:
                            continue
                        place1 = tmp[as_monster]
                    else:
                        tmp = self.mess
                        tmp = tmp[str(int(duel.chain - 1))]
                        if as_monster not in tmp:
                            continue
                        place1 = tmp[as_monster]
                    for place2 in place1:
                        if monster_condition != "":
                            if not self.validate_answer(
                                    place2, monster_condition, "", duel
                            ):
                                continue
                        if counter == 1:
                            return_value[0].append(place2)
                        else:
                            return_value[1].append(place2)
            else:
                place_array_tmp = []
                for place in monster_effect_det_monster["place"]:
                    place_tmp = place["det"].split("_")
                    if place["and_or"] != "" and place_tmp[0] == "field":
                        tmptmp = {}
                        tmptmp["and_or"] = place["and_or"]
                        tmptmp["det"] = place["det"]
                        place_array_tmp.append(tmptmp)
                        continue
                    else:
                        tmptmp = {}
                        tmptmp["and_or"] = place["and_or"]
                        tmptmp["det"] = place["det"]
                        place_array_tmp.append(tmptmp)
                        place_array = place_array_tmp
                        place_array_tmp = []
                    if place_tmp[2] == "1":
                        mine_or_other2 = 1
                    elif place_tmp[2] == "2":
                        mine_or_other2 = 2
                    elif place_tmp[2] == "3":
                        mine_or_other2 = 3
                    if user == 1:
                        mine_or_other = mine_or_other2
                    else:
                        if mine_or_other2 == 1:
                            mine_or_other = 2
                        elif mine_or_other2 == 2:
                            mine_or_other = 1
                        else:
                            mine_or_other = mine_or_other2
                    deck_id = int(place_tmp[1])
                    if place_tmp[0] == "deck":
                        if mine_or_other2 == 1:
                            deck = self.decks[deck_id]["mydeck"]
                        elif mine_or_other2 == 2:
                            deck = self.decks[deck_id]["otherdeck"]
                        elif mine_or_other2 == 3:
                            deck = self.decks[deck_id]["commondeck"]
                        user_decks = deck
                        for user_deck in user_decks:
                            tmp2 = {}
                            tmp2["det"] = user_deck
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = user
                            tmp2["place"] = "deck"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_deck["place_unique_id"]
                            if counter == 1:
                                return_value[0].append(tmp2)
                            else:
                                return_value[1].append(tmp2)
                    elif place_tmp[0] == "grave":
                        if mine_or_other2 == 1:
                            grave = self.graves[deck_id]["mygrave"]
                        elif mine_or_other2 == 2:
                            grave = self.graves[deck_id]["othergrave"]
                        elif mine_or_other2 == 3:
                            grave = self.graves[deck_id]["commongrave"]
                        user_graves = grave
                        for user_grave in user_graves:
                            tmp2 = {}
                            tmp2["det"] = user_grave
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = user
                            tmp2["place"] = "grave"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_grave["place_unique_id"]
                            if counter == 1:
                                return_value[0].append(tmp2)
                            else:
                                return_value[1].append(tmp2)
                    elif place_tmp[0] == "hand":
                        if mine_or_other2 == 1:
                            hand = self.hands[deck_id]["myhand"]
                        elif mine_or_other2 == 2:
                            hand = self.hands[deck_id]["otherhand"]
                        elif mine_or_other2 == 3:
                            hand = self.hands[deck_id]["commonhand"]
                        user_hands = hand
                        for user_hand in user_hands:
                            tmp2 = {}
                            tmp2["det"] = user_hand
                            tmp2["mine_or_other"] = mine_or_other
                            tmp2["user"] = user
                            tmp2["place"] = "hand"
                            tmp2["deck_id"] = deck_id
                            tmp2["x"] = 0
                            tmp2["y"] = 0
                            tmp2["place_unique_id"] = user_hand["place_unique_id"]
                            if counter == 1:
                                return_value[0].append(tmp2)
                            else:
                                return_value[1].append(tmp2)
                    elif place_tmp[0] == "field":
                        field_size = FieldSize.objects.get(id=1)
                        field = self.field
                        if self.field_free is True:
                            field_x = 20
                        else:
                            field_x = field_size.field_x
                        for x in range(field_x):
                            for y in range(field_size.field_y):
                                flag_field_place = True
                                current_and_or = "and"
                                mine_or_others = []
                                for place_tmp2 in place_array:
                                    and_or = place_tmp2["and_or"]
                                    det = place_tmp2["det"]
                                    splitted_det = det.split("_")
                                    kind2 = splitted_det[1]
                                    if self.field_free is False:
                                        kind = field[x][y]["kind"]
                                    else:
                                        kind = field[0][y]["kind"]
                                    if kind != "":
                                        tmp = kind.split("_")
                                    else:
                                        tmp = []
                                    if current_and_or == "and":
                                        if kind2 in tmp:
                                            if flag_field_place is True:
                                                flag_field_place = True
                                        else:
                                            flag_field_place = False
                                    elif current_and_or == "or":
                                        if kind2 in tmp:
                                            flag_field_place = True
                                        else:
                                            if flag_field_place is False:
                                                flag_field_place = False
                                    mine_or_other = int(splitted_det[2])
                                    if (
                                            mine_or_other == 1
                                            and user == 1
                                            or mine_or_other == 2
                                            and user == 2
                                    ):
                                        mine_or_other = 1
                                    elif (
                                            mine_or_other == 1
                                            and user == 2
                                            or mine_or_other == 2
                                            and user == 1
                                    ):
                                        mine_or_other = 2
                                    else:
                                        mine_or_other = 3
                                    mine_or_others.append(mine_or_other)

                                if flag_field_place is False:
                                    continue
                                if field[x][y]["mine_or_other"] not in mine_or_others:
                                    continue
                                if field[x][y]["det"] is not None:
                                    if self.check_not_effected(
                                            field[x][y]["det"],
                                            user,
                                            effect_kind,
                                            "field",
                                            0,
                                            x,
                                            y,
                                            field[x][y]["mine_or_other"],
                                    ):
                                        continue
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["user"] = user
                                    tmp2["place"] = "field"
                                    tmp2["deck_id"] = 0
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["place_unique_id"] = field[x][y]["det"][
                                        "place_unique_id"
                                    ]
                                    if not self.validate_answer(
                                            tmp2, monster_effect_det["monster"], exclude, duel
                                    ):
                                        continue
                                if whether_monster == 0:
                                    if field[x][y]["det"] is not None:
                                        continue
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    if self.field_free is True:
                                        tmp2["mine_or_other"] = field[0][y]["mine_or_other"]
                                    elif self.field_free is False:
                                        tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["hide"] = (
                                        field["hide"] if ("hide" in field[x][y]) else False
                                    )
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["deck_id"] = 0
                                    tmp2["user"] = user
                                    tmp2["place"] = "field"
                                    if counter == 1:
                                        return_value[0].append(tmp2)
                                    else:
                                        return_value[1].append(tmp2)
                                else:
                                    if field[x][y]["det"] is None:
                                        continue
                                    tmp2 = {}
                                    tmp2["det"] = field[x][y]["det"]
                                    if self.field_free is True:
                                        tmp2["mine_or_other"] = field[0][y]["mine_or_other"]
                                    elif self.field_free is False:
                                        tmp2["mine_or_other"] = field[x][y]["mine_or_other"]
                                    tmp2["hide"] = (
                                        field["hide"] if ("hide" in field[x][y]) else False
                                    )
                                    tmp2["x"] = x
                                    tmp2["y"] = y
                                    tmp2["deck_id"] = 0
                                    tmp2["user"] = user
                                    tmp2["place"] = "field"
                                    if counter == 1:
                                        return_value[0].append(tmp2)
                                    else:
                                        return_value[1].append(tmp2)
        if return_value[0] == [] or return_value[1] == []:
            return False
        return True
    def check_wait(self,user): 
        duel = self.duel
        if duel.user_turn == 1:
            if user == 1:
                whether_phase = duel.phase_whether_1_1.split("_")
                whether_timing = duel.timing_whether_1_1.split("_")
            else:
                whether_phase = duel.phase_whether_2_1.split("_")
                whether_timing = duel.timing_whether_2_1.split("_")
        else:
            if user == 1:
                whether_phase = duel.phase_whether_1_2.split("_")
                whether_timing = duel.timing_whether_1_2.split("_")
            else:
                whether_phase = duel.phase_whether_2_2.split("_")
                whether_timing = duel.timing_whether_2_2.split("_")
        if self.duel.chain > 0:
            chain_user = json.loads(duel.chain_user)
            effect_user = chain_user[str(duel.chain - 1)]
            if int(effect_user) == 1:
                if user == 1:
                    whether_kind = duel.kind_whether_1_1.split("_")
                else:
                    whether_kind = duel.kind_whether_2_2.split("_")
            else:
                if user == 1:
                    whether_kind = duel.kind_whether_1_2.split("_")
                else:
                    whether_kind = duel.kind_whether_2_1.split("_")
        if duel.chain == 0:
            phase = duel.phase
            timing = duel.timing
            timing2 = duel.timing2
            timing3 = duel.timing3
            if timing is None and timing2 is None and timing3 is None and str(phase.id) not in whether_phase and self.duel.user_turn != user:
                return False
            if timing is not None:
                if str(timing.id) not in whether_timing:
                    return False
            if timing2 is not None:
                if str(timing2.id) not in whether_timing:
                    return False
            if timing3 is not None:
                if str(timing3.id) not in whether_timing:
                    return False
        if self.duel.chain > 0:
            chain_det_ary = json.loads(self.duel.chain_det_trigger)
            chain_det = chain_det_ary[str(self.duel.chain - 1)]
            if str(chain_det) not in self.triggers:
                trigger_before = Trigger.objects.get(id=chain_det)
                self.triggers[str(chain_det)] = trigger_before
            else:
                trigger_before = self.triggers[str(chain_det)]
            chain_kind = trigger_before.trigger_kind
            if chain_kind == "":
                return True
            chain_kinds = chain_kind.split("_")
            for whether_kind_det in whether_kind:
                if whether_kind_det in chain_kinds:
                    return False

        return True

    def answer_ai_fusion_material(self,monster_effect_wrapper,strategy,strategy_up_or_down):
        duel = self.duel
        mess = self.mess 
        chain_user = json.loads(duel.chain_user)
        effect_user = chain_user[str(duel.chain - 1)]
        if str(duel.chain - 1) not in mess:
            mess[str(duel.chain - 1)] = {}
                
        if "fusion" not in mess[str(duel.chain - 1)]:
            return False
        place1 = mess[str(duel.chain - 1)]["fusion"]
        place = place1[0]
        fusion_id = place["fusion"]
        as_monster_effect = "material1"
        if not as_monster_effect in mess[str(duel.chain - 1)]:
            mess[str(duel.chain-1)][as_monster_effect] = []
        chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
        trigger_id = chain_det_trigger_json[str(duel.chain - 1)]
        trigger = Trigger.objects.get(id=trigger_id)
        min_equation_number1 = 0
        min_equation_number2 = 0
        min_equation_number3 = 0
        trigger_fusion1 = json.loads(trigger.fusion1)
        min_equation_number1 = trigger_fusion1["monster"][0]["min_equation_number"]
        if trigger.instead_condition:
            instead_condition = json.loads(trigger.instead_condition)
            if self.check_monster_effect_condition(
                    instead_condition, 0, 2):
                instead = True
            else:
                instead = False
        else:
            instead = True
        if(trigger.instead1 and instead is True):
            instead1 = json.loads(trigger.instead1)
            min_equation_number1_instead = instead2["monster"][0]["min_equation_number"]
            max_equation_number1_instead = instead2["monster"][0]["max_equation_number"]
        else:
            instead1 = None
            min_equation_number1_instead = 0
            max_equation_number1_instead = 1000
        if(trigger.instead2 and instead is True):
            instead2 = json.loads(trigger.instead2)
            min_equation_number2_instead = instead2["monster"][0]["min_equation_number"]
            max_equation_number2_instead = instead2["monster"][0]["max_equation_number"]
        else:
            instead2 = None
            min_equation_number2_instead = 0
            max_equation_number2_instead = 1000
        if(trigger.instead3 and instead is True):
            instead3 = json.loads(trigger.instead3)
            min_equation_number3_instead = instead3["monster"][0]["min_equation_number"]
            max_equation_number3_instead = instead3["monster"][0]["max_equation_number"]
        else:
            instead3 = None
            min_equation_number3_instead = 0
            max_equation_number3_instead = 1000
        if(trigger.fusion2):
            trigger_fusion2 = json.loads(trigger.fusion2)
            min_equation_number2 = trigger_fusion2["monster"][0]["min_equation_number"]

        else:
            trigger_fusion2 = None
        if(trigger.fusion3):
            trigger_fusion3 = json.loads(trigger.fusion3)
            min_equation_number3_instead = instead3["monster"][0]["min_equation_number"]
            max_equation_number3_instead = instead3["monster"][0]["max_equation_number"]

        else:
            trigger_fusion3 = None
        monster_id = self.get_monster_id(
            place["det"], place["place"], place["det"]["owner"],place["deck_id"],place["x"], place["y"], place["mine_or_other"])
        fusion = Fusion.objects.filter(id=fusion_id["id"]).get()
        if fusion is None:
            return False
        fusion1 = json.loads(fusion.fusion1)

        min_equation_number1 = max(min_equation_number1,fusion1["monster"][0]["min_equation_number"])
        if(fusion.fusion2):
            fusion2 = json.loads(fusion.fusion2)

            min_equation_number2 = max(min_equation_number2,fusion2["monster"][0]["min_equation_number"])
        else:
            fusion2 = None
        if(fusion.fusion3):
            fusion3 = json.loads(fusion.fusion3)

            min_equation_number3 = max(min_equation_number3,fusion3["monster"][0]["min_equation_number"])
        else:
            fusion3 = None
        tmp_ary = self.get_fusion_material(trigger.fusion_monster, effect_user, trigger,1,1)
        ary = []
        ary.append(tmp_ary[0]["monster"])
        ary.append(tmp_ary[1]["monster"])
        ary.append(tmp_ary[2]["monster"])
        result = []
        tmp = {}
        tmp["min"] = tmp_ary[0]["min"]
        tmp["max"] = tmp_ary[0]["max"]
        tmp["monster"] = (sorted(ary[0], key=lambda x:(x["instead"], x["strategy_value"]), reverse=strategy_up_or_down))
        result.append(tmp)
        tmp = {}
        tmp["min"] = tmp_ary[1]["min"]
        tmp["max"] = tmp_ary[1]["max"]
        tmp["monster"] = (sorted(ary[1], key=lambda x:(x["instead"], x["strategy_value"]), reverse=strategy_up_or_down))
        result.append(tmp)
        tmp = {}
        tmp["min"] = tmp_ary[2]["min"]
        tmp["max"] = tmp_ary[2]["max"]
        tmp["monster"] = (sorted(ary[2], key=lambda x: (x["instead"],x["strategy_value"]), reverse=strategy_up_or_down))
        result.append(tmp)
        flag = False
        ary = self.fusion_cross_check(result[0],result[1],result[2],min_equation_number1,min_equation_number2,min_equation_number3,1,min_equation_number1_instead,min_equation_number2_instead,min_equation_number3_instead,max_equation_number1_instead,max_equation_number2_instead,max_equation_number3_instead)
        if(ary[0]):
            as_monster_effect = "material1"
            if not as_monster_effect in mess[str(duel.chain - 1)]:
                mess[str(duel.chain-1)][as_monster_effect] = []
            mess[str(duel.chain - 1)][
            "material1"
            ].extend(ary[0])
        if(ary[1]):
            as_monster_effect = "material2"
            if not as_monster_effect in mess[str(duel.chain - 1)]:
                mess[str(duel.chain-1)][as_monster_effect] = []
            mess[str(duel.chain - 1)][
            "material2"
            ].extend(ary[1])
        if(ary[2]):
            as_monster_effect = "material3"
            if not as_monster_effect in mess[str(duel.chain - 1)]:
                mess[str(duel.chain-1)][as_monster_effect] = []
            mess[str(duel.chain - 1)][
            "material3"
            ].extend(ary[2])
        self.mess = mess
        duel.ask = 0
        return True
    def answer_ai_fusion(self,monster_effect_wrapper,strategy,strategy_up_or_down):
        duel = self.duel
        mess = self.mess 
        user = 2
        as_monster_effect = "fusion"
        if not as_monster_effect in mess[str(duel.chain - 1)]:
            mess[str(duel.chain-1)][as_monster_effect] = []
        chain_det_trigger_json = json.loads(self.duel.chain_det_trigger)
        trigger_id = chain_det_trigger_json[str(duel.chain - 1)]
        trigger = Trigger.objects.get(id=trigger_id)
        monsters = self.get_fusion_monster(trigger.fusion_monster, user, trigger,0,1)
        result = sorted(monsters, key=lambda x: x["strategy_value"], reverse=strategy_up_or_down)
        mess[str(duel.chain - 1)][
            as_monster_effect
        ].append(result[0])
        self.mess = mess
        duel.ask = 0
        return True

    def answer_ai(self,strategy="",strategy_up_or_down=0):
        # 大きいと小さい反対になっている
        if strategy_up_or_down ==0:
            strategy_up_or_down = 1
        else:
            strategy_up_or_down = 0
        field = self.field
        cost_det2 = self.duel.cost_det
        user = 2
        duel = self.duel
        ask_fields = []
        field_size = FieldSize.objects.get(id=1)
        current_and_or = "and"
        other_user_flag = False
        result = []
        if duel.in_copying is True:
            self.tmp_chain = str(duel.chain - 1)
        else:
            self.tmp_chain = str(duel.chain)
        if int(self.tmp_chain) > 0:
            self.duel.retrieve = 1
        cost = self.cost
        mess = self.mess
        if duel.in_cost is True:
            if str(duel.chain) in cost:
                cost_chain = cost[str(duel.chain)]
            else:
                cost_chain = []
        else:
            if str(duel.chain - 1) in cost:
                cost_chain = cost[str(duel.chain - 1)]
            else:
                cost_chain = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        counter = 0
        effect_kind = duel.ask_kind
        if duel.in_cost is True:
            cost_det = duel.cost_det
            effect_user = duel.cost_user
            cost = CostWrapper.objects.get(id=int(cost_det))
            cost_det = cost.cost
            if cost_det.cost != "":
                monster_effect_text_org = json.loads(cost_det.cost)
            if (
                    cost_det.cost_val == 3
                    or cost_det.cost_val == 44
            ):
                if duel.user_turn == effect_user:
                    ask_org = 1
                else:
                    ask_org = 2
            elif cost_det.cost_val == 4:
                other_user_flag = True
                if duel.user_turn == effect_user:
                    ask_org = 2
                else:
                    ask_org = 1
            elif cost_det.cost_val == 5:
                if self.user != effect_user:
                    other_user_flag = True
                ask_org = 3
            else:
                ask_org = 0
            if cost_det.cost_val == 28 or cost_det.cost_val == 64:
                chain_variable_det = json.loads(duel.chain_variable)
                chain_variable_name = monster_effect_text_org["chain_variable"]
                chain_variable = self.calculate_boland(
                    monster_effect_text_org["max_equation_number"],None,True
                )
                if self.tmp_chain not in chain_variable_det:
                    chain_variable_det[self.tmp_chain] = {}
                chain_variable_det[self.tmp_chain][chain_variable_name] = chain_variable
                duel.chain_variable = json.dumps(chain_variable_det)
                return
            elif cost_det.cost_val == 26:
                chain_variable_det = json.loads(duel.chain_variable)
                chain_variable_name = monster_effect_text_org["chain_variable"]
                chain_variable = self.calculate_boland(
                    monster_effect_text_org["max_equation_number"],None,True
                )
                if self.tmp_chain not in chain_variable_det:
                    chain_variable_det[self.tmp_chain] = {}
                chain_variable_det[self.tmp_chain][chain_variable_name] = chain_variable
                duel.chain_variable = json.dumps(chain_variable_det)
                return
            elif cost_det.cost_val == 27 or cost_det.cost_val == 63:
                chain_variable_det = json.loads(duel.chain_variable)
                chain_variable_name = monster_effect_text_org["chain_variable"]
                chain_variable = self.calculate_boland(
                    monster_effect_text_org["max_equation_number"],None,True
                )
                if self.tmp_chain not in chain_variable_det:
                    chain_variable_det[self.tmp_chain] = {}
                chain_variable_det[self.tmp_chain][chain_variable_name] = chain_variable
                duel.chain_variable = json.dumps(chain_variable_det)
                return
            elif cost_det.cost_val == 16:
                effect = CostWrapper.objects.get(id=cost_det2)
                if effect.pac:
                    next_effect = self._pac(effect.pac)
                else:
                    next_effect = effect.monster_effect_next
                duel.cost_det = next_effect.id
                return
            elif cost_det.cost_val == 48:
                next_effect = self.copy_special_effect(cost_det.cost,cost_det.cost.cost_kind,True)
                duel.cost_det = next_effect.id
                return
            elif cost_det.cost_val == 26:
                effect = CostWrapper.objects.get(id=cost_det2)
                if effect.pac:
                    next_effect = self._pac(effect.pac)
                else:
                    next_effect = effect.monster_effect_next
                duel.cost_det = next_effect.id
                return
        elif duel.in_trigger_waiting is True and duel.force == 0:
            duel.force = 2

            return 
        else:
            chain_det = json.loads(duel.chain_det)
            chain_user = json.loads(duel.chain_user)
            effect_user = chain_user[str(duel.chain - 1)]
            monster_effect = MonsterEffectWrapper.objects.get(
                id=int(chain_det[str(duel.chain - 1)])
            )
            monster_effect_det2 = monster_effect.monster_effect
            monster_condition = monster_effect_det2.monster_condition
            if monster_condition != "":
                monster_condition = json.loads(monster_condition)
                monster_condition = monster_condition["monster"][0]["monster"]
            if monster_effect_det2.monster_effect_val == 54 or monster_effect_det2.monster_effect_val == 55:
                return_value = {}
                acc_global = self.acc_global
                order = range(0,len(acc_global))
                dummy_list = []
                for tmp in order:
                    dummy_list.append(acc_global[int(tmp)])
                self.acc_global = dummy_list
                return 
            elif monster_effect_det2.monster_effect_val == 16 or monster_effect_det2.monster_effect_val == 26 or monster_effect_det2.monster_effect_val == 16 or monster_effect_det2.monster_effect_val == 67 :
                return
            if monster_effect_det2.monster_effect:
                monster_effect_text_org = json.loads(monster_effect_det2.monster_effect)
            else:
                monster_effect_text_org  = []
            if monster_effect_det2.monster_effect_val == 28 or monster_effect_det2.monster_effect_val == 27 or monster_effect_det2.monster_effect_val == 64 or monster_effect_det2.monster_effect_val == 63:
                chain_variable_det = json.loads(duel.chain_variable)
                chain_variable_name = monster_effect_text_org["chain_variable"]
                chain_variable = self.calculate_boland(
                    monster_effect_text_org["max_equation_number"],None,True
                )
                if self.tmp_chain not in chain_variable_det:
                    chain_variable_det[self.tmp_chain] = {}
                chain_variable_det[self.tmp_chain][chain_variable_name] = chain_variable
                duel.chain_variable = json.dumps(chain_variable_det)
                return
            if monster_effect_det2.monster_effect_val == 57:
                return self.show_as(
                    self,
                    user,
                    effect_kind,
                    monster_effect_text_org,
                    monster_condition,
                )
            elif monster_effect_det2.monster_effect_val == 65:
                return self.show_as_under(
                    self,
                    user,
                    effect_kind,
                    monster_effect_text_org,
                    monster_condition,
                )
            elif monster_effect_det2.monster_effect_val == 59:
                return self.show_force(
                    user,
                    effect_kind,
                    monster_effect_det2.monster_effect,
                )
            if (
                    monster_effect_det2.monster_effect_val == 3
                    or monster_effect_det2.monster_effect_val == 44
            ):
                if duel.user_turn == effect_user:
                    ask_org = 1
                else:
                    ask_org = 2
            elif monster_effect_det2.monster_effect_val == 4:
                other_user_flag = True
                if duel.user_turn == effect_user:
                    ask_org = 2
                else:
                    ask_org = 1
            elif monster_effect_det2.monster_effect_val == 76:
                return self.answer_ai_fusion(monster_effect,strategy,strategy_up_or_down)
            elif monster_effect_det2.monster_effect_val == 77:
                return self.answer_ai_fusion_material(monster_effect,strategy,strategy_up_or_down)
            elif monster_effect_det2.monster_effect_val == 5:
                if self.user != effect_user:
                    other_user_flag = True
                ask_org = 3
            else:
                ask_org = 0
        tmp_val = {}
        return_val = []
        if "whether_monster" in monster_effect_text_org:
            whether_monster = monster_effect_text_org["whether_monster"]
        else:
            whether_monster = 0
        monster_effect_text = monster_effect_text_org["monster"]
        exclude = monster_effect_text_org["exclude"]
        for monster_effect_det in monster_effect_text:
           min = self.calculate_boland(
               monster_effect_det["min_equation_number"]
           )
           max = self.calculate_boland(
               monster_effect_det["max_equation_number"]
           )
           equation_kind = monster_effect_det["equation"]["equation_kind"]
           if "min_flag" in monster_effect_det :
               min_flag = monster_effect_det["min_flag"]
           else:
               min_flag = False
           monster_effect_det_monster = monster_effect_det["monster"]
           counter += 1

           if duel.user_turn == user:
               if (counter == 1 and ask_org == 3) or ask_org == 1:
                   place_array = []
                   place_tmp = monster_effect_det_monster["place"]
                   tmp_place_counter = 0
                   for place_key in range(len(place_tmp)):
                       place_and_or = place_tmp[place_key]["and_or"]
                       place_det = place_tmp[place_key]["det"]
                       if place_and_or == "":
                           place_and_or = "or"
                       place_array.append([])
                       place_array[tmp_place_counter].append(place_det)
                       if place_and_or == "and":
                           place_key += 1
                           place_and_or = place_tmp[place_key]["and_or"]
                           place_det = place_tmp[place_key]["det"]
                           place_array[tmp_place_counter][1] = place_det
                           if place_and_or == "and":
                               place_key += 1
                               place_and_or = place_tmp[place_key]["and_or"]
                               place_det = place_tmp[place_key]["det"]
                               place_array[tmp_place_counter][2] = place_det
                               if place_and_or == "and":
                                   place_key += 1
                                   place_and_or = place_tmp[place_key]["and_or"]
                                   place_det = place_tmp[place_key]["det"]
                                   place_array[tmp_place_counter][3] = place_det
                                   if place_and_or == "and":
                                       place_key += 1
                                       place_and_or = place_tmp[place_key]["and_or"]
                                       place_det = place_tmp[place_key]["det"]
                                       place_array[tmp_place_counter][4] = place_det
                       tmp_place_counter += 1
                   for place_each in place_array:
                       place_tmp = place_each[0].split("_")
                       if place_tmp[0] == "deck":
                           deck = Deck.objects.get(id=place_tmp[1])
                           if deck.mine_or_other == 1:
                              tmp,count = (
                              self.return_deck2(
                                  duel,
                                  deck.id,
                                  3,
                                  place_tmp[2],
                                  deck.deck_name,
                                  exclude,
                                  monster_effect_det,
                                  max,
                                   strategy,
                                   strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                              )
                              )
                              min -= count
                              max -= count
                           else:
                              tmp,count =(
                                  self.return_deck2(
                                      duel,
                                      deck.id,
                                      user,
                                      place_tmp[2],
                                      deck.deck_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                   strategy,
                                   strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              max -= count
                       elif place_tmp[0] == "grave":
                           grave = Grave.objects.get(id=place_tmp[1])
                           if grave.mine_or_other == 1:
                               tmp,count = self.return_grave2(
                                   duel,
                                   grave.id,
                                   3,
                                   place_tmp[2],
                                   grave.grave_name,
                                   exclude,
                                   monster_effect_det,
                                   max,
                                   strategy,
                                   strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                               )
                               result.extend(tmp)
                               min -= count
                               max -= count
                           else:
                              tmp,count = (
                                  self.return_grave2(
                                      duel,
                                      grave.id,
                                      user,
                                      place_tmp[2],
                                      grave.grave_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                   strategy,
                                   strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              max -= count
                       elif place_tmp[0] == "hand":
                           hand = Hand.objects.get(id=place_tmp[1])
                           if hand.mine_or_other == 1:
                                   tmp,count = (
                                       self.return_hand2(
                                           duel,
                                           hand.id,
                                           3,
                                           place_tmp[2],
                                           hand.hand_name,
                                           exclude,
                                           monster_effect_det,
                                           max,
                                           strategy,
                                           strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                       )
                                   )
                                   result.extend(tmp)
                                   min -= count
                                   max -= count
                           else:
                              tmp,count = (
                                  self.return_hand2(
                                      duel,
                                      hand.id,
                                      user,
                                      place_tmp[2],
                                      hand.hand_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                      strategy,
                                      strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              max-=count
                       elif place_tmp[0] == "field":
                           tmp,count = self.return_field2(
                   duel,
                   place_tmp[1] ,
                   user,
                   place_tmp[2],
                   monster_effect_det,
                   effect_kind,
                   0,
                   whether_monster,
                   exclude,
                   max,
                   strategy,
                   strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
               )
                           result.extend(tmp)
                           min -= count
                           max-=count
           else:
               if (counter == 2 and ask_org == 3) or ask_org == 2:
                   place_array = []
                   place_tmp = monster_effect_det_monster["place"]
                   tmp_place_counter = 0
                   for place_key in range(len(place_tmp)):
                       place_and_or = place_tmp[place_key]["and_or"]
                       place_det = place_tmp[place_key]["det"]
                       if place_and_or == "":
                           place_and_or = "or"
                       place_array.append([])
                       place_array[tmp_place_counter].append(place_det)
                       if place_and_or == "and":
                           place_key += 1
                           place_and_or = place_tmp[place_key]["and_or"]
                           place_det = place_tmp[place_key]["det"]
                           place_array[tmp_place_counter][1] = place_det
                           if place_and_or == "and":
                               place_key += 1
                               place_and_or = place_tmp[place_key]["and_or"]
                               place_det = place_tmp[place_key]["det"]
                               place_array[tmp_place_counter][2] = place_det
                               if place_and_or == "and":
                                   place_key += 1
                                   place_and_or = place_tmp[place_key]["and_or"]
                                   place_det = place_tmp[place_key]["det"]
                                   place_array[tmp_place_counter][3] = place_det
                                   if place_and_or == "and":
                                       place_key += 1
                                       place_and_or = place_tmp[place_key]["and_or"]
                                       place_det = place_tmp[place_key]["det"]
                                       place_array[tmp_place_counter][4] = place_det
                       tmp_place_counter += 1
                   for place_each in place_array:
                       place_tmp = place_each[0].split("_")
                       if place_tmp[0] == "deck":
                           deck = Deck.objects.get(id=place_tmp[1])
                           if deck.mine_or_other == 1:
                               tmp,count = (
                                   self.return_deck2(
                                       duel,
                                       deck.id,
                                       3,
                                       place_tmp[2],
                                       deck.deck_name,
                                       exclude,
                                       monster_effect_det,
                                       max,
                                           strategy,
                                           strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                   )
                               )
                               result.extend(tmp)
                           else:
                              tmp,count = (
                                  self.return_deck2(
                                      duel,
                                      deck.id,
                                      user,
                                      place_tmp[2],
                                      deck.deck_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                           strategy,
                                           strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              max -= count
                       elif place_tmp[0] == "grave":
                           grave = Grave.objects.get(id=place_tmp[1])
                           if grave.mine_or_other == 1:
                                  
                              tmp,count = (
                                  self.return_grave2(
                                      duel,
                                      grave.id,
                                      3,
                                      place_tmp[2],
                                      grave.grave_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                           strategy,
                                           strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              
                              max -= count
                           else:
                                tmp,count = (
                                    self.return_grave2(
                                        duel,
                                        grave.id,
                                        user,
                                        place_tmp[2],
                                        grave.grave_name,
                                        exclude,
                                        monster_effect_det,
                                        max,
                                           strategy,
                                           strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                    )
                                )
                                result.extend(tmp)
                                min -= count
                                max -=count
                       elif place_tmp[0] == "hand":
                           hand = Hand.objects.get(id=place_tmp[1])
                           if hand.mine_or_other == 1:
                              tmp,count = (
                                  self.return_hand2(
                                      duel,
                                      hand.id,
                                      3,
                                      place_tmp[2],
                                      hand.hand_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                           strategy,
                                           strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              max -= count
                           else:
                              tmp,count = (
                                  self.return_hand2(
                                      duel,
                                      hand.id,
                                      user,
                                      place_tmp[2],
                                      hand.hand_name,
                                      exclude,
                                      monster_effect_det,
                                      max,
                                           strategy,
                                           strategy_up_or_down,
                                        min,
                                        min_flag,
                   equation_kind
                                  )
                              )
                              result.extend(tmp)
                              min -= count
                              max -=count
                       elif place_tmp[0] == "field":
                           tmp,count = self.return_field2(
                   duel,
                   place_tmp[1] ,
                   user,
                   place_tmp[2],
                   monster_effect_det,
                   effect_kind,
                   0,
                   whether_monster,
                   exclude,
                   max,
                   strategy,
                   strategy_up_or_down,
                   min,
                   min_flag,
                   equation_kind
               )
                           result.extend(tmp)
                           min -= count
                           max -=count
        as_monster_effect = monster_effect_det["as_monster_condition"]
        if as_monster_effect[0] == "%":
            timing_mess = self.timing_mess
            if as_monster_effect not in timing_mess:
                timing_mess[as_monster_effect] = []
            for tmp2 in result:
                timing_mess[
                    as_monster_effect
                ].append(tmp2)
            self.timing_mess = timing_mess
        elif as_monster_effect[0] == "~":
            if as_monster_effect not in cost_chain :
                cost_chain[as_monster_effect] = []
            for tmp2 in result:
                cost_chain[
                    as_monster_effect
                ].append(tmp2)
            if duel.in_cost is True:
                self.cost[str(duel.chain)] =cost_chain
            else:
                self.cost[str(duel.chain-1)] =cost_chain
        else:
            if as_monster_effect not in mess:
                mess[as_monster_effect] = []
            for tmp2 in result:
                mess[
                as_monster_effect
                ].append(tmp2)
            self.mess[str(duel.chain-1)] = mess
    def show_as(
            self, user, effect_kind, monster_effect_text, monster_condition, sentence, prompt
    ):
        ask_fields = []
        duel = self.duel
        field = self.field
        as_monster_to = monster_effect_text["as_monster_condition_to"]
        mess = self.mess
        if as_monster_to not in mess[str(int(duel.chain - 1))]:
            mess[str(int(duel.chain - 1))][as_monster_to] = []
        for monster_effect_det in monster_effect_text["monster"]:
            max = self.calculate_boland(
                monster_effect_det["max_equation_number"]
            )
            tmp = 0
            if (
                    "as_monster_condition" in monster_effect_det
                    and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monsters = monster_effect_det["as_monster_condition"]
                if not isinstance(as_monsters, list):
                    tmp_monster = []
                    tmp_monster.append(as_monsters)
                    as_monsters = tmp_monster
                for as_monster in as_monsters:
                    if self.check_monster_condition_det(
                            monster_effect_det,
                            as_monster["det"],
                            user,
                            effect_kind,
                            1,
                            "field",
                            0,
                            x,
                            y,
                            field[x][y]["mine_or_other"]
                    ):
                        mess[str(int(duel.chain - 1))][as_monster_to].append(as_monster)
                        tmp += 1
                        if tmp >= max:
                            break
        self.mess = mess
        return

    def show_as_under(
            self, user, effect_kind, monster_effect_text, monster_condition, sentence, prompt
    ):
        ask_fields = []
        duel = self.duel
        field = self.field
        as_monster_to = monster_effect_text["as_monster_condition_to"]
        mess = self.mess
        if as_monster_to not in mess[str(int(duel.chain - 1))]:
            mess[str(int(duel.chain - 1))][as_monster_to] = []
        for monster_effect_det in monster_effect_text["monster"]:
            max = self.calculate_boland(
                monster_effect_det["max_equation_number"]
            )
            tmp = 0
            if (
                    "as_monster_condition" in monster_effect_det
                    and monster_effect_det["as_monster_condition"] != ""
            ):
                as_monsters = monster_effect_["as_monster_condition"]
                if not isinstance(as_monsters, list):
                    tmp_monster = []
                    tmp_monster.append(as_monsters)
                    as_monsters = tmp_monster
                for as_monster in as_monsters:
                    x = as_monster["x"]
                    y = as_monster["y"]
                    if self.check_monster_condition_det(
                            monster_effect_det,
                            as_monster["det"],
                            user,
                            effect_kind,
                            1,
                            "field",
                            0,
                            x,
                            y,
                    ):
                        if "under" not in field[x][y]["det"]:
                            continue
                        for under in field[x][y]["det"]["under"]:
                            tmp2 = {}
                            tmp2["det"] = under
                            tmp2["x"] = x
                            tmp2["y"] = y
                            tmp2["deck_id"] = 0
                            tmp2["user"] = user
                            tmp2["place"] = "under"
                            tmp2["mine_or_other"] = field["mine_or_other"]
                            mess[str(int(duel.chain - 1))][as_monster_to].append(as_monster)
                            tmp += 1
                            if tmp >= max:
                                break
        self.mess = mess
        return
    def show_force(
            self, user, effect_kind, monster_effect
    ):
        det = json.loads(monster_effect)
        deck_id = det["deck_id"]
        ignore_timing = det["ignore_timing"]
        if user == 1:
            other_user = 2
        else:
            other_user = 1
        mine_or_other = other_user
        duel = self.duel
        hand = self.hands[deck_id]["otherhand"]
        user_hands = hand
        i=0
        for user_hand in user_hands:
            id = self.get_monster_id(
                user_hand, "hand", other_user,i, 0, 0, mine_or_other
            )
            monster_det = Monster.objects.get(id=id)
            triggers = monster_det.trigger.all()
            triggers = triggers.filter(trigger_timing=False)
            phase = duel.phase
            turn = duel.user_turn
            place_unique_id = user_hand["place_unique_id"]
            tmp2 = {}
            tmp2["det"] = user_hand
            tmp2["mine_or_other"] = mine_or_other
            tmp2["user"] = user
            tmp2["place"] = "hand"
            tmp2["deck_id"] = deck_id
            tmp2["x"] = 0
            tmp2["y"] = 0
            tmp2["place_unique_id"] = user_hand["place_unique_id"]
            for trigger in triggers:
                if self.check_launch_trigger_ignore_chain_and_timing(
                        trigger,
                        phase,
                        turn,
                        other_user,
                        user,
                        mine_or_other,
                        "hand",
                        place_unique_id,
                        deck_id,
                        ignore_timing
                ):
                    self.invoke_force_trigger(
                        trigger,
                        "hand",
                        user_hand,
                        mine_or_other,
                        other_user,
                        deck_id,
                        0,
                        0,
                        None,
                        None,
                        None,
                        None,
                        None,
                    )
                    return
    def return_deck2(
            self,
            duel,
            deck_id,
            user,
            mine_or_other,
            deck_name,
            exclude="",
            monster_effect_det=None,
            num=0,
            strategy = "",
            strategy_up_or_down = 0,
            min = 0,
            min_flag = False,
            equation_kind = "number"
    ):
        if num == 0:
            return [],0
        mine_or_other = int(mine_or_other)
        count = 0
        cost = self.cost
        mess = self.mess
        effect_kind = duel.ask_kind
        if duel.in_cost is True:
            if str(duel.chain) in cost:
                cost_chain = cost[str(duel.chain)]
            else:
                cost_chain = []
        else:
            if str(duel.chain - 1) in cost:
                cost_chain = cost[str(duel.chain - 1)]
            else:
                cost_chain = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        if user == 1:
            pass
        elif user == 2:
            if mine_or_other == 1:
                mine_or_other = 2
            elif mine_or_other == 2:
                mine_or_other = 1
        if mine_or_other == 1:
            tmp = self.decks[deck_id]["mydeck"]
        elif mine_or_other == 2:
            tmp = self.decks[deck_id]["otherdeck"]
        elif mine_or_other == 3 or mine_or_other == 0:
            tmp = self.decks[deck_id]["commondeck"]
        user_decks = tmp
        return_value = []
        for user_deck in user_decks:
            flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:
    
                    if exclude_det in cost_chain:
                        for cost_det in cost_chain[exclude_det]:
                            if user_deck["place_unique_id"] == cost_det["place_unique_id"]:
                                flag = False
                                break
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if user_deck["place_unique_id"] == mess_det["place_unique_id"]:
                                flag = False
                                break
            if not self.check_monster_condition_det(
                    monster_effect_det, user_deck, user, effect_kind, 1, "deck", deck_id, 0, 0
            ):
                flag = False
            if flag is True:
                if strategy != "": 
                    if strategy in user_deck["variables"]:
                        tmp_variable = user_deck["variables"][strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        user_deck, user, "deck", deck_id, 0, 0, strategy, mine_or_other, int(tmp_variable["value"])
                    )
                else:
                    value = 0
                if equation_kind != "number" :
                    variable = user_deck["variables"][equation_kind][
                                    "value"
                                ]
                else:
                    variable = 1
                pprint(variable)
                tmp2 = {}
                tmp2["det"] = user_deck
                tmp2["mine_or_other"] = mine_or_other
                tmp2["user"] = user
                tmp2["place"] = "deck"
                tmp2["deck_id"] = deck_id
                tmp2["x"] = 0
                tmp2["y"] = 0
                tmp2["place_unique_id"] = user_deck["place_unique_id"]
                tmp2["strategy_value"] = value
                tmp2["variable"] = variable
                return_value.append(tmp2)
        return_value = sorted(return_value, key=lambda x: x["strategy_value"], reverse=strategy_up_or_down)
        return_value3 = []
        for return_value2 in return_value:
                del return_value2["strategy_value"]
                count += int(return_value2["variable"])
                del return_value2["variable"]
                return_value3.append(return_value2)
                if count >= min and min_flag is True:
                    return return_value3,count
                if count >= num:
                    return return_value3,count

        return return_value3,count
    def return_grave2(
            self,
            duel,
            deck_id,
            user,
            mine_or_other,
            deck_name,
            exclude="",
            monster_effect_det=None,
            num=0,
            strategy = None,
            strategy_up_or_down = 0,
            min = 0,
            min_flag = False,
            equation_kind = "number"
    ):
        if num == 0:
            return [],0;
        mine_or_other = int(mine_or_other)
        count = 0
        cost = self.cost
        mess = self.mess
        effect_kind = duel.ask_kind
        if duel.in_cost is True:
            if str(duel.chain) in cost:
                cost_chain = cost[str(duel.chain)]
            else:
                cost_chain = []
        else:
            if str(duel.chain - 1) in cost:
                cost_chain = cost[str(duel.chain - 1)]
            else:
                cost_chain = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        if user == 1:
            pass
        elif user == 2:
            if mine_or_other == 1:
                mine_or_other = 2
            elif mine_or_other == 2:
                mine_or_other = 1
        if mine_or_other == 1:
            tmp = self.graves[deck_id]["mygrave"]
        elif mine_or_other == 2:
            tmp = self.graves[deck_id]["othergrave"]
        elif mine_or_other == 3 or mine_or_other == 0:
            tmp = self.graves[deck_id]["commongrave"]
        user_graves = tmp
        return_value = []
        for user_grave in user_graves:
            flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:

                    if exclude_det in cost_chain:
                        for cost_det in cost_chain[exclude_det]:
                            if user_grave["place_unique_id"] == cost_det["place_unique_id"]:
                                flag = False
                                continue
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if user_grave["place_unique_id"] == mess_det["place_unique_id"]:
                                flag = False
                                continue
            if not self.check_monster_condition_det(
                    monster_effect_det, user_grave, user, effect_kind, 1, "grave", deck_id, 0, 0
            ):
                flag = False
            if flag is True:
                if strategy != "": 
                    if strategy in user_grave["variables"]:
                        tmp_variable = user_grave["variables"][strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        user_grave, user, "grave", deck_id, 0, 0, strategy, mine_or_other, int(tmp_variable["value"])
                    )
                else:
                    value = 0
                if equation_kind != "number" :
                    variable = user_grave["det"]["variables"][equation_kind][
                                    "value"
                                ]
                else:
                    variable = 1
                tmp2 = {}
                tmp2["det"] = user_grave
                tmp2["mine_or_other"] = mine_or_other
                tmp2["user"] = user
                tmp2["place"] = "grave"
                tmp2["deck_id"] = deck_id
                tmp2["x"] = 0
                tmp2["y"] = 0
                tmp2["place_unique_id"] = user_grave["place_unique_id"]
                tmp2["strategy_value"] = value
                tmp2["variable"] = variable
                return_value.append(tmp2)
        return_value = sorted(return_value, key=lambda x: x["strategy_value"], reverse=strategy_up_or_down)
        return_value3 = []
        for return_value2 in return_value:
                del return_value2["strategy_value"]
                count += int(return_value2["variable"])
                del return_value2["variable"]
                return_value3.append(return_value2)
                if count >= min and min_flag is True:
                    return return_value3,count
                if count >= num:
                    return return_value3,count

        return return_value3,count

    def return_hand2(
            self,
            duel,
            deck_id,
            user,
            mine_or_other,
            deck_name,
            exclude="",
            monster_effect_det=None,
            num=0,
            strategy = "",
            strategy_up_or_down = 0,
            min = 0,
            min_flag = False,
            equation_kind = "number"
    ):
        if num == 0:
            return [],0
        mine_or_other = int(mine_or_other)
        count = 0
        cost = self.cost
        mess = self.mess
        effect_kind = duel.ask_kind
        if duel.in_cost is True:
            if str(duel.chain) in cost:
                cost_chain = cost[str(duel.chain)]
            else:
                cost_chain = []
        else:
            if str(duel.chain - 1) in cost:
                cost_chain = cost[str(duel.chain - 1)]
            else:
                cost_chain = []
        if str(duel.chain - 1) in mess:
            mess = mess[str(duel.chain - 1)]
        else:
            mess = []
        if user == 1:
            pass
        elif user == 2:
            if mine_or_other == 1:
                mine_or_other = 2
            elif mine_or_other == 2:
                mine_or_other = 1
        if mine_or_other == 1:
            tmp = self.hands[deck_id]["myhand"]
        elif mine_or_other == 2:
            tmp = self.hands[deck_id]["otherhand"]
        elif mine_or_other == 3 or mine_or_other == 0:
            tmp = self.hands[deck_id]["commonhand"]
        user_hands = tmp
        return_value = []
        for user_hand in user_hands:
            flag = True
            if exclude != "":
                excludes = exclude.split(",")
                for exclude_det in excludes:

                    if exclude_det in cost_chain:
                        for cost_det in cost_chain[exclude_det]:
                            if user_hand["place_unique_id"] == cost_det["place_unique_id"]:
                                flag = False
                                continue
                    if exclude_det in mess:
                        for mess_det in mess[exclude_det]:
                            if user_hand["place_unique_id"] == mess_det["place_unique_id"]:
                                flag = False
                                continue
            if not self.check_monster_condition_det(
                    monster_effect_det, user_hand, user, effect_kind, 1, "hand", deck_id, 0, 0
            ):
                flag = False
            if flag is True:
                if strategy != "": 
                    if strategy in user_hand["variables"]:
                        tmp_variable = user_hand["variables"][strategy]
                        if not tmp_variable["value"].isnumeric():
                            tmp_variable["value"] = 0
                    else:
                        tmp_variable = {}
                        tmp_variable["value"] = 0
                    value = self.check_change_val(
                        user_hand, user, "hand", deck_id, 0, 0, strategy, mine_or_other, int(tmp_variable["value"])
                    )
                else:
                    value = 0
                if equation_kind != "number" :
                    variable = user_hand["variables"][equation_kind][
                                    "value"
                                ]
                else: 
                    variable = 1
                tmp2 = {}
                tmp2["det"] = user_hand
                tmp2["mine_or_other"] = mine_or_other
                tmp2["user"] = user
                tmp2["place"] = "hand"
                tmp2["deck_id"] = deck_id
                tmp2["x"] = 0
                tmp2["y"] = 0
                tmp2["place_unique_id"] = user_hand["place_unique_id"]
                tmp2["strategy_value"] = value
                tmp2["variable"] = variable
                return_value.append(tmp2)
        
        return_value = sorted(return_value, key=lambda x: x["strategy_value"], reverse=strategy_up_or_down)
        return_value3 = []
        for return_value2 in return_value:
                del return_value2["strategy_value"]
                count += int(return_value2["variable"])
                del return_value2["variable"]
                return_value3.append(return_value2)
                if count >= min and min_flag is True:
                    return return_value3,count
                if count >= num:
                    return return_value3,count

        return return_value3,count
    def each(self,monster_effect_text):
        duel = self.duel
        det = json.loads(monster_effect_text)
        as_monster_effect = det["each"]
        each_val = det["val"]
        if "del" in det:
            del_ary = det["del"].split(",")
        else:
            del_ary = []
        max = det["max"]
        if int(max) <= duel.each:
            duel.each = 0
            return False
        tmp_mess = self.mess
        cost_tmp = self.cost
        timing_tmp = self.timing_mess
        if as_monster_effect[0] == "-":
            if duel.chain - 2 < 0:
                place1 = []
            else:
                place1 = tmp_mess[str(duel.chain - 2)][as_monster_effect[1:]]
        elif as_monster_effect[0] == "~":
            if duel.in_cost is True:
                if as_monster_effect not in cost_tmp[str(self.tmp_chain)]:
                    place1 = []
                else:
                    place1 = cost_tmp[str(self.tmp_chain)][
                        as_monster_effect
                    ]
            else:
                if as_monster_effect not in cost_tmp[str(duel.chain - 1)]:
                    place1 = []
                else:
                    place1 = cost_tmp[str(duel.chain - 1)][
                        as_monster_effect
                    ]
        elif as_monster_effect[0] == "%":
            if as_monster_effect not in timing_tmp:
                place1 = []
            else:
                place1 = timing_tmp[as_monster_effect]
        elif as_monster_effect not in tmp_mess[str(duel.chain - 1)]:
            place1 = []
        else:
            place1 = tmp_mess[str(duel.chain - 1)][as_monster_effect]
        if len(place1) <= duel.each:
            duel.each = 0
            return False
        each = place1[duel.each]
        duel.each += 1
        for delete_mess in del_ary:
            if delete_mess in tmp_mess[str(duel.chain-1)]:
                del tmp_mess[str(duel.chain-1)][delete_mess]
        tmp_mess[str(duel.chain-1)][each_val] = []
        tmp_mess[str(duel.chain-1)][each_val].append( each)
        self.mess = tmp_mess
        return True
    def check_once_per_turn_relate(self,user,pid):
        duel = self.duel
        if user == 1:
            if duel.once_per_turn_relate1 == "":
                return True
            once_per_turns = duel.once_per_turn_relate1.split("_")
            if pid in once_per_turns:
                return False
        else:
            if duel.once_per_turn_relate2 == "":
                return True
            once_per_turns = duel.once_per_turn_relate2.split("_")
            if pid in once_per_turns:
                return False
        return True
    def check_once_per_turn_exist(self,user,pid):
        duel = self.duel
        if user == 1:
            if duel.once_per_turn_exist1 == "":
                return True
            once_per_turns = duel.once_per_turn_exist1.split("_")
            if pid in once_per_turns:
                return False
        else:    
            if duel.once_per_turn_exist2 == "":
                return True
            once_per_turns = duel.once_per_turn_exist2.split("_")
            if pid in once_per_turns:
                return False
        return True
    def check_once_per_duel(self,trigger,user):
        duel = self.duel
        if user == 1:
            if duel.once_per_duel1 == "":
                return True
            once_per_duels = duel.once_per_duel1.split("_")
            if str(trigger.id) in once_per_duels:
                return False
        else:    
            if duel.once_per_duel2 == "":
                return True
            once_per_duels = duel.once_per_duel2.split("_")
            if str(trigger.id) in once_per_duels:
                return False
        return True
    def check_once_per_turn(self,trigger,user):
        duel = self.duel
        if user == 1:
            if duel.once_per_turn1 == "":
                return True
            once_per_turns = duel.once_per_turn1.split("_")
            if str(trigger.id) in once_per_turns:
                return False
        else:    
            if duel.once_per_turn2 == "":
                return True
            once_per_turns = duel.once_per_turn2.split("_")
            if str(trigger.id) in once_per_turns:
                return False
        return True
    def check_once_per_turn_group(self,trigger,user):
        duel = self.duel
        if user == 1:
            if duel.once_per_turn_group1 == "":
                return True
            once_per_turns = duel.once_per_turn_group1.split("_")
            if str(trigger.once_per_turn_group) in once_per_turns:
                return False
        else:    
            if duel.once_per_turn_group2 == "":
                return True
            once_per_turns = duel.once_per_turn_group2.split("_")
            if str(trigger.once_per_turn_group) in once_per_turns:
                return False
        return True
    def check_once_per_turn_monster_group(self,trigger,user,monster):
        duel = self.duel
        pid = monster["det"]["place_unique_id"]
        if user == 1:
            if duel.once_per_turn_monster_group1 == "":
                return True
            once_per_turns = duel.once_per_turn_monster_group1.split("_")
            if str(trigger.once_per_turn_monster_group)+"*"+pid in once_per_turns:
                return False
        else:    
            if duel.once_per_turn_monster_group2 == "":
                return True
            once_per_turns = duel.once_per_turn_monster_group2.split("_")
            if str(trigger.once_per_turn_monster_group)+"*"+pid in once_per_turns:
                return False
        return True
    def check_once_per_turn_monster(self,trigger,user,monster):
        duel = self.duel
        pid = monster["det"]["place_unique_id"]
        if user == 1:
            if duel.once_per_turn_monster1 == "":
                return True
            once_per_turns = duel.once_per_turn_monster1.split("_")
            if str(trigger.id)+"*"+pid in once_per_turns:
                return False
        else:    
            if duel.once_per_turn_monster2 == "":
                return True
            once_per_turns = duel.once_per_turn_monster2.split("_")
            if str(trigger.id)+"*"+pid in once_per_turns:
                return False
        return True
    '''
    def check_once_per_turn_monster_group(self,trigger,user,monster):
        duel = self.duel
        pid = monster["det"]["place_unique_id"]
        if trigger.once_turn_group == 0:
            return True
        if user == 1:
            if duel.once_per_turn_monster1 == "":
                return True
            once_per_turns = duel.once_per_turn_monster1.split("_")
            if str(trigger.once_per_turn_group)+"*"+pid in once_per_turns: 
                return False
        else:    
            if duel.once_per_turn_monster2 == "":
                return True
            once_per_turns = duel.once_per_turn_monster2.split("_")
            if str(trigger.once_per_turn_group)+"*"+pid in once_per_turns:
                return False
        return True
    '''
    ''' askがなかった場合 '''
    def do_next(self,monster_effect,user):
        if monster_effect.if_not_to_2 is False:
            if monster_effect.pac:
                return self._pac(monster_effect.pac)
            else:
                if monster_effect.monster_effect_next is not None:
                    return monster_effect.monster_effect_next
                else:
                    return self.pop_pac(user)
        else:
            if monster_effect.pac2:
                return self._pac(monster_effect.pac2)
            else:
                if monster_effect.monster_effect_next2 is not None:
                    return monster_effect.monster_effect_next2
                else:
                    return self.pop_pac(user)


    def do_cost_next_ai(self,cost,user):
        self.invoke_flag = False
        if cost.pac:
            return self._pac_cost(cost.pac)
        else:
            if cost.cost_next:
                return cost.cost_next
            else:
                return self.pop_pac_cost(user)
    def do_cost_next(self,cost,user):
        if cost.if_not_to_2 is False or self.invoke_flag is True:
            self.invoke_flag = False
            if cost.pac:
                return self._pac_cost(cost.pac)
            else:
                if cost.cost_next:
                    return cost.cost_next
                else:
                    return self.pop_pac_cost(user)
        else:
            if cost.pac2:
                return self._pac_cost(cost.pac2)
            else:
                if cost.cost_next2 is not None:
                    return cost.cost_next2
                else:
                    return self.pop_pac_cost(user)


    def timing_auto(self):
        duel = self.duel
        if duel.timing3 is not None and duel.chain == 0:
            if duel.timing3.timing_auto is True:
                if duel.timing_fresh is False:
                    duel.timing3 = duel.timing3.next_timing
                    duel.timing_fresh = True
                else:
                    duel.timing_fresh = False
            if duel.timing is None and duel.timing2 is None and duel.timing3 is None:
                self.timing_mess = {}
            if duel.mute == 1:
                selfj.unmute()
            duel.mute = 0
        elif duel.timing2 is not None and duel.chain == 0:
            if duel.timing2.timing_auto is True:
                if duel.timing_fresh is False:
                    duel.timing2 = duel.timing2.next_timing
                    duel.timing_fresh = True
                    self.check_eternal_effect(
                        decks, graves, hands, duel.phase, duel.user_turn, user, other_user
                    )
                else:
                    duel.timing_fresh = False
            if duel.timing is None and duel.timing2 is None:
                self.timing_mess = {}
            if duel.mute == 1:
                self.unmute()
            duel.mute = 0
        elif duel.timing is not None and duel.chain == 0:
            if duel.timing.timing_auto is True:
                if duel.timing_fresh is False:
                    duel.timing = duel.timing.next_timing
                    duel.timing_fresh = True
                    self.check_eternal_effect(
                        decks, graves, hands, duel.phase, duel.user_turn, user, other_user
                    )
                else:
                    duel.timing_fresh = False
            if duel.timing is None:
                self.timing_mess = {}
            if duel.mute == 1:
                self.unmute()
            duel.mute = 0
            
    def search_place_unique_id(self,y,place_unique_id):
        field = self.field
        x = -1
        for x_range in range(20):
            if field[x_range][y]["det"] is None:
                continue
            elif field[x_range][y]["det"]["place_unique_id"] == place_unique_id:
                x = x_range
                break
        return x
    def create_token(self,monster_effect,user):
        return_value = []
        effect = json.loads(monster_effect)
        effect = effect["monster"][0]["monster"]
        id = int(effect["monster_effect"])
        monster = Monster.objects.filter(id=int(id)).first()
        tmp = {}
        tmp6 = {}
        tmp["flag"] = 0
        tmp["token"] = monster.token_flag
        tmp["monster_name"] = monster.monster_name
        tmp["id"] = monster.id
        tmp["org_id"] = monster.id
        tmp["monster_sentence"] = monster.monster_sentence
        tmp["img"] = monster.img
        tmp["instead_img"] = monster.instead_img
        monsteritems = (
            MonsterItem.objects.all()
                .filter(monster_id__id=id)
                .order_by("-monster_variables_id__priority")
                .select_related("monster_variables_id")
                .select_related("monster_variables_id__monster_variable_kind_id")
        )

        for monsteritem in monsteritems:
            tmp5 = {}
            monster_variable = monsteritem.monster_variables_id
            tmp5["name"] = monster_variable.monster_variable_name
            tmp5["minus"] = monster_variable.monster_variable_minus
            tmp5["value"] = monsteritem.monster_item_text
            tmp5["i_val"] = monsteritem.monster_item_text
            tmp5["i_i_val"] = monsteritem.monster_item_text
            tmp2 = monsteritem.monster_item_text.split("_")
            if monster_variable.monster_variable_kind_id.monster_variable_name == "数値":
                tmp5["str"] = tmp5["value"]
            else:
                tmp5["str"] = ""
                for tmp3 in tmp2:
                    tmp4 = monster_variable.monster_variable_kind_id.monster_variable_sentence.split(
                        "|"
                    )
                    tmp5["str"] += tmp4[int(tmp3) - 1]
            tmp6[monster_variable.monster_variable_name] = tmp5
        tmp["variables"] = tmp6
        tmp["place"] = "deck"
        tmp["from"] = None
        tmp["noeffect"] = ""
        tmp["nochoose"] = ""
        tmp["owner"] = user
        tmp["user"] = user
        tmp["mine_or_other"] = user
        tmp["deck_id"] = 1
        tmp["card_unique_id"] = str(uuid.uuid4())
        tmp["place_unique_id"] = str(uuid.uuid4())
        return_tmp = {}
        return_tmp["x"] = 0
        return_tmp["y"] = 0
        return_tmp["place"] = "none"
        return_tmp["mine_or_other"] = user
        return_tmp["deck_id"] = 0
        return_tmp["org_det"] = copy.deepcopy(tmp)
        return_tmp["det"] = self.copy_monster_from_deck(
            tmp, 0, user
        )
        return_value.append(return_tmp)
        return return_value

    def max2(self,choices,choices2):
#        if choices[0] is None and choices2[0] is None:
            return max(choices[1],choices2[1])
#        if choices[0] is not None and choices2[0] is not None:
#            return max(choices[1],choices2[1])
#        if choices[0] is not None:
#            return choices[1]
 #       return choices2[1]
